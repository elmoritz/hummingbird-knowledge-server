[
  {
    "id": "route-handler-dispatcher-only",
    "title": "Route Handlers Are Dispatchers Only",
    "content": "In Hummingbird 2.x clean architecture, route handlers have exactly one job: dispatch to the service layer and return the result. They must not contain business logic, database calls, or service construction.\n\n```swift\n// ✅ Correct — pure dispatcher\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    let user = try await context.dependencies.userService.create(dto)\n    return CreateUserResponse(user)\n}\n\n// ❌ Wrong — business logic in handler\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    guard !dto.email.isEmpty else { throw HTTPError(.badRequest) }\n    let hashed = BCrypt.hash(dto.password)\n    let user = User(email: dto.email, passwordHash: hashed)\n    try await db.save(user)\n    return user\n}\n```",
    "layer": "controller",
    "patternIds": ["dispatcher-pattern", "thin-controller"],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-layer-no-hummingbird",
    "title": "Service Layer Must Not Import Hummingbird",
    "content": "The service layer encodes business logic independently of any web framework. No Hummingbird import means the service can be tested without an HTTP context and can be reused across transports.\n\n```swift\n// ✅ Correct — pure Swift service\nimport Foundation\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n\n    func create(_ request: CreateUserRequest) async throws -> User {\n        guard !request.email.isEmpty else {\n            throw AppError.invalidInput(reason: \"Email must not be empty\")\n        }\n        return try await repository.insert(User(email: request.email))\n    }\n}\n\n// ❌ Wrong — Hummingbird leaked into service layer\nimport Hummingbird\n\nstruct UserService {\n    func create(_ req: Request) async throws -> Response { ... }\n}\n```",
    "layer": "service",
    "patternIds": ["framework-agnostic-service"],
    "violationIds": ["hummingbird-import-in-service"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dependency-injection-via-context",
    "title": "Inject Dependencies via AppRequestContext",
    "content": "All dependencies (services, repositories, stores) must be accessed through `AppRequestContext.dependencies`. This gives you a single, testable, type-safe injection point with zero service-locator magic.\n\n```swift\n// ✅ Correct — from AppRequestContext\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.userService.find(id: id)\n}\n\n// ❌ Wrong — constructed inline\nrouter.get(\"/users/:id\") { request, context in\n    let repo = PostgresUserRepository(pool: globalPool)\n    let service = UserService(repository: repo)\n    return try await service.find(id: request.uri.path)\n}\n```",
    "layer": "context",
    "patternIds": ["dependency-injection", "context-as-container"],
    "violationIds": ["service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "typed-errors-app-error",
    "title": "All Errors Are Typed AppError Values",
    "content": "Every error that crosses a layer boundary must be an `AppError`. Raw third-party errors are caught and wrapped immediately. This keeps HTTP response codes consistent and prevents internal details from leaking to clients.\n\n```swift\n// ✅ Correct — wrap at the boundary\nfunc findUser(id: String) async throws -> User {\n    do {\n        return try await repository.find(id: id)\n    } catch let dbError as DatabaseError {\n        throw AppError.internalError(reason: dbError.localizedDescription)\n    }\n}\n\n// ❌ Wrong — raw error propagates\nfunc findUser(id: String) async throws -> User {\n    return try await repository.find(id: id) // DatabaseError leaks up\n}\n```",
    "layer": null,
    "patternIds": ["typed-errors", "error-wrapping"],
    "violationIds": ["raw-error-thrown-from-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dtos-at-boundaries",
    "title": "DTOs at Every HTTP Boundary",
    "content": "Domain models must never cross the HTTP layer raw. A DTO (Data Transfer Object) gives you a stable public contract independent of internal model evolution.\n\n```swift\n// ✅ Correct — DTO at the boundary\nstruct UserResponse: Codable, ResponseCodable {\n    let id: String\n    let email: String\n    let createdAt: Date\n\n    init(_ user: User) {\n        self.id = user.id.uuidString\n        self.email = user.email\n        self.createdAt = user.createdAt\n    }\n}\n\n// Handler returns DTO, not domain model\nrouter.get(\"/users/:id\") { request, context in\n    let user = try await context.dependencies.userService.find(...)\n    return UserResponse(user) // never `return user` directly\n}\n```",
    "layer": "controller",
    "patternIds": ["dto-pattern", "api-boundary"],
    "violationIds": ["domain-model-across-http-boundary"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "actor-for-shared-state",
    "title": "Use Actors for Shared Mutable State",
    "content": "Any mutable state shared across concurrent requests must be protected by a Swift actor. In Swift 6 strict concurrency mode this is enforced at compile time.\n\n```swift\n// ✅ Correct — actor-protected\nactor RateLimitStore {\n    private var windows: [String: [Date]] = [:]\n\n    func recordRequest(from ip: String, limit: Int) -> Bool {\n        // Safe — all access serialised by the actor\n        ...\n    }\n}\n\n// ❌ Wrong — data race in Swift 6\nvar requestCounts: [String: Int] = [:] // module-level var\n\nrouter.get(\"/\") { request, context in\n    requestCounts[request.uri.path, default: 0] += 1 // data race!\n    ...\n}\n```",
    "layer": "middleware",
    "patternIds": ["actor-model", "swift-concurrency"],
    "violationIds": ["shared-mutable-state-without-actor"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "request-context-di",
    "title": "AppRequestContext as the DI Container",
    "content": "Hummingbird 2.x uses a custom `RequestContext` to thread per-request state. `AppRequestContext` extends this to carry the application's dependency graph. `DependencyInjectionMiddleware` populates it at the start of every request.\n\n```swift\n// The context definition\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies\n\n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        self.dependencies = AppDependencies.placeholder\n    }\n}\n\n// The middleware that fills it in\nstruct DependencyInjectionMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let dependencies: AppDependencies\n\n    func handle(_ request: Request, context: AppRequestContext,\n                next: (Request, AppRequestContext) async throws -> Response) async throws -> Response {\n        var ctx = context\n        ctx.dependencies = dependencies\n        return try await next(request, ctx)\n    }\n}\n```",
    "layer": "context",
    "patternIds": ["request-context", "middleware-di"],
    "violationIds": ["nonisolated-context-access"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "router-middleware-pattern",
    "title": "RouterMiddleware Protocol Pattern",
    "content": "Hummingbird 2.x middleware conforms to `RouterMiddleware`. The associated `Context` type binds the middleware to a specific request context. Middleware is added to the router before routes are registered — order matters.\n\n```swift\nstruct AuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        guard let header = request.headers[.authorization],\n              header == \"Bearer \\(token)\" else {\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// Registration order matters — add before routes\nrouter.add(middleware: DependencyInjectionMiddleware(...))\nrouter.add(middleware: AuthMiddleware(token: ...))\nrouter.get(\"/protected\") { ... }\n```",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "request-pipeline"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-lifecycle-background-service",
    "title": "Background Services via Service Lifecycle",
    "content": "Hummingbird 2.x uses `swift-service-lifecycle` for background work. Implement `Service` and add to the application. The service group manages startup, shutdown, and graceful termination automatically.\n\n```swift\nimport Hummingbird\n\nstruct CacheRefreshService: Service {\n    let cache: CacheStore\n    let interval: Duration\n    let logger: Logger\n\n    func run() async throws {\n        while !Task.isCancelled {\n            do {\n                try await cache.refresh()\n                logger.info(\"Cache refreshed\")\n            } catch {\n                logger.warning(\"Cache refresh failed\", metadata: [\"error\": \"\\(error)\"])\n            }\n            try await Task.sleep(for: interval)\n        }\n    }\n}\n\n// In Application+build.swift:\napp.addServices(CacheRefreshService(cache: cache, interval: .seconds(3600), logger: logger))\n```",
    "layer": "service",
    "patternIds": ["service-lifecycle", "background-service"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "request-validation-via-dto",
    "title": "Request Validation Through DTOs",
    "content": "All HTTP request data (path parameters, query parameters, request bodies) must be validated through DTO decoding, not accessed raw from the request object. DTOs enforce type safety, validation rules, and provide a clean contract between HTTP and service layers.\n\n```swift\n// ✅ Correct — validate through DTO\nstruct CreateUserRequest: Decodable {\n    let email: String\n    let age: Int\n\n    enum CodingKeys: String, CodingKey {\n        case email, age\n    }\n\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        email = try container.decode(String.self, forKey: .email)\n        age = try container.decode(Int.self, forKey: .age)\n        \n        // Validation at the DTO boundary\n        guard email.contains(\"@\") else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .email,\n                in: container,\n                debugDescription: \"Email must be valid\"\n            )\n        }\n        guard age >= 13 else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .age,\n                in: container,\n                debugDescription: \"Must be 13 or older\"\n            )\n        }\n    }\n}\n\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    return try await context.dependencies.userService.create(dto)\n}\n\n// ❌ Wrong — raw parameter access without validation\nrouter.post(\"/users\") { request, context in\n    let email = request.uri.queryParameters[\"email\"] ?? \"\"\n    let ageStr = request.uri.queryParameters[\"age\"] ?? \"0\"\n    let age = Int(ageStr) ?? 0\n    // No validation, unsafe parsing, brittle code\n    return try await context.dependencies.userService.create(email: email, age: age)\n}\n```",
    "layer": "controller",
    "patternIds": ["dto-pattern", "api-boundary", "request-validation"],
    "violationIds": ["unchecked-uri-parameters", "unchecked-query-parameters", "raw-parameter-in-service-call", "missing-request-decode"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "inline-handler-anti-pattern",
    "title": "Anti-Pattern: All Logic Inline in Route Handlers",
    "content": "Tutorials often show all logic inline in a route handler for brevity. This is an anti-pattern in production code: it creates untestable handlers, couples framework to business logic, and makes layers impossible to reason about independently.\n\n```swift\n// ❌ ANTI-PATTERN — tutorial style, not production style\nrouter.post(\"/register\") { request, context in\n    struct Body: Decodable { var email: String; var password: String }\n    let body = try await request.decode(as: Body.self, context: context)\n    guard !body.email.isEmpty else { return Response(status: .badRequest) }\n    let hash = SHA256.hash(data: Data(body.password.utf8)).description\n    // Directly using global DB connection:\n    try await db.execute(\"INSERT INTO users ...\", [body.email, hash])\n    return Response(status: .created)\n}\n```\n\nThe correct approach uses the service layer for all business logic, the repository for DB access, and the context for injection.",
    "layer": "controller",
    "patternIds": [],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": true,
    "correctionId": "route-handler-dispatcher-only",
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "centralized-configuration",
    "title": "Centralized Configuration via AppDependencies",
    "content": "All configuration values (URLs, timeouts, feature flags, limits) must be centralized in a Configuration struct and injected via AppDependencies. Never hardcode values or access environment variables directly in services or handlers.\n\n```swift\n// ✅ Correct — centralized configuration\nstruct AppConfiguration: Sendable {\n    let apiBaseURL: String\n    let databaseURL: String\n    let rateLimitPerMinute: Int\n    let jwtSecret: String\n\n    static func fromEnvironment() throws -> AppConfiguration {\n        guard let apiURL = ProcessInfo.processInfo.environment[\"API_BASE_URL\"],\n              let dbURL = ProcessInfo.processInfo.environment[\"DATABASE_URL\"],\n              let jwtSecret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"] else {\n            throw AppError.configurationError(reason: \"Missing required environment variables\")\n        }\n        return AppConfiguration(\n            apiBaseURL: apiURL,\n            databaseURL: dbURL,\n            rateLimitPerMinute: 60,\n            jwtSecret: jwtSecret\n        )\n    }\n}\n\nstruct AppDependencies: Sendable {\n    let configuration: AppConfiguration\n    let userService: UserService\n    // ... other dependencies\n}\n\n// In service — configuration injected\nstruct UserService {\n    let config: AppConfiguration\n    let repository: any UserRepositoryProtocol\n\n    func authenticate(token: String) throws -> Bool {\n        return JWT.verify(token, secret: config.jwtSecret)\n    }\n}\n\n// ❌ Wrong — direct environment access\nstruct UserService {\n    func authenticate(token: String) throws -> Bool {\n        let secret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"]!\n        return JWT.verify(token, secret: secret)\n    }\n}\n\n// ❌ Wrong — hardcoded values\nstruct RateLimitMiddleware: RouterMiddleware {\n    func handle(_ request: Request, context: AppRequestContext, next: ...) async throws -> Response {\n        let limit = 60 // magic number!\n        ...\n    }\n}\n```",
    "layer": "context",
    "patternIds": ["dependency-injection", "configuration-management"],
    "violationIds": ["direct-env-access", "hardcoded-url", "magic-numbers"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "secure-configuration",
    "title": "Secure Secrets Management",
    "content": "Secrets (API keys, passwords, tokens, encryption keys) must NEVER be hardcoded in source code. They must be loaded from environment variables, secret management services, or encrypted configuration files at application startup.\n\n```swift\n// ✅ Correct — secrets from environment\nstruct AppConfiguration: Sendable {\n    let jwtSecret: String\n    let databasePassword: String\n    let apiKey: String\n\n    static func fromEnvironment() throws -> AppConfiguration {\n        guard let jwtSecret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"],\n              let dbPassword = ProcessInfo.processInfo.environment[\"DATABASE_PASSWORD\"],\n              let apiKey = ProcessInfo.processInfo.environment[\"API_KEY\"],\n              !jwtSecret.isEmpty, !dbPassword.isEmpty, !apiKey.isEmpty else {\n            throw AppError.configurationError(reason: \"Required secrets not found in environment\")\n        }\n        return AppConfiguration(\n            jwtSecret: jwtSecret,\n            databasePassword: dbPassword,\n            apiKey: apiKey\n        )\n    }\n}\n\n// ❌ CRITICAL VULNERABILITY — hardcoded secrets\nstruct AuthService {\n    let jwtSecret = \"super-secret-key-12345\" // ⚠️ NEVER DO THIS!\n    let apiKey = \"sk_live_abc123def456\" // ⚠️ SECURITY BREACH!\n}\n\n// ❌ Wrong — secrets in git-tracked config files\nstruct Config {\n    static let databaseURL = \"postgres://user:password@localhost/db\" // ⚠️ Credentials exposed!\n}\n```\n\nBest practices:\n- Use environment variables for development and production\n- Use secret management services (AWS Secrets Manager, HashiCorp Vault) in production\n- Never commit `.env` files to version control (add to `.gitignore`)\n- Rotate secrets regularly\n- Use different secrets for dev, staging, and production",
    "layer": null,
    "patternIds": ["security", "configuration-management"],
    "violationIds": ["hardcoded-credentials"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "async-concurrency-patterns",
    "title": "Async/Await Concurrency Patterns",
    "content": "Hummingbird 2.x is built on Swift concurrency. All I/O operations (network, file system, database) must use `async`/`await`. Never use blocking APIs (sleep, synchronous URLSession, blocking file I/O) in async contexts — they block the entire thread and prevent other requests from being processed.\n\n```swift\n// ✅ Correct — async/await for all I/O\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user)\n}\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n\n    func find(id: String) async throws -> User {\n        return try await repository.find(id: id) // async database call\n    }\n}\n\n// ❌ Wrong — blocking sleep in handler\nrouter.get(\"/slow\") { request, context in\n    Thread.sleep(forTimeInterval: 1.0) // ⚠️ Blocks executor thread!\n    return Response(status: .ok)\n}\n\n// ❌ Wrong — synchronous network call in async context\nfunc fetchData() async throws -> Data {\n    let url = URL(string: \"https://api.example.com/data\")!\n    let data = try Data(contentsOf: url) // ⚠️ Synchronous I/O blocks thread!\n    return data\n}\n\n// ✅ Correct — async network call\nfunc fetchData() async throws -> Data {\n    let url = URL(string: \"https://api.example.com/data\")!\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n```\n\nFor delays, use `Task.sleep(for:)` instead of `Thread.sleep()`:\n```swift\n// ✅ Correct — non-blocking delay\ntry await Task.sleep(for: .seconds(1))\n\n// ❌ Wrong — blocking delay\nThread.sleep(forTimeInterval: 1.0)\n```",
    "layer": null,
    "patternIds": ["swift-concurrency", "async-await"],
    "violationIds": ["sleep-in-handler", "blocking-sleep-in-async", "synchronous-network-call", "synchronous-database-call-in-async"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "non-blocking-io",
    "title": "Non-Blocking I/O Operations",
    "content": "All file I/O in async contexts must use async APIs. Swift's `FileHandle`, `Data(contentsOf:)`, and `String(contentsOfFile:)` are synchronous and block the thread. Use async file I/O libraries or offload to a background executor.\n\n```swift\n// ✅ Correct — async file I/O (using async FileHandle or custom wrapper)\nimport Foundation\n#if canImport(FoundationNetworking)\nimport FoundationNetworking\n#endif\n\nfunc readFile(at path: String) async throws -> Data {\n    // Option 1: Use async-capable file I/O library (e.g., swift-nio, AsyncFileHandle)\n    // Option 2: Offload to background executor for legacy APIs\n    return try await Task.detached {\n        try Data(contentsOf: URL(fileURLWithPath: path))\n    }.value\n}\n\n// ❌ Wrong — synchronous file I/O in async context\nfunc loadConfig() async throws -> Configuration {\n    let data = try Data(contentsOf: URL(fileURLWithPath: \"/etc/config.json\")) // ⚠️ Blocks thread!\n    return try JSONDecoder().decode(Configuration.self, from: data)\n}\n\n// ✅ Correct — offload to background if no async API available\nfunc loadConfig() async throws -> Configuration {\n    let data = try await Task.detached {\n        try Data(contentsOf: URL(fileURLWithPath: \"/etc/config.json\"))\n    }.value\n    return try JSONDecoder().decode(Configuration.self, from: data)\n}\n```\n\nFor database operations, always use async database clients:\n```swift\n// ✅ Correct — async database client (e.g., PostgresNIO, MongoKitten)\nlet users = try await db.query(\"SELECT * FROM users WHERE id = $1\", [id])\n\n// ❌ Wrong — synchronous database call\nlet users = try db.executeSync(\"SELECT * FROM users WHERE id = $1\", [id])\n```",
    "layer": null,
    "patternIds": ["swift-concurrency", "async-io"],
    "violationIds": ["blocking-io-in-async"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "sendable-types",
    "title": "Sendable Conformance for Concurrent Types",
    "content": "Swift 6 strict concurrency requires that types crossing concurrency boundaries (passed to async functions, stored in actors, captured in closures) conform to `Sendable`. This prevents data races at compile time.\n\n```swift\n// ✅ Correct — Sendable structs for concurrent use\nstruct User: Sendable {\n    let id: UUID\n    let email: String\n    let createdAt: Date\n}\n\nstruct AppConfiguration: Sendable {\n    let apiURL: String\n    let timeout: Duration\n}\n\n// ✅ Correct — @unchecked Sendable for types with internal synchronization\nfinal class DatabasePool: @unchecked Sendable {\n    private let lock = NSLock()\n    private var connections: [Connection] = []\n\n    func getConnection() -> Connection {\n        lock.lock()\n        defer { lock.unlock() }\n        return connections.removeFirst()\n    }\n}\n\n// ❌ Wrong — non-Sendable type crossing concurrency boundary\nclass UserCache { // Missing Sendable conformance\n    var users: [UUID: User] = [:]\n}\n\nfunc cacheUser(_ user: User, in cache: UserCache) async {\n    cache.users[user.id] = user // ⚠️ Data race risk!\n}\n\n// ✅ Correct — use actor instead\nactor UserCache {\n    private var users: [UUID: User] = [:]\n\n    func store(_ user: User) {\n        users[user.id] = user\n    }\n\n    func get(_ id: UUID) -> User? {\n        return users[id]\n    }\n}\n```\n\nSendable conformance rules:\n- Structs with only Sendable properties are automatically Sendable\n- Actors are implicitly Sendable\n- Classes must be `final`, have only immutable properties, and use `@unchecked Sendable` if they have internal synchronization\n- Closures capturing only Sendable values are Sendable",
    "layer": null,
    "patternIds": ["swift-concurrency", "sendable"],
    "violationIds": ["missing-sendable-conformance"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "structured-concurrency",
    "title": "Structured Concurrency with Task Groups",
    "content": "Swift structured concurrency ensures tasks are properly scoped and cancelled. Use `async let` for independent concurrent tasks, `TaskGroup` for dynamic concurrency, and avoid unstructured `Task.detached` unless absolutely necessary.\n\n```swift\n// ✅ Correct — structured concurrency with async let\nfunc fetchUserData(id: String) async throws -> UserData {\n    async let user = userService.find(id: id)\n    async let posts = postService.findByUser(id: id)\n    async let comments = commentService.findByUser(id: id)\n\n    return try await UserData(\n        user: user,\n        posts: posts,\n        comments: comments\n    )\n}\n\n// ✅ Correct — TaskGroup for dynamic concurrency\nfunc fetchMultipleUsers(ids: [String]) async throws -> [User] {\n    return try await withThrowingTaskGroup(of: User.self) { group in\n        for id in ids {\n            group.addTask {\n                try await userService.find(id: id)\n            }\n        }\n        var users: [User] = []\n        for try await user in group {\n            users.append(user)\n        }\n        return users\n    }\n}\n\n// ❌ Wrong — unstructured Task.detached loses cancellation\nfunc processInBackground(data: Data) async {\n    Task.detached { // ⚠️ Not cancelled when parent is cancelled!\n        try? await heavyProcessing(data)\n    }\n    // Function returns immediately, task continues in background\n    // No way to wait for completion or handle errors\n}\n\n// ✅ Correct — child task inherits cancellation\nfunc processInBackground(data: Data) async throws {\n    try await withTaskCancellationHandler {\n        try await heavyProcessing(data)\n    } onCancel: {\n        cleanup()\n    }\n}\n```\n\nUse `Task.detached` only when you need to break actor isolation for a legitimate reason (e.g., avoiding priority inversion). Always handle cancellation explicitly.",
    "layer": null,
    "patternIds": ["swift-concurrency", "task-groups"],
    "violationIds": ["task-detached-without-isolation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "structured-logging",
    "title": "Structured Logging with swift-log",
    "content": "Hummingbird 2.x uses `swift-log` for structured logging. Never use `print()` for logging — it's not structured, can't be filtered by level, and won't appear in production logs. Always log errors with context metadata.\n\n```swift\nimport Logging\n\nstruct UserService {\n    let logger: Logger\n    let repository: any UserRepositoryProtocol\n\n    func create(_ request: CreateUserRequest) async throws -> User {\n        logger.info(\"Creating user\", metadata: [\"email\": \"\\(request.email)\"])\n\n        do {\n            let user = try await repository.insert(User(email: request.email))\n            logger.info(\"User created\", metadata: [\n                \"userId\": \"\\(user.id)\",\n                \"email\": \"\\(user.email)\"\n            ])\n            return user\n        } catch let error as DatabaseError {\n            logger.error(\"Database error creating user\", metadata: [\n                \"email\": \"\\(request.email)\",\n                \"error\": \"\\(error)\",\n                \"errorCode\": \"\\(error.code)\"\n            ])\n            throw AppError.internalError(reason: \"Failed to create user\")\n        }\n    }\n}\n\n// ❌ Wrong — print instead of logger\nfunc deleteUser(id: String) async throws {\n    do {\n        try await repository.delete(id: id)\n    } catch {\n        print(\"Error: \\(error)\") // ⚠️ Not structured, no context, can't filter!\n        throw error\n    }\n}\n\n// ❌ Wrong — swallowed error with no logging\nfunc updateUser(id: String, email: String) async throws {\n    do {\n        try await repository.update(id: id, email: email)\n    } catch {\n        // ⚠️ Error discarded silently — impossible to debug!\n    }\n}\n```\n\nLog levels:\n- `trace`: Very detailed debugging (e.g., request/response bodies)\n- `debug`: Debugging information (e.g., cache hits, query plans)\n- `info`: Normal application flow (e.g., \"User created\", \"Request started\")\n- `notice`: Important but normal events (e.g., \"Configuration loaded\")\n- `warning`: Unusual but recoverable (e.g., \"Retry attempt 2/3\")\n- `error`: Errors that should be investigated (e.g., database failures)\n- `critical`: System instability (e.g., \"Out of memory\")",
    "layer": null,
    "patternIds": ["logging", "observability"],
    "violationIds": ["print-in-error-handler", "swallowed-error", "error-discarded-with-underscore"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "explicit-http-status-codes",
    "title": "Explicit HTTP Status Codes",
    "content": "Every HTTP response must have an explicit status code. Hummingbird infers `.ok` (200) for most types, but you should be explicit, especially for error cases, redirects, and created resources.\n\n```swift\n// ✅ Correct — explicit status codes\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    let user = try await context.dependencies.userService.create(dto)\n    return Response(status: .created, body: .init(data: try JSONEncoder().encode(CreateUserResponse(user))))\n}\n\nrouter.delete(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    try await context.dependencies.userService.delete(id: id)\n    return Response(status: .noContent)\n}\n\nrouter.get(\"/health\") { request, context in\n    return Response(status: .ok, body: .init(string: \"OK\"))\n}\n\n// ❌ Wrong — missing status code (defaults to 200)\nrouter.post(\"/users\") { request, context in\n    let user = try await context.dependencies.userService.create(...)\n    return CreateUserResponse(user) // ⚠️ Should be 201 Created, not 200 OK!\n}\n\n// ❌ Wrong — generic status for errors\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    guard let user = try await context.dependencies.userService.find(id: id) else {\n        return Response(status: .badRequest) // ⚠️ Should be 404 Not Found, not 400 Bad Request!\n    }\n    return UserResponse(user)\n}\n```\n\nCommon status codes:\n- `200 OK`: Successful GET, PUT, PATCH\n- `201 Created`: Successful POST that creates a resource\n- `204 No Content`: Successful DELETE or update with no response body\n- `400 Bad Request`: Invalid input (validation error)\n- `401 Unauthorized`: Missing or invalid authentication\n- `403 Forbidden`: Valid auth but insufficient permissions\n- `404 Not Found`: Resource doesn't exist\n- `409 Conflict`: Duplicate resource or constraint violation\n- `500 Internal Server Error`: Unexpected server error",
    "layer": "controller",
    "patternIds": ["http-status-codes", "rest-api"],
    "violationIds": ["response-without-status-code"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "explicit-content-type-headers",
    "title": "Explicit Content-Type Headers",
    "content": "HTTP responses should explicitly set the Content-Type header to indicate the response format. While Hummingbird can infer types for some responses, being explicit prevents client parsing errors and improves API clarity.\n\n```swift\n// ✅ Correct — explicit Content-Type for JSON\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    let body = try JSONEncoder().encode(UserResponse(user))\n    var response = Response(status: .ok, body: .init(data: body))\n    response.headers[.contentType] = \"application/json\"\n    return response\n}\n\n// ✅ Correct — using ResponseCodable (sets Content-Type automatically)\nstruct UserResponse: ResponseCodable {\n    let id: String\n    let email: String\n}\n\nrouter.get(\"/users/:id\") { request, context in\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user) // Content-Type: application/json set automatically\n}\n\n// ✅ Correct — explicit Content-Type for HTML\nrouter.get(\"/dashboard\") { request, context in\n    let html = \"<html><body>Dashboard</body></html>\"\n    var response = Response(status: .ok, body: .init(string: html))\n    response.headers[.contentType] = \"text/html; charset=utf-8\"\n    return response\n}\n\n// ❌ Wrong — missing Content-Type for binary data\nrouter.get(\"/download\") { request, context in\n    let data = try await fileService.readFile(\"report.pdf\")\n    return Response(status: .ok, body: .init(data: data)) // ⚠️ Missing Content-Type!\n}\n\n// ✅ Correct — explicit Content-Type for binary data\nrouter.get(\"/download\") { request, context in\n    let data = try await fileService.readFile(\"report.pdf\")\n    var response = Response(status: .ok, body: .init(data: data))\n    response.headers[.contentType] = \"application/pdf\"\n    response.headers[.contentDisposition] = \"attachment; filename=\\\"report.pdf\\\"\"\n    return response\n}\n```\n\nCommon Content-Type values:\n- `application/json`: JSON data (most common for REST APIs)\n- `text/html; charset=utf-8`: HTML pages\n- `text/plain; charset=utf-8`: Plain text\n- `application/pdf`: PDF documents\n- `image/png`, `image/jpeg`: Images\n- `application/octet-stream`: Generic binary data",
    "layer": "controller",
    "patternIds": ["http-headers", "rest-api"],
    "violationIds": ["response-missing-content-type"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  }
]
