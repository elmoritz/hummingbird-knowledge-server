[
  {
    "id": "route-handler-dispatcher-only",
    "title": "Route Handlers Are Dispatchers Only",
    "content": "In Hummingbird 2.x clean architecture, route handlers have exactly one job: dispatch to the service layer and return the result. They must not contain business logic, database calls, or service construction.\n\n```swift\n// ✅ Correct — pure dispatcher\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    let user = try await context.dependencies.userService.create(dto)\n    return CreateUserResponse(user)\n}\n\n// ❌ Wrong — business logic in handler\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    guard !dto.email.isEmpty else { throw HTTPError(.badRequest) }\n    let hashed = BCrypt.hash(dto.password)\n    let user = User(email: dto.email, passwordHash: hashed)\n    try await db.save(user)\n    return user\n}\n```",
    "layer": "controller",
    "patternIds": ["dispatcher-pattern", "thin-controller"],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-layer-no-hummingbird",
    "title": "Service Layer Must Not Import Hummingbird",
    "content": "The service layer encodes business logic independently of any web framework. No Hummingbird import means the service can be tested without an HTTP context and can be reused across transports.\n\n```swift\n// ✅ Correct — pure Swift service\nimport Foundation\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n\n    func create(_ request: CreateUserRequest) async throws -> User {\n        guard !request.email.isEmpty else {\n            throw AppError.invalidInput(reason: \"Email must not be empty\")\n        }\n        return try await repository.insert(User(email: request.email))\n    }\n}\n\n// ❌ Wrong — Hummingbird leaked into service layer\nimport Hummingbird\n\nstruct UserService {\n    func create(_ req: Request) async throws -> Response { ... }\n}\n```",
    "layer": "service",
    "patternIds": ["framework-agnostic-service"],
    "violationIds": ["hummingbird-import-in-service"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dependency-injection-via-context",
    "title": "Inject Dependencies via AppRequestContext",
    "content": "All dependencies (services, repositories, stores) must be accessed through `AppRequestContext.dependencies`. This gives you a single, testable, type-safe injection point with zero service-locator magic.\n\n```swift\n// ✅ Correct — from AppRequestContext\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.userService.find(id: id)\n}\n\n// ❌ Wrong — constructed inline\nrouter.get(\"/users/:id\") { request, context in\n    let repo = PostgresUserRepository(pool: globalPool)\n    let service = UserService(repository: repo)\n    return try await service.find(id: request.uri.path)\n}\n```",
    "layer": "context",
    "patternIds": ["dependency-injection", "context-as-container"],
    "violationIds": ["service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "typed-errors-app-error",
    "title": "All Errors Are Typed AppError Values",
    "content": "Every error that crosses a layer boundary must be an `AppError`. Raw third-party errors are caught and wrapped immediately. This keeps HTTP response codes consistent and prevents internal details from leaking to clients.\n\n```swift\n// ✅ Correct — wrap at the boundary\nfunc findUser(id: String) async throws -> User {\n    do {\n        return try await repository.find(id: id)\n    } catch let dbError as DatabaseError {\n        throw AppError.internalError(reason: dbError.localizedDescription)\n    }\n}\n\n// ❌ Wrong — raw error propagates\nfunc findUser(id: String) async throws -> User {\n    return try await repository.find(id: id) // DatabaseError leaks up\n}\n```",
    "layer": null,
    "patternIds": ["typed-errors", "error-wrapping"],
    "violationIds": ["raw-error-thrown-from-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dtos-at-boundaries",
    "title": "DTOs at Every HTTP Boundary",
    "content": "Domain models must never cross the HTTP layer raw. A DTO (Data Transfer Object) gives you a stable public contract independent of internal model evolution.\n\n```swift\n// ✅ Correct — DTO at the boundary\nstruct UserResponse: Codable, ResponseCodable {\n    let id: String\n    let email: String\n    let createdAt: Date\n\n    init(_ user: User) {\n        self.id = user.id.uuidString\n        self.email = user.email\n        self.createdAt = user.createdAt\n    }\n}\n\n// Handler returns DTO, not domain model\nrouter.get(\"/users/:id\") { request, context in\n    let user = try await context.dependencies.userService.find(...)\n    return UserResponse(user) // never `return user` directly\n}\n```",
    "layer": "controller",
    "patternIds": ["dto-pattern", "api-boundary"],
    "violationIds": ["domain-model-across-http-boundary"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "actor-for-shared-state",
    "title": "Use Actors for Shared Mutable State",
    "content": "Any mutable state shared across concurrent requests must be protected by a Swift actor. In Swift 6 strict concurrency mode this is enforced at compile time.\n\n```swift\n// ✅ Correct — actor-protected\nactor RateLimitStore {\n    private var windows: [String: [Date]] = [:]\n\n    func recordRequest(from ip: String, limit: Int) -> Bool {\n        // Safe — all access serialised by the actor\n        ...\n    }\n}\n\n// ❌ Wrong — data race in Swift 6\nvar requestCounts: [String: Int] = [:] // module-level var\n\nrouter.get(\"/\") { request, context in\n    requestCounts[request.uri.path, default: 0] += 1 // data race!\n    ...\n}\n```",
    "layer": "middleware",
    "patternIds": ["actor-model", "swift-concurrency"],
    "violationIds": ["shared-mutable-state-without-actor"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "request-context-di",
    "title": "AppRequestContext as the DI Container",
    "content": "Hummingbird 2.x uses a custom `RequestContext` to thread per-request state. `AppRequestContext` extends this to carry the application's dependency graph. `DependencyInjectionMiddleware` populates it at the start of every request.\n\n```swift\n// The context definition\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies\n\n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        self.dependencies = AppDependencies.placeholder\n    }\n}\n\n// The middleware that fills it in\nstruct DependencyInjectionMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let dependencies: AppDependencies\n\n    func handle(_ request: Request, context: AppRequestContext,\n                next: (Request, AppRequestContext) async throws -> Response) async throws -> Response {\n        var ctx = context\n        ctx.dependencies = dependencies\n        return try await next(request, ctx)\n    }\n}\n```",
    "layer": "context",
    "patternIds": ["request-context", "middleware-di"],
    "violationIds": ["nonisolated-context-access"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "router-middleware-pattern",
    "title": "RouterMiddleware Protocol Pattern",
    "content": "Hummingbird 2.x middleware conforms to `RouterMiddleware`. The associated `Context` type binds the middleware to a specific request context. Middleware is added to the router before routes are registered — order matters.\n\n```swift\nstruct AuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        guard let header = request.headers[.authorization],\n              header == \"Bearer \\(token)\" else {\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// Registration order matters — add before routes\nrouter.add(middleware: DependencyInjectionMiddleware(...))\nrouter.add(middleware: AuthMiddleware(token: ...))\nrouter.get(\"/protected\") { ... }\n```",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "request-pipeline"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-lifecycle-background-service",
    "title": "Background Services via Service Lifecycle",
    "content": "Hummingbird 2.x uses `swift-service-lifecycle` for background work. Implement `Service` and add to the application. The service group manages startup, shutdown, and graceful termination automatically.\n\n```swift\nimport Hummingbird\n\nstruct CacheRefreshService: Service {\n    let cache: CacheStore\n    let interval: Duration\n    let logger: Logger\n\n    func run() async throws {\n        while !Task.isCancelled {\n            do {\n                try await cache.refresh()\n                logger.info(\"Cache refreshed\")\n            } catch {\n                logger.warning(\"Cache refresh failed\", metadata: [\"error\": \"\\(error)\"])\n            }\n            try await Task.sleep(for: interval)\n        }\n    }\n}\n\n// In Application+build.swift:\napp.addServices(CacheRefreshService(cache: cache, interval: .seconds(3600), logger: logger))\n```",
    "layer": "service",
    "patternIds": ["service-lifecycle", "background-service"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "request-validation-via-dto",
    "title": "Request Validation Through DTOs",
    "content": "All HTTP request data (path parameters, query parameters, request bodies) must be validated through DTO decoding, not accessed raw from the request object. DTOs enforce type safety, validation rules, and provide a clean contract between HTTP and service layers.\n\n```swift\n// ✅ Correct — validate through DTO\nstruct CreateUserRequest: Decodable {\n    let email: String\n    let age: Int\n\n    enum CodingKeys: String, CodingKey {\n        case email, age\n    }\n\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        email = try container.decode(String.self, forKey: .email)\n        age = try container.decode(Int.self, forKey: .age)\n        \n        // Validation at the DTO boundary\n        guard email.contains(\"@\") else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .email,\n                in: container,\n                debugDescription: \"Email must be valid\"\n            )\n        }\n        guard age >= 13 else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .age,\n                in: container,\n                debugDescription: \"Must be 13 or older\"\n            )\n        }\n    }\n}\n\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    return try await context.dependencies.userService.create(dto)\n}\n\n// ❌ Wrong — raw parameter access without validation\nrouter.post(\"/users\") { request, context in\n    let email = request.uri.queryParameters[\"email\"] ?? \"\"\n    let ageStr = request.uri.queryParameters[\"age\"] ?? \"0\"\n    let age = Int(ageStr) ?? 0\n    // No validation, unsafe parsing, brittle code\n    return try await context.dependencies.userService.create(email: email, age: age)\n}\n```",
    "layer": "controller",
    "patternIds": ["dto-pattern", "api-boundary", "request-validation"],
    "violationIds": ["unchecked-uri-parameters", "unchecked-query-parameters", "raw-parameter-in-service-call", "missing-request-decode"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "inline-handler-anti-pattern",
    "title": "Anti-Pattern: All Logic Inline in Route Handlers",
    "content": "Tutorials often show all logic inline in a route handler for brevity. This is an anti-pattern in production code: it creates untestable handlers, couples framework to business logic, and makes layers impossible to reason about independently.\n\n```swift\n// ❌ ANTI-PATTERN — tutorial style, not production style\nrouter.post(\"/register\") { request, context in\n    struct Body: Decodable { var email: String; var password: String }\n    let body = try await request.decode(as: Body.self, context: context)\n    guard !body.email.isEmpty else { return Response(status: .badRequest) }\n    let hash = SHA256.hash(data: Data(body.password.utf8)).description\n    // Directly using global DB connection:\n    try await db.execute(\"INSERT INTO users ...\", [body.email, hash])\n    return Response(status: .created)\n}\n```\n\nThe correct approach uses the service layer for all business logic, the repository for DB access, and the context for injection.",
    "layer": "controller",
    "patternIds": [],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": true,
    "correctionId": "route-handler-dispatcher-only",
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "centralized-configuration",
    "title": "Centralized Configuration via AppDependencies",
    "content": "All configuration values (URLs, timeouts, feature flags, limits) must be centralized in a Configuration struct and injected via AppDependencies. Never hardcode values or access environment variables directly in services or handlers.\n\n```swift\n// ✅ Correct — centralized configuration\nstruct AppConfiguration: Sendable {\n    let apiBaseURL: String\n    let databaseURL: String\n    let rateLimitPerMinute: Int\n    let jwtSecret: String\n\n    static func fromEnvironment() throws -> AppConfiguration {\n        guard let apiURL = ProcessInfo.processInfo.environment[\"API_BASE_URL\"],\n              let dbURL = ProcessInfo.processInfo.environment[\"DATABASE_URL\"],\n              let jwtSecret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"] else {\n            throw AppError.configurationError(reason: \"Missing required environment variables\")\n        }\n        return AppConfiguration(\n            apiBaseURL: apiURL,\n            databaseURL: dbURL,\n            rateLimitPerMinute: 60,\n            jwtSecret: jwtSecret\n        )\n    }\n}\n\nstruct AppDependencies: Sendable {\n    let configuration: AppConfiguration\n    let userService: UserService\n    // ... other dependencies\n}\n\n// In service — configuration injected\nstruct UserService {\n    let config: AppConfiguration\n    let repository: any UserRepositoryProtocol\n\n    func authenticate(token: String) throws -> Bool {\n        return JWT.verify(token, secret: config.jwtSecret)\n    }\n}\n\n// ❌ Wrong — direct environment access\nstruct UserService {\n    func authenticate(token: String) throws -> Bool {\n        let secret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"]!\n        return JWT.verify(token, secret: secret)\n    }\n}\n\n// ❌ Wrong — hardcoded values\nstruct RateLimitMiddleware: RouterMiddleware {\n    func handle(_ request: Request, context: AppRequestContext, next: ...) async throws -> Response {\n        let limit = 60 // magic number!\n        ...\n    }\n}\n```",
    "layer": "context",
    "patternIds": ["dependency-injection", "configuration-management"],
    "violationIds": ["direct-env-access", "hardcoded-url", "magic-numbers"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "secure-configuration",
    "title": "Secure Secrets Management",
    "content": "Secrets (API keys, passwords, tokens, encryption keys) must NEVER be hardcoded in source code. They must be loaded from environment variables, secret management services, or encrypted configuration files at application startup.\n\n```swift\n// ✅ Correct — secrets from environment\nstruct AppConfiguration: Sendable {\n    let jwtSecret: String\n    let databasePassword: String\n    let apiKey: String\n\n    static func fromEnvironment() throws -> AppConfiguration {\n        guard let jwtSecret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"],\n              let dbPassword = ProcessInfo.processInfo.environment[\"DATABASE_PASSWORD\"],\n              let apiKey = ProcessInfo.processInfo.environment[\"API_KEY\"],\n              !jwtSecret.isEmpty, !dbPassword.isEmpty, !apiKey.isEmpty else {\n            throw AppError.configurationError(reason: \"Required secrets not found in environment\")\n        }\n        return AppConfiguration(\n            jwtSecret: jwtSecret,\n            databasePassword: dbPassword,\n            apiKey: apiKey\n        )\n    }\n}\n\n// ❌ CRITICAL VULNERABILITY — hardcoded secrets\nstruct AuthService {\n    let jwtSecret = \"super-secret-key-12345\" // ⚠️ NEVER DO THIS!\n    let apiKey = \"sk_live_abc123def456\" // ⚠️ SECURITY BREACH!\n}\n\n// ❌ Wrong — secrets in git-tracked config files\nstruct Config {\n    static let databaseURL = \"postgres://user:password@localhost/db\" // ⚠️ Credentials exposed!\n}\n```\n\nBest practices:\n- Use environment variables for development and production\n- Use secret management services (AWS Secrets Manager, HashiCorp Vault) in production\n- Never commit `.env` files to version control (add to `.gitignore`)\n- Rotate secrets regularly\n- Use different secrets for dev, staging, and production",
    "layer": null,
    "patternIds": ["security", "configuration-management"],
    "violationIds": ["hardcoded-credentials"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "async-concurrency-patterns",
    "title": "Async/Await Concurrency Patterns",
    "content": "Hummingbird 2.x is built on Swift concurrency. All I/O operations (network, file system, database) must use `async`/`await`. Never use blocking APIs (sleep, synchronous URLSession, blocking file I/O) in async contexts — they block the entire thread and prevent other requests from being processed.\n\n```swift\n// ✅ Correct — async/await for all I/O\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user)\n}\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n\n    func find(id: String) async throws -> User {\n        return try await repository.find(id: id) // async database call\n    }\n}\n\n// ❌ Wrong — blocking sleep in handler\nrouter.get(\"/slow\") { request, context in\n    Thread.sleep(forTimeInterval: 1.0) // ⚠️ Blocks executor thread!\n    return Response(status: .ok)\n}\n\n// ❌ Wrong — synchronous network call in async context\nfunc fetchData() async throws -> Data {\n    let url = URL(string: \"https://api.example.com/data\")!\n    let data = try Data(contentsOf: url) // ⚠️ Synchronous I/O blocks thread!\n    return data\n}\n\n// ✅ Correct — async network call\nfunc fetchData() async throws -> Data {\n    let url = URL(string: \"https://api.example.com/data\")!\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n```\n\nFor delays, use `Task.sleep(for:)` instead of `Thread.sleep()`:\n```swift\n// ✅ Correct — non-blocking delay\ntry await Task.sleep(for: .seconds(1))\n\n// ❌ Wrong — blocking delay\nThread.sleep(forTimeInterval: 1.0)\n```",
    "layer": null,
    "patternIds": ["swift-concurrency", "async-await"],
    "violationIds": ["sleep-in-handler", "blocking-sleep-in-async", "synchronous-network-call", "synchronous-database-call-in-async"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "non-blocking-io",
    "title": "Non-Blocking I/O Operations",
    "content": "All file I/O in async contexts must use async APIs. Swift's `FileHandle`, `Data(contentsOf:)`, and `String(contentsOfFile:)` are synchronous and block the thread. Use async file I/O libraries or offload to a background executor.\n\n```swift\n// ✅ Correct — async file I/O (using async FileHandle or custom wrapper)\nimport Foundation\n#if canImport(FoundationNetworking)\nimport FoundationNetworking\n#endif\n\nfunc readFile(at path: String) async throws -> Data {\n    // Option 1: Use async-capable file I/O library (e.g., swift-nio, AsyncFileHandle)\n    // Option 2: Offload to background executor for legacy APIs\n    return try await Task.detached {\n        try Data(contentsOf: URL(fileURLWithPath: path))\n    }.value\n}\n\n// ❌ Wrong — synchronous file I/O in async context\nfunc loadConfig() async throws -> Configuration {\n    let data = try Data(contentsOf: URL(fileURLWithPath: \"/etc/config.json\")) // ⚠️ Blocks thread!\n    return try JSONDecoder().decode(Configuration.self, from: data)\n}\n\n// ✅ Correct — offload to background if no async API available\nfunc loadConfig() async throws -> Configuration {\n    let data = try await Task.detached {\n        try Data(contentsOf: URL(fileURLWithPath: \"/etc/config.json\"))\n    }.value\n    return try JSONDecoder().decode(Configuration.self, from: data)\n}\n```\n\nFor database operations, always use async database clients:\n```swift\n// ✅ Correct — async database client (e.g., PostgresNIO, MongoKitten)\nlet users = try await db.query(\"SELECT * FROM users WHERE id = $1\", [id])\n\n// ❌ Wrong — synchronous database call\nlet users = try db.executeSync(\"SELECT * FROM users WHERE id = $1\", [id])\n```",
    "layer": null,
    "patternIds": ["swift-concurrency", "async-io"],
    "violationIds": ["blocking-io-in-async"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "sendable-types",
    "title": "Sendable Conformance for Concurrent Types",
    "content": "Swift 6 strict concurrency requires that types crossing concurrency boundaries (passed to async functions, stored in actors, captured in closures) conform to `Sendable`. This prevents data races at compile time.\n\n```swift\n// ✅ Correct — Sendable structs for concurrent use\nstruct User: Sendable {\n    let id: UUID\n    let email: String\n    let createdAt: Date\n}\n\nstruct AppConfiguration: Sendable {\n    let apiURL: String\n    let timeout: Duration\n}\n\n// ✅ Correct — @unchecked Sendable for types with internal synchronization\nfinal class DatabasePool: @unchecked Sendable {\n    private let lock = NSLock()\n    private var connections: [Connection] = []\n\n    func getConnection() -> Connection {\n        lock.lock()\n        defer { lock.unlock() }\n        return connections.removeFirst()\n    }\n}\n\n// ❌ Wrong — non-Sendable type crossing concurrency boundary\nclass UserCache { // Missing Sendable conformance\n    var users: [UUID: User] = [:]\n}\n\nfunc cacheUser(_ user: User, in cache: UserCache) async {\n    cache.users[user.id] = user // ⚠️ Data race risk!\n}\n\n// ✅ Correct — use actor instead\nactor UserCache {\n    private var users: [UUID: User] = [:]\n\n    func store(_ user: User) {\n        users[user.id] = user\n    }\n\n    func get(_ id: UUID) -> User? {\n        return users[id]\n    }\n}\n```\n\nSendable conformance rules:\n- Structs with only Sendable properties are automatically Sendable\n- Actors are implicitly Sendable\n- Classes must be `final`, have only immutable properties, and use `@unchecked Sendable` if they have internal synchronization\n- Closures capturing only Sendable values are Sendable",
    "layer": null,
    "patternIds": ["swift-concurrency", "sendable"],
    "violationIds": ["missing-sendable-conformance"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "structured-concurrency",
    "title": "Structured Concurrency with Task Groups",
    "content": "Swift structured concurrency ensures tasks are properly scoped and cancelled. Use `async let` for independent concurrent tasks, `TaskGroup` for dynamic concurrency, and avoid unstructured `Task.detached` unless absolutely necessary.\n\n```swift\n// ✅ Correct — structured concurrency with async let\nfunc fetchUserData(id: String) async throws -> UserData {\n    async let user = userService.find(id: id)\n    async let posts = postService.findByUser(id: id)\n    async let comments = commentService.findByUser(id: id)\n\n    return try await UserData(\n        user: user,\n        posts: posts,\n        comments: comments\n    )\n}\n\n// ✅ Correct — TaskGroup for dynamic concurrency\nfunc fetchMultipleUsers(ids: [String]) async throws -> [User] {\n    return try await withThrowingTaskGroup(of: User.self) { group in\n        for id in ids {\n            group.addTask {\n                try await userService.find(id: id)\n            }\n        }\n        var users: [User] = []\n        for try await user in group {\n            users.append(user)\n        }\n        return users\n    }\n}\n\n// ❌ Wrong — unstructured Task.detached loses cancellation\nfunc processInBackground(data: Data) async {\n    Task.detached { // ⚠️ Not cancelled when parent is cancelled!\n        try? await heavyProcessing(data)\n    }\n    // Function returns immediately, task continues in background\n    // No way to wait for completion or handle errors\n}\n\n// ✅ Correct — child task inherits cancellation\nfunc processInBackground(data: Data) async throws {\n    try await withTaskCancellationHandler {\n        try await heavyProcessing(data)\n    } onCancel: {\n        cleanup()\n    }\n}\n```\n\nUse `Task.detached` only when you need to break actor isolation for a legitimate reason (e.g., avoiding priority inversion). Always handle cancellation explicitly.",
    "layer": null,
    "patternIds": ["swift-concurrency", "task-groups"],
    "violationIds": ["task-detached-without-isolation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "structured-logging",
    "title": "Structured Logging with swift-log",
    "content": "Hummingbird 2.x uses `swift-log` for structured logging. Never use `print()` for logging — it's not structured, can't be filtered by level, and won't appear in production logs. Always log errors with context metadata.\n\n```swift\nimport Logging\n\nstruct UserService {\n    let logger: Logger\n    let repository: any UserRepositoryProtocol\n\n    func create(_ request: CreateUserRequest) async throws -> User {\n        logger.info(\"Creating user\", metadata: [\"email\": \"\\(request.email)\"])\n\n        do {\n            let user = try await repository.insert(User(email: request.email))\n            logger.info(\"User created\", metadata: [\n                \"userId\": \"\\(user.id)\",\n                \"email\": \"\\(user.email)\"\n            ])\n            return user\n        } catch let error as DatabaseError {\n            logger.error(\"Database error creating user\", metadata: [\n                \"email\": \"\\(request.email)\",\n                \"error\": \"\\(error)\",\n                \"errorCode\": \"\\(error.code)\"\n            ])\n            throw AppError.internalError(reason: \"Failed to create user\")\n        }\n    }\n}\n\n// ❌ Wrong — print instead of logger\nfunc deleteUser(id: String) async throws {\n    do {\n        try await repository.delete(id: id)\n    } catch {\n        print(\"Error: \\(error)\") // ⚠️ Not structured, no context, can't filter!\n        throw error\n    }\n}\n\n// ❌ Wrong — swallowed error with no logging\nfunc updateUser(id: String, email: String) async throws {\n    do {\n        try await repository.update(id: id, email: email)\n    } catch {\n        // ⚠️ Error discarded silently — impossible to debug!\n    }\n}\n```\n\nLog levels:\n- `trace`: Very detailed debugging (e.g., request/response bodies)\n- `debug`: Debugging information (e.g., cache hits, query plans)\n- `info`: Normal application flow (e.g., \"User created\", \"Request started\")\n- `notice`: Important but normal events (e.g., \"Configuration loaded\")\n- `warning`: Unusual but recoverable (e.g., \"Retry attempt 2/3\")\n- `error`: Errors that should be investigated (e.g., database failures)\n- `critical`: System instability (e.g., \"Out of memory\")",
    "layer": null,
    "patternIds": ["logging", "observability"],
    "violationIds": ["print-in-error-handler", "swallowed-error", "error-discarded-with-underscore"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "explicit-http-status-codes",
    "title": "Explicit HTTP Status Codes",
    "content": "Every HTTP response must have an explicit status code. Hummingbird infers `.ok` (200) for most types, but you should be explicit, especially for error cases, redirects, and created resources.\n\n```swift\n// ✅ Correct — explicit status codes\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    let user = try await context.dependencies.userService.create(dto)\n    return Response(status: .created, body: .init(data: try JSONEncoder().encode(CreateUserResponse(user))))\n}\n\nrouter.delete(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    try await context.dependencies.userService.delete(id: id)\n    return Response(status: .noContent)\n}\n\nrouter.get(\"/health\") { request, context in\n    return Response(status: .ok, body: .init(string: \"OK\"))\n}\n\n// ❌ Wrong — missing status code (defaults to 200)\nrouter.post(\"/users\") { request, context in\n    let user = try await context.dependencies.userService.create(...)\n    return CreateUserResponse(user) // ⚠️ Should be 201 Created, not 200 OK!\n}\n\n// ❌ Wrong — generic status for errors\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    guard let user = try await context.dependencies.userService.find(id: id) else {\n        return Response(status: .badRequest) // ⚠️ Should be 404 Not Found, not 400 Bad Request!\n    }\n    return UserResponse(user)\n}\n```\n\nCommon status codes:\n- `200 OK`: Successful GET, PUT, PATCH\n- `201 Created`: Successful POST that creates a resource\n- `204 No Content`: Successful DELETE or update with no response body\n- `400 Bad Request`: Invalid input (validation error)\n- `401 Unauthorized`: Missing or invalid authentication\n- `403 Forbidden`: Valid auth but insufficient permissions\n- `404 Not Found`: Resource doesn't exist\n- `409 Conflict`: Duplicate resource or constraint violation\n- `500 Internal Server Error`: Unexpected server error",
    "layer": "controller",
    "patternIds": ["http-status-codes", "rest-api"],
    "violationIds": ["response-without-status-code"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "explicit-content-type-headers",
    "title": "Explicit Content-Type Headers",
    "content": "HTTP responses should explicitly set the Content-Type header to indicate the response format. While Hummingbird can infer types for some responses, being explicit prevents client parsing errors and improves API clarity.\n\n```swift\n// ✅ Correct — explicit Content-Type for JSON\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    let body = try JSONEncoder().encode(UserResponse(user))\n    var response = Response(status: .ok, body: .init(data: body))\n    response.headers[.contentType] = \"application/json\"\n    return response\n}\n\n// ✅ Correct — using ResponseCodable (sets Content-Type automatically)\nstruct UserResponse: ResponseCodable {\n    let id: String\n    let email: String\n}\n\nrouter.get(\"/users/:id\") { request, context in\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user) // Content-Type: application/json set automatically\n}\n\n// ✅ Correct — explicit Content-Type for HTML\nrouter.get(\"/dashboard\") { request, context in\n    let html = \"<html><body>Dashboard</body></html>\"\n    var response = Response(status: .ok, body: .init(string: html))\n    response.headers[.contentType] = \"text/html; charset=utf-8\"\n    return response\n}\n\n// ❌ Wrong — missing Content-Type for binary data\nrouter.get(\"/download\") { request, context in\n    let data = try await fileService.readFile(\"report.pdf\")\n    return Response(status: .ok, body: .init(data: data)) // ⚠️ Missing Content-Type!\n}\n\n// ✅ Correct — explicit Content-Type for binary data\nrouter.get(\"/download\") { request, context in\n    let data = try await fileService.readFile(\"report.pdf\")\n    var response = Response(status: .ok, body: .init(data: data))\n    response.headers[.contentType] = \"application/pdf\"\n    response.headers[.contentDisposition] = \"attachment; filename=\\\"report.pdf\\\"\"\n    return response\n}\n```\n\nCommon Content-Type values:\n- `application/json`: JSON data (most common for REST APIs)\n- `text/html; charset=utf-8`: HTML pages\n- `text/plain; charset=utf-8`: Plain text\n- `application/pdf`: PDF documents\n- `image/png`, `image/jpeg`: Images\n- `application/octet-stream`: Generic binary data",
    "layer": "controller",
    "patternIds": ["http-headers", "rest-api"],
    "violationIds": ["response-missing-content-type"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "router-groups-and-prefixes",
    "title": "Router Groups and Route Prefixes",
    "content": "Hummingbird 2.x routers support grouping routes with shared prefixes and middleware. Use `router.group()` to organize related endpoints logically, apply scoped middleware, and avoid repetitive path segments. Groups can be nested for hierarchical API structures.\n\n```swift\n// ✅ Correct — using router groups with prefixes\nlet apiV1 = router.group(\"/api/v1\")\n\napiV1.group(\"/users\")\n    .get { request, context in\n        // GET /api/v1/users\n        return try await context.dependencies.userService.list()\n    }\n    .get(\"/:id\") { request, context in\n        // GET /api/v1/users/:id\n        let id = try context.parameters.require(\"id\")\n        return try await context.dependencies.userService.find(id: id)\n    }\n    .post { request, context in\n        // POST /api/v1/users\n        let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n        return try await context.dependencies.userService.create(dto)\n    }\n\napiV1.group(\"/posts\")\n    .get { request, context in\n        // GET /api/v1/posts\n        return try await context.dependencies.postService.list()\n    }\n    .get(\"/:id\") { request, context in\n        // GET /api/v1/posts/:id\n        let id = try context.parameters.require(\"id\")\n        return try await context.dependencies.postService.find(id: id)\n    }\n\n// ✅ Correct — applying middleware to a group\nlet authenticated = router.group()\n    .add(middleware: AuthMiddleware())\n\nauthenticated.group(\"/admin\")\n    .get(\"/dashboard\") { request, context in\n        // Requires authentication via AuthMiddleware\n        return try await context.dependencies.adminService.getDashboard()\n    }\n    .delete(\"/users/:id\") { request, context in\n        let id = try context.parameters.require(\"id\")\n        return try await context.dependencies.userService.delete(id: id)\n    }\n\n// ❌ Wrong — repeating prefixes in every route\nrouter.get(\"/api/v1/users\") { request, context in\n    return try await context.dependencies.userService.list()\n}\n\nrouter.get(\"/api/v1/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.userService.find(id: id)\n}\n\nrouter.get(\"/api/v1/posts\") { request, context in\n    return try await context.dependencies.postService.list()\n}\n\nrouter.get(\"/api/v1/posts/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.postService.find(id: id)\n}\n// ⚠️ Repetitive, hard to refactor, middleware must be added to each route\n\n// ❌ Wrong — applying middleware to individual routes instead of groups\nrouter.get(\"/admin/dashboard\") { request, context in\n    // Must manually check auth in every handler\n    guard try await context.dependencies.authService.isAuthenticated(request) else {\n        throw HTTPError(.unauthorized)\n    }\n    return try await context.dependencies.adminService.getDashboard()\n}\n```\n\nBest practices:\n- Group routes by resource (`/users`, `/posts`, `/comments`)\n- Use versioned groups (`/api/v1`, `/api/v2`) for API versioning\n- Apply middleware at the group level, not per route\n- Nest groups for hierarchical structures (`/api/v1/admin/users`)\n- Keep route definitions close to related routes for readability",
    "layer": "controller",
    "patternIds": ["router-groups", "route-organization", "middleware-scoping"],
    "violationIds": ["repeated-route-prefixes", "middleware-duplication"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "response-body-streaming-patterns",
    "title": "Response Body Types and Streaming Patterns",
    "content": "Hummingbird 2.x uses NIO's `ByteBuffer` and Swift's `AsyncSequence` for response bodies. Understanding these types is critical for efficient streaming, file downloads, and large response handling. Never buffer entire large responses in memory — stream them instead.\n\n```swift\nimport Hummingbird\nimport NIOCore\n\n// ✅ Correct — streaming file download with AsyncSequence\nrouter.get(\"/download/:filename\") { request, context in\n    let filename = try context.parameters.require(\"filename\")\n    let fileStream = try await context.dependencies.fileService.streamFile(filename)\n    \n    // ResponseBody accepts AsyncSequence<ByteBuffer, Error>\n    var response = Response(\n        status: .ok,\n        body: .init(asyncSequence: fileStream)\n    )\n    response.headers[.contentType] = \"application/octet-stream\"\n    response.headers[.contentDisposition] = \"attachment; filename=\\\"\\(filename)\\\"\"\n    return response\n}\n\n// ✅ Correct — streaming JSON array with backpressure handling\nstruct UserStreamService {\n    func streamAllUsers() -> AsyncStream<ByteBuffer, Error> {\n        AsyncStream { continuation in\n            Task {\n                do {\n                    let users = try await repository.findAll()\n                    var buffer = ByteBufferAllocator().buffer(capacity: 1024)\n                    buffer.writeString(\"[\")\n                    continuation.yield(buffer)\n                    \n                    for (index, user) in users.enumerated() {\n                        var itemBuffer = ByteBufferAllocator().buffer(capacity: 256)\n                        if index > 0 {\n                            itemBuffer.writeString(\",\")\n                        }\n                        let userData = try JSONEncoder().encode(user)\n                        itemBuffer.writeBytes(userData)\n                        continuation.yield(itemBuffer)\n                    }\n                    \n                    var endBuffer = ByteBufferAllocator().buffer(capacity: 1)\n                    endBuffer.writeString(\"]\")\n                    continuation.yield(endBuffer)\n                    continuation.finish()\n                } catch {\n                    continuation.finish(throwing: error)\n                }\n            }\n        }\n    }\n}\n\n// ✅ Correct — static ByteBuffer for small responses\nrouter.get(\"/health\") { request, context in\n    var buffer = ByteBufferAllocator().buffer(capacity: 16)\n    buffer.writeString(\"{\\\"status\\\":\\\"ok\\\"}\")\n    var response = Response(status: .ok, body: .init(byteBuffer: buffer))\n    response.headers[.contentType] = \"application/json\"\n    return response\n}\n\n// ❌ Wrong — loading entire large file into memory\nrouter.get(\"/download/:filename\") { request, context in\n    let filename = try context.parameters.require(\"filename\")\n    let data = try await fileService.readEntireFile(filename) // ⚠️ OOM for large files!\n    var buffer = ByteBufferAllocator().buffer(capacity: data.count)\n    buffer.writeBytes(data)\n    return Response(status: .ok, body: .init(byteBuffer: buffer))\n}\n\n// ❌ Wrong — buffering entire stream before sending\nrouter.get(\"/users/export\") { request, context in\n    let users = try await context.dependencies.userService.findAll()\n    var allData = Data()\n    for user in users {\n        allData.append(try JSONEncoder().encode(user)) // ⚠️ Builds entire response in memory!\n    }\n    var buffer = ByteBufferAllocator().buffer(capacity: allData.count)\n    buffer.writeBytes(allData)\n    return Response(status: .ok, body: .init(byteBuffer: buffer))\n}\n\n// ❌ Wrong — AsyncSequence without error handling\nfunc streamData() -> AsyncStream<ByteBuffer, Never> {\n    AsyncStream { continuation in\n        Task {\n            let data = try! await fetchData() // ⚠️ Force-try crashes on error!\n            var buffer = ByteBufferAllocator().buffer(capacity: data.count)\n            buffer.writeBytes(data)\n            continuation.yield(buffer)\n            continuation.finish()\n        }\n    }\n}\n\n// ✅ Correct — AsyncSequence with proper error propagation\nfunc streamData() -> AsyncThrowingStream<ByteBuffer, Error> {\n    AsyncThrowingStream { continuation in\n        Task {\n            do {\n                let data = try await fetchData()\n                var buffer = ByteBufferAllocator().buffer(capacity: data.count)\n                buffer.writeBytes(data)\n                continuation.yield(buffer)\n                continuation.finish()\n            } catch {\n                continuation.finish(throwing: error)\n            }\n        }\n    }\n}\n```\n\nKey types:\n- `ByteBuffer`: NIO's efficient byte container (copy-on-write, ref-counted)\n- `ResponseBody`: Wrapper supporting `.init(byteBuffer:)`, `.init(asyncSequence:)`, `.init(data:)`, `.init(string:)`\n- `AsyncSequence<ByteBuffer, Error>`: Protocol for streaming responses\n- `AsyncStream` / `AsyncThrowingStream`: Concrete async sequence types\n\nCommon pitfalls:\n- Loading entire files into memory instead of streaming\n- Buffering entire response before sending (defeats streaming)\n- Using `AsyncStream<ByteBuffer, Never>` for operations that can fail (use `AsyncThrowingStream`)\n- Not setting `Content-Length` header for known-size responses\n- Not handling backpressure (NIO handles this automatically with AsyncSequence)\n- Creating new `ByteBufferAllocator` per request (use shared allocator from context)\n- Force-unwrapping or `try!` in stream producers (always propagate errors via continuation)",
    "layer": "controller",
    "patternIds": ["response-streaming", "bytebuffer", "async-sequence", "backpressure"],
    "violationIds": ["buffering-entire-stream", "missing-stream-error-handling", "force-try-in-stream", "oom-large-file-in-memory"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "multipart-form-data-handling",
    "title": "Multipart Form Data and File Uploads",
    "content": "Hummingbird 2.x handles multipart form data through the request body stream. For file uploads, you must parse the multipart boundary, extract parts, and stream file content to storage without buffering the entire file in memory. Use a multipart parser library or implement streaming multipart parsing.\n\n```swift\nimport Hummingbird\nimport NIOCore\n\n// ✅ Correct — streaming file upload with multipart parsing\nrouter.post(\"/upload\") { request, context in\n    guard let contentType = request.headers[.contentType],\n          contentType.hasPrefix(\"multipart/form-data\") else {\n        throw HTTPError(.badRequest, message: \"Content-Type must be multipart/form-data\")\n    }\n    \n    // Extract boundary from Content-Type header\n    guard let boundary = extractBoundary(from: contentType) else {\n        throw HTTPError(.badRequest, message: \"Missing boundary in Content-Type\")\n    }\n    \n    let uploadService = context.dependencies.uploadService\n    let fileMetadata = try await uploadService.handleMultipartUpload(\n        body: request.body,\n        boundary: boundary\n    )\n    \n    return Response(\n        status: .created,\n        body: .init(data: try JSONEncoder().encode(UploadResponse(fileMetadata)))\n    )\n}\n\n// Service layer — streaming multipart parser\nstruct UploadService {\n    let storage: any FileStorageProtocol\n    let logger: Logger\n    \n    func handleMultipartUpload(\n        body: Request.Body,\n        boundary: String\n    ) async throws -> FileMetadata {\n        var parser = MultipartParser(boundary: boundary)\n        var currentFile: FileUploadContext?\n        \n        for try await chunk in body {\n            let parts = try parser.parse(chunk)\n            \n            for part in parts {\n                switch part {\n                case .headers(let headers):\n                    // Extract filename and content-type from part headers\n                    guard let disposition = headers[\"content-disposition\"],\n                          let filename = extractFilename(from: disposition) else {\n                        throw AppError.invalidInput(reason: \"Missing filename\")\n                    }\n                    \n                    let contentType = headers[\"content-type\"] ?? \"application/octet-stream\"\n                    currentFile = try await storage.createUpload(\n                        filename: filename,\n                        contentType: contentType\n                    )\n                    \n                case .body(let data):\n                    guard let file = currentFile else {\n                        throw AppError.invalidInput(reason: \"Received body before headers\")\n                    }\n                    try await storage.writeChunk(data, to: file)\n                    \n                case .end:\n                    guard let file = currentFile else {\n                        throw AppError.invalidInput(reason: \"Received end before file start\")\n                    }\n                    try await storage.finalizeUpload(file)\n                    currentFile = nil\n                }\n            }\n        }\n        \n        guard let file = currentFile else {\n            throw AppError.invalidInput(reason: \"No file uploaded\")\n        }\n        \n        return try await storage.getMetadata(for: file)\n    }\n}\n\nfunc extractBoundary(from contentType: String) -> String? {\n    let components = contentType.split(separator: \";\")\n    for component in components {\n        let trimmed = component.trimmingCharacters(in: .whitespaces)\n        if trimmed.hasPrefix(\"boundary=\") {\n            return String(trimmed.dropFirst(\"boundary=\".count))\n        }\n    }\n    return nil\n}\n\n// ❌ Wrong — buffering entire file upload in memory\nrouter.post(\"/upload\") { request, context in\n    var allData = Data()\n    for try await chunk in request.body {\n        allData.append(contentsOf: chunk.readableBytesView) // ⚠️ OOM for large files!\n    }\n    \n    // Parse entire multipart body from memory\n    let file = try parseMultipart(allData)\n    try await storage.save(file)\n    return Response(status: .created)\n}\n\n// ❌ Wrong — missing Content-Type validation\nrouter.post(\"/upload\") { request, context in\n    // No check for multipart/form-data!\n    let file = try await uploadService.handleUpload(request.body)\n    return Response(status: .created)\n}\n\n// ❌ Wrong — synchronous file write in async context\nrouter.post(\"/upload\") { request, context in\n    let filename = UUID().uuidString\n    let handle = FileHandle(forWritingAtPath: \"/uploads/\\(filename)\")! // ⚠️ Synchronous!\n    \n    for try await chunk in request.body {\n        handle.write(Data(buffer: chunk)) // ⚠️ Blocks executor thread!\n    }\n    \n    handle.closeFile()\n    return Response(status: .created)\n}\n```\n\nBest practices:\n- Always validate `Content-Type: multipart/form-data` before parsing\n- Extract and validate the boundary parameter from Content-Type header\n- Stream file chunks directly to storage (disk, S3, etc.) without buffering entire file\n- Set upload size limits to prevent DoS attacks (use middleware or check Content-Length)\n- Validate filenames to prevent directory traversal attacks (sanitize `../`, absolute paths)\n- Use async file I/O or object storage SDKs (never synchronous file operations)\n- Return file metadata (ID, size, content-type) in response, not the file content itself\n- Clean up partial uploads on errors (delete incomplete files)\n- Consider using a battle-tested multipart parser library instead of custom parsing",
    "layer": "controller",
    "patternIds": ["multipart-form-data", "file-upload", "request-streaming"],
    "violationIds": ["buffering-entire-upload", "missing-content-type-validation", "synchronous-file-write", "directory-traversal-vulnerability"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "request-body-streaming",
    "title": "Streaming Request Bodies with AsyncSequence",
    "content": "Hummingbird 2.x provides `Request.Body` as an `AsyncSequence<ByteBuffer>` for streaming large request payloads. Never call `request.decode()` for large uploads — it buffers the entire body. Instead, iterate the body stream chunk-by-chunk for memory-efficient processing.\n\n```swift\nimport Hummingbird\nimport NIOCore\n\n// ✅ Correct — streaming request body processing\nrouter.post(\"/ingest\") { request, context in\n    var totalBytes = 0\n    var hasher = SHA256()\n    \n    // Process request body as stream\n    for try await chunk in request.body {\n        totalBytes += chunk.readableBytes\n        hasher.update(data: chunk.readableBytesView)\n        \n        // Stream to storage or process incrementally\n        try await context.dependencies.dataService.processChunk(chunk)\n    }\n    \n    let hash = hasher.finalize()\n    logger.info(\"Processed streaming request\", metadata: [\n        \"totalBytes\": \"\\(totalBytes)\",\n        \"hash\": \"\\(hash.hexString)\"\n    ])\n    \n    return Response(status: .accepted)\n}\n\n// ✅ Correct — streaming CSV import line-by-line\nrouter.post(\"/import/csv\") { request, context in\n    var lineBuffer = ByteBufferAllocator().buffer(capacity: 1024)\n    var recordsImported = 0\n    \n    for try await chunk in request.body {\n        lineBuffer.writeImmutableBuffer(chunk)\n        \n        // Process complete lines\n        while let line = lineBuffer.readLine() {\n            let record = try parseCSVLine(line)\n            try await context.dependencies.importService.insertRecord(record)\n            recordsImported += 1\n        }\n    }\n    \n    // Process remaining partial line if any\n    if lineBuffer.readableBytes > 0 {\n        let line = lineBuffer.readString(length: lineBuffer.readableBytes)!\n        let record = try parseCSVLine(line)\n        try await context.dependencies.importService.insertRecord(record)\n        recordsImported += 1\n    }\n    \n    return Response(\n        status: .ok,\n        body: .init(data: try JSONEncoder().encode(ImportResponse(recordsImported: recordsImported)))\n    )\n}\n\n// ✅ Correct — streaming request with Content-Length validation\nrouter.post(\"/upload\") { request, context in\n    guard let contentLengthStr = request.headers[.contentLength],\n          let contentLength = Int(contentLengthStr) else {\n        throw HTTPError(.lengthRequired, message: \"Content-Length header required\")\n    }\n    \n    let maxUploadSize = 100 * 1024 * 1024 // 100 MB\n    guard contentLength <= maxUploadSize else {\n        throw HTTPError(.payloadTooLarge, message: \"Upload exceeds \\(maxUploadSize) bytes\")\n    }\n    \n    var totalReceived = 0\n    for try await chunk in request.body {\n        totalReceived += chunk.readableBytes\n        \n        // Enforce limit even if Content-Length header is wrong\n        guard totalReceived <= maxUploadSize else {\n            throw HTTPError(.payloadTooLarge, message: \"Upload size exceeded during transfer\")\n        }\n        \n        try await context.dependencies.uploadService.writeChunk(chunk)\n    }\n    \n    guard totalReceived == contentLength else {\n        throw HTTPError(.badRequest, message: \"Received \\(totalReceived) bytes, expected \\(contentLength)\")\n    }\n    \n    return Response(status: .created)\n}\n\n// ❌ Wrong — buffering entire request body\nrouter.post(\"/process\") { request, context in\n    var allData = ByteBufferAllocator().buffer(capacity: 0)\n    for try await chunk in request.body {\n        allData.writeImmutableBuffer(chunk) // ⚠️ Buffers entire request in memory!\n    }\n    \n    try await processData(allData) // Memory spike for large requests\n    return Response(status: .ok)\n}\n\n// ❌ Wrong — using request.decode() for large payloads\nrouter.post(\"/import\") { request, context in\n    // ⚠️ Buffers entire JSON array in memory before parsing!\n    let records = try await request.decode(as: [ImportRecord].self, context: context)\n    \n    for record in records {\n        try await context.dependencies.importService.insertRecord(record)\n    }\n    \n    return Response(status: .ok)\n}\n\n// ❌ Wrong — no upload size limit enforcement\nrouter.post(\"/upload\") { request, context in\n    // No size limit! ⚠️ Attacker can send unlimited data\n    for try await chunk in request.body {\n        try await storage.write(chunk)\n    }\n    return Response(status: .created)\n}\n\n// ❌ Wrong — ignoring backpressure in stream processing\nrouter.post(\"/ingest\") { request, context in\n    for try await chunk in request.body {\n        // Spawning detached task loses backpressure!\n        Task.detached {\n            try? await slowProcessor.process(chunk) // ⚠️ Tasks queue up unbounded!\n        }\n    }\n    return Response(status: .accepted)\n}\n\n// ✅ Correct — respecting backpressure\nrouter.post(\"/ingest\") { request, context in\n    for try await chunk in request.body {\n        // Await each chunk processing before reading next\n        try await slowProcessor.process(chunk) // Backpressure maintained\n    }\n    return Response(status: .accepted)\n}\n```\n\nKey points:\n- `Request.Body` is `AsyncSequence<ByteBuffer>` — iterate with `for try await`\n- Each iteration yields a `ByteBuffer` chunk (not necessarily the entire body)\n- Use `request.decode()` only for small, trusted payloads (< 1 MB)\n- For large uploads, stream chunks to storage without buffering\n- Always enforce upload size limits (check `Content-Length`, track bytes received)\n- Validate `Content-Length` header matches actual received bytes\n- Respect backpressure — await async operations inside loop, don't spawn detached tasks\n- For line-based protocols (CSV, NDJSON), accumulate chunks into line buffer\n- Use `ByteBuffer.readLine()` or manual parsing for incremental processing\n- Clean up resources on error (close files, abort multipart uploads, etc.)\n\nCommon mistakes:\n- Buffering entire body before processing (defeats streaming)\n- Using `request.decode()` for large uploads (OOM risk)\n- Missing upload size limits (DoS vulnerability)\n- Spawning detached tasks in loop (loses backpressure, unbounded memory growth)\n- Not validating Content-Length header\n- Synchronous I/O in stream processing (blocks executor threads)",
    "layer": "controller",
    "patternIds": ["request-streaming", "async-sequence", "backpressure", "upload-limits"],
    "violationIds": ["buffering-entire-request", "missing-upload-size-limit", "detached-task-in-stream-loop", "request-decode-for-large-payload"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "file-upload-security",
    "title": "File Upload Security Best Practices",
    "content": "File uploads are a major security risk. Every file upload endpoint must validate file type, size, filename, and content. Never trust client-provided filenames, MIME types, or file extensions. Always sanitize, validate, and scan uploaded files before storage or processing.\n\n```swift\nimport Hummingbird\nimport Foundation\n\n// ✅ Correct — comprehensive file upload validation\nstruct FileUploadService {\n    let storage: any FileStorageProtocol\n    let logger: Logger\n    let config: UploadConfiguration\n    \n    func validateAndStoreUpload(\n        filename: String,\n        contentType: String,\n        body: Request.Body\n    ) async throws -> FileMetadata {\n        // 1. Validate and sanitize filename\n        let sanitizedFilename = try sanitizeFilename(filename)\n        \n        // 2. Validate MIME type against allowlist\n        guard config.allowedMimeTypes.contains(contentType) else {\n            logger.warning(\"Rejected upload with disallowed MIME type\", metadata: [\n                \"filename\": \"\\(sanitizedFilename)\",\n                \"contentType\": \"\\(contentType)\"\n            ])\n            throw AppError.invalidInput(reason: \"File type \\(contentType) not allowed\")\n        }\n        \n        // 3. Extract and validate file extension\n        let fileExtension = (sanitizedFilename as NSString).pathExtension.lowercased()\n        guard config.allowedExtensions.contains(fileExtension) else {\n            throw AppError.invalidInput(reason: \"File extension .\\(fileExtension) not allowed\")\n        }\n        \n        // 4. Generate secure random filename (don't use client filename)\n        let secureFilename = \"\\(UUID().uuidString).\\(fileExtension)\"\n        \n        // 5. Stream to temporary location with size limit\n        let tempPath = try await storage.createTempFile(secureFilename)\n        var bytesWritten = 0\n        \n        do {\n            for try await chunk in body {\n                bytesWritten += chunk.readableBytes\n                \n                // Enforce size limit during upload\n                guard bytesWritten <= config.maxUploadSizeBytes else {\n                    try await storage.deleteTempFile(tempPath)\n                    throw AppError.invalidInput(reason: \"File exceeds maximum size of \\(config.maxUploadSizeBytes) bytes\")\n                }\n                \n                try await storage.writeToTempFile(chunk, at: tempPath)\n            }\n            \n            // 6. Validate actual content type by inspecting file magic bytes\n            let actualContentType = try await detectContentType(at: tempPath)\n            guard actualContentType == contentType else {\n                logger.warning(\"Content-Type mismatch\", metadata: [\n                    \"declared\": \"\\(contentType)\",\n                    \"actual\": \"\\(actualContentType)\"\n                ])\n                try await storage.deleteTempFile(tempPath)\n                throw AppError.invalidInput(reason: \"File content does not match declared type\")\n            }\n            \n            // 7. Optional: Virus scan (if available)\n            if let virusScanner = config.virusScanner {\n                let isSafe = try await virusScanner.scan(tempPath)\n                guard isSafe else {\n                    logger.error(\"Virus detected in uploaded file\", metadata: [\n                        \"filename\": \"\\(sanitizedFilename)\"\n                    ])\n                    try await storage.deleteTempFile(tempPath)\n                    throw AppError.securityViolation(reason: \"File failed security scan\")\n                }\n            }\n            \n            // 8. Move to permanent storage\n            let permanentPath = try await storage.moveToPermStorage(tempPath, as: secureFilename)\n            \n            return FileMetadata(\n                id: UUID().uuidString,\n                filename: sanitizedFilename,\n                secureFilename: secureFilename,\n                path: permanentPath,\n                sizeBytes: bytesWritten,\n                contentType: actualContentType\n            )\n            \n        } catch {\n            // Clean up temp file on any error\n            try? await storage.deleteTempFile(tempPath)\n            throw error\n        }\n    }\n    \n    func sanitizeFilename(_ filename: String) throws -> String {\n        // Remove path separators to prevent directory traversal\n        var sanitized = filename.replacingOccurrences(of: \"/\", with: \"_\")\n        sanitized = sanitized.replacingOccurrences(of: \"\\\\\", with: \"_\")\n        sanitized = sanitized.replacingOccurrences(of: \"..\", with: \"_\")\n        \n        // Remove null bytes\n        sanitized = sanitized.replacingOccurrences(of: \"\\0\", with: \"\")\n        \n        // Limit length\n        if sanitized.count > 255 {\n            sanitized = String(sanitized.prefix(255))\n        }\n        \n        // Ensure filename is not empty after sanitization\n        guard !sanitized.isEmpty else {\n            throw AppError.invalidInput(reason: \"Invalid filename\")\n        }\n        \n        return sanitized\n    }\n    \n    func detectContentType(at path: String) async throws -> String {\n        // Read first few bytes (magic bytes) to detect actual file type\n        let magicBytes = try await storage.readBytes(at: path, count: 16)\n        \n        // Check magic bytes against known file signatures\n        if magicBytes.starts(with: [0xFF, 0xD8, 0xFF]) {\n            return \"image/jpeg\"\n        } else if magicBytes.starts(with: [0x89, 0x50, 0x4E, 0x47]) {\n            return \"image/png\"\n        } else if magicBytes.starts(with: [0x25, 0x50, 0x44, 0x46]) {\n            return \"application/pdf\"\n        }\n        // ... more magic byte checks\n        \n        return \"application/octet-stream\"\n    }\n}\n\nstruct UploadConfiguration: Sendable {\n    let maxUploadSizeBytes: Int\n    let allowedMimeTypes: Set<String>\n    let allowedExtensions: Set<String>\n    let virusScanner: (any VirusScannerProtocol)?\n}\n\n// ❌ CRITICAL VULNERABILITY — using client filename directly\nrouter.post(\"/upload\") { request, context in\n    let filename = request.headers[\"x-filename\"] ?? \"upload.bin\"\n    let path = \"/uploads/\\(filename)\" // ⚠️ DIRECTORY TRAVERSAL!\n    // Attacker sends: x-filename: ../../../../etc/passwd\n    try await storage.writeFile(path, body: request.body)\n    return Response(status: .created)\n}\n\n// ❌ CRITICAL — trusting Content-Type header without validation\nrouter.post(\"/upload\") { request, context in\n    let contentType = request.headers[.contentType] ?? \"application/octet-stream\"\n    // ⚠️ Attacker sets Content-Type: image/jpeg but uploads executable!\n    let file = try await storage.save(request.body, as: contentType)\n    return Response(status: .created)\n}\n\n// ❌ CRITICAL — no file size limit\nrouter.post(\"/upload\") { request, context in\n    // ⚠️ Attacker can fill disk with unlimited upload!\n    try await storage.save(request.body)\n    return Response(status: .created)\n}\n\n// ❌ Wrong — file extension validation only\nfunc validateFile(filename: String) -> Bool {\n    return filename.hasSuffix(\".jpg\") || filename.hasSuffix(\".png\")\n    // ⚠️ Attacker uploads malware.exe.jpg — passes validation!\n}\n```\n\nSecurity checklist:\n- ✅ Sanitize filenames (remove `../`, `/`, `\\\\`, null bytes)\n- ✅ Never use client-provided filenames for storage paths (use UUIDs)\n- ✅ Validate MIME type against allowlist (never use blocklist)\n- ✅ Validate file extension against allowlist\n- ✅ Detect actual file type from magic bytes, not extension or Content-Type header\n- ✅ Enforce maximum upload size (both Content-Length and actual bytes)\n- ✅ Store uploads outside web root (prevent direct URL access)\n- ✅ Use random filenames (UUIDs) to prevent filename collisions and guessing\n- ✅ Scan for viruses/malware if handling untrusted uploads\n- ✅ Set restrictive file permissions on upload directory\n- ✅ Rate-limit upload endpoints to prevent abuse\n- ✅ Log all upload attempts (successful and failed) for security monitoring\n- ✅ Clean up temp files on errors\n- ✅ Consider storing uploads in object storage (S3) instead of local filesystem\n\nCommon vulnerabilities:\n- Directory traversal (filename: `../../etc/passwd`)\n- Arbitrary file upload (upload `.php`, `.jsp` to execute server-side code)\n- MIME type mismatch (declare image/jpeg, upload executable)\n- Zip bombs / billion laughs (compressed files that expand to GB)\n- XXE attacks in XML/SVG uploads\n- Malware distribution (upload infected files)\n- Disk space exhaustion (unlimited upload size)\n- Path disclosure (error messages reveal filesystem structure)",
    "layer": "service",
    "patternIds": ["security", "file-upload", "input-validation"],
    "violationIds": ["directory-traversal-vulnerability", "untrusted-filename", "missing-mime-type-validation", "missing-upload-size-limit", "missing-magic-byte-validation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "error-middleware-pattern",
    "title": "Error Middleware for Centralized Error Handling",
    "content": "Error middleware catches all errors thrown by handlers and transforms them into appropriate HTTP responses. This centralizes error handling logic, ensures consistent error responses, prevents error details from leaking to clients, and provides a single point for error logging.\n\n```swift\nimport Hummingbird\nimport Logging\n\n// ✅ Correct — centralized error middleware\nstruct ErrorMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let logger: Logger\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        do {\n            return try await next(request, context)\n        } catch let error as AppError {\n            // Handle typed application errors\n            return handleAppError(error, request: request)\n        } catch let error as HTTPError {\n            // Handle Hummingbird HTTP errors\n            return handleHTTPError(error, request: request)\n        } catch {\n            // Catch any unexpected errors\n            logger.error(\"Unexpected error\", metadata: [\n                \"error\": \"\\(error)\",\n                \"path\": \"\\(request.uri.path)\",\n                \"method\": \"\\(request.method)\"\n            ])\n            return Response(\n                status: .internalServerError,\n                headers: [.contentType: \"application/json\"],\n                body: .init(data: errorJSON(\"Internal server error\", code: 500))\n            )\n        }\n    }\n\n    private func handleAppError(_ error: AppError, request: Request) -> Response {\n        let (status, message, code) = mapAppErrorToHTTP(error)\n        \n        // Log based on severity\n        switch status {\n        case .internalServerError, .serviceUnavailable:\n            logger.error(\"Application error\", metadata: [\n                \"error\": \"\\(error)\",\n                \"path\": \"\\(request.uri.path)\",\n                \"method\": \"\\(request.method)\"\n            ])\n        case .badRequest, .unauthorized, .forbidden, .notFound:\n            logger.info(\"Client error\", metadata: [\n                \"error\": \"\\(error)\",\n                \"status\": \"\\(status.code)\"\n            ])\n        default:\n            logger.warning(\"Error\", metadata: [\"error\": \"\\(error)\"])\n        }\n\n        return Response(\n            status: status,\n            headers: [.contentType: \"application/json\"],\n            body: .init(data: errorJSON(message, code: code))\n        )\n    }\n\n    private func handleHTTPError(_ error: HTTPError, request: Request) -> Response {\n        logger.info(\"HTTP error\", metadata: [\n            \"status\": \"\\(error.status.code)\",\n            \"path\": \"\\(request.uri.path)\"\n        ])\n        return Response(\n            status: error.status,\n            headers: [.contentType: \"application/json\"],\n            body: .init(data: errorJSON(\n                error.status.reasonPhrase,\n                code: Int(error.status.code)\n            ))\n        )\n    }\n\n    private func mapAppErrorToHTTP(_ error: AppError) -> (HTTPResponse.Status, String, Int) {\n        switch error {\n        case .invalidInput(let reason):\n            return (.badRequest, reason, 400)\n        case .unauthorized(let reason):\n            return (.unauthorized, reason, 401)\n        case .forbidden(let reason):\n            return (.forbidden, reason, 403)\n        case .notFound(let reason):\n            return (.notFound, reason, 404)\n        case .conflict(let reason):\n            return (.conflict, reason, 409)\n        case .validationError(let reason):\n            return (.unprocessableEntity, reason, 422)\n        case .internalError:\n            // Never expose internal error details to clients!\n            return (.internalServerError, \"Internal server error\", 500)\n        case .serviceUnavailable(let reason):\n            return (.serviceUnavailable, reason, 503)\n        }\n    }\n\n    private func errorJSON(_ message: String, code: Int) -> Data {\n        let json = \"\"\"\n        {\n            \"error\": {\n                \"message\": \"\\(message)\",\n                \"code\": \\(code)\n            }\n        }\n        \"\"\"\n        return Data(json.utf8)\n    }\n}\n\n// Register error middleware FIRST — order matters!\nrouter.add(middleware: ErrorMiddleware(logger: logger))\nrouter.add(middleware: DependencyInjectionMiddleware(dependencies: deps))\nrouter.get(\"/users/:id\") { request, context in\n    // Any error thrown here will be caught by ErrorMiddleware\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user)\n}\n\n// ❌ Wrong — error handling in every route handler\nrouter.get(\"/users/:id\") { request, context in\n    do {\n        let id = try context.parameters.require(\"id\")\n        let user = try await context.dependencies.userService.find(id: id)\n        return UserResponse(user)\n    } catch {\n        // Duplicated error handling logic!\n        return Response(\n            status: .internalServerError,\n            body: .init(string: \"Error: \\(error)\")\n        )\n    }\n}\n\n// ❌ CRITICAL — leaking internal error details\nrouter.get(\"/users/:id\") { request, context in\n    do {\n        let user = try await context.dependencies.userService.find(id: \"123\")\n        return UserResponse(user)\n    } catch {\n        // ⚠️ Exposes database connection strings, stack traces, etc!\n        return Response(\n            status: .internalServerError,\n            body: .init(string: \"Database error: \\(error)\")\n        )\n    }\n}\n\n// ❌ Wrong — inconsistent error response format\nrouter.get(\"/users/:id\") { request, context in\n    guard let user = try? await context.dependencies.userService.find(id: \"123\") else {\n        return Response(status: .notFound, body: .init(string: \"Not found\"))\n    }\n    return UserResponse(user)\n}\n\nrouter.get(\"/posts/:id\") { request, context in\n    guard let post = try? await context.dependencies.postService.find(id: \"123\") else {\n        // Different format from /users/:id!\n        return Response(\n            status: .notFound,\n            headers: [.contentType: \"application/json\"],\n            body: .init(string: \"{\\\"error\\\":\\\"Post not found\\\"}\")\n        )\n    }\n    return PostResponse(post)\n}\n```\n\nBest practices:\n- Add error middleware FIRST in the middleware chain\n- Map all AppError cases to appropriate HTTP status codes\n- Return consistent JSON error format across all endpoints\n- Log errors with appropriate severity (error vs warning vs info)\n- Never expose internal error details (database errors, stack traces) to clients\n- Include request metadata in error logs (path, method, user ID)\n- Use structured logging (Logger.Metadata) for searchability\n- Return user-friendly error messages\n- Consider adding error tracking integration (Sentry, Rollbar)\n- Test error responses in integration tests",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "error-handling", "centralized-error-handling"],
    "violationIds": ["inline-error-handling", "error-detail-leakage", "inconsistent-error-responses"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "cors-middleware-pattern",
    "title": "CORS Middleware Pattern",
    "content": "CORS (Cross-Origin Resource Sharing) middleware handles preflight OPTIONS requests and adds appropriate CORS headers to responses. Configure allowed origins, methods, headers, and credentials policy. Never use wildcard (`*`) origins with credentials, and always validate origins against an allowlist in production.\n\n```swift\nimport Hummingbird\nimport HTTPTypes\n\n// ✅ Correct — production-ready CORS middleware\nstruct CORSMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    private let config: CORSConfiguration\n\n    init(config: CORSConfiguration) {\n        self.config = config\n    }\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Handle preflight OPTIONS request\n        if request.method == .options {\n            return handlePreflight(request: request)\n        }\n\n        // Process actual request and add CORS headers to response\n        var response = try await next(request, context)\n        response = addCORSHeaders(to: response, for: request)\n        return response\n    }\n\n    private func handlePreflight(request: Request) -> Response {\n        var headers: HTTPFields = [:]\n\n        // Validate origin\n        if let origin = request.headers[HTTPField.Name(\"origin\")!],\n           isOriginAllowed(origin) {\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = origin\n\n            if config.allowCredentials {\n                headers[HTTPField.Name(\"access-control-allow-credentials\")!] = \"true\"\n            }\n        } else if config.allowedOrigins.contains(\"*\") {\n            // Wildcard only if credentials not allowed\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n        }\n\n        // Add allowed methods\n        let allowedMethods = config.allowedMethods.map { $0.rawValue }.joined(separator: \", \")\n        headers[HTTPField.Name(\"access-control-allow-methods\")!] = allowedMethods\n\n        // Add allowed headers\n        if !config.allowedHeaders.isEmpty {\n            let allowedHeaders = config.allowedHeaders.joined(separator: \", \")\n            headers[HTTPField.Name(\"access-control-allow-headers\")!] = allowedHeaders\n        }\n\n        // Add max age for preflight cache\n        if let maxAge = config.maxAge {\n            headers[HTTPField.Name(\"access-control-max-age\")!] = \"\\(maxAge)\"\n        }\n\n        return Response(status: .noContent, headers: headers)\n    }\n\n    private func addCORSHeaders(to response: Response, for request: Request) -> Response {\n        var headers = response.headers\n\n        // Validate and set origin\n        if let origin = request.headers[HTTPField.Name(\"origin\")!],\n           isOriginAllowed(origin) {\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = origin\n\n            if config.allowCredentials {\n                headers[HTTPField.Name(\"access-control-allow-credentials\")!] = \"true\"\n            }\n        } else if config.allowedOrigins.contains(\"*\") {\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n        }\n\n        // Add exposed headers\n        if !config.exposedHeaders.isEmpty {\n            let exposedHeaders = config.exposedHeaders.joined(separator: \", \")\n            headers[HTTPField.Name(\"access-control-expose-headers\")!] = exposedHeaders\n        }\n\n        return Response(\n            status: response.status,\n            headers: headers,\n            body: response.body\n        )\n    }\n\n    private func isOriginAllowed(_ origin: String) -> Bool {\n        if config.allowedOrigins.contains(\"*\") {\n            return true\n        }\n        return config.allowedOrigins.contains(origin)\n    }\n}\n\n// CORS configuration\nstruct CORSConfiguration: Sendable {\n    let allowedOrigins: Set<String>\n    let allowedMethods: Set<HTTPRequest.Method>\n    let allowedHeaders: Set<String>\n    let exposedHeaders: Set<String>\n    let allowCredentials: Bool\n    let maxAge: Int?\n\n    // Production configuration — explicit origin allowlist\n    static func production(allowedOrigins: Set<String>) -> CORSConfiguration {\n        CORSConfiguration(\n            allowedOrigins: allowedOrigins,\n            allowedMethods: [.get, .post, .put, .patch, .delete, .options],\n            allowedHeaders: [\"content-type\", \"authorization\", \"x-requested-with\"],\n            exposedHeaders: [\"content-length\", \"content-type\"],\n            allowCredentials: true,\n            maxAge: 3600\n        )\n    }\n\n    // Development configuration — allow all origins (use only in development!)\n    static var development: CORSConfiguration {\n        CORSConfiguration(\n            allowedOrigins: [\"*\"],\n            allowedMethods: [.get, .post, .put, .patch, .delete, .options],\n            allowedHeaders: [\"*\"],\n            exposedHeaders: [],\n            allowCredentials: false,  // Cannot use credentials with wildcard origin\n            maxAge: 3600\n        )\n    }\n}\n\n// ✅ Correct — production usage with explicit origins\nlet corsConfig = CORSConfiguration.production(allowedOrigins: [\n    \"https://app.example.com\",\n    \"https://admin.example.com\"\n])\nrouter.add(middleware: CORSMiddleware(config: corsConfig))\n\n// ✅ Correct — development usage (localhost only)\n#if DEBUG\nlet corsConfig = CORSConfiguration.development\nrouter.add(middleware: CORSMiddleware(config: corsConfig))\n#endif\n\n// ❌ CRITICAL SECURITY ISSUE — wildcard origin with credentials\nlet badConfig = CORSConfiguration(\n    allowedOrigins: [\"*\"],\n    allowedMethods: [.get, .post],\n    allowedHeaders: [\"*\"],\n    exposedHeaders: [],\n    allowCredentials: true,  // ⚠️ SECURITY VULNERABILITY!\n    maxAge: 3600\n)\n// This allows ANY website to make authenticated requests to your API!\n\n// ❌ Wrong — no origin validation\nstruct BadCORSMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var response = try await next(request, context)\n        \n        // ⚠️ Reflects any origin without validation!\n        if let origin = request.headers[HTTPField.Name(\"origin\")!] {\n            response.headers[HTTPField.Name(\"access-control-allow-origin\")!] = origin\n            response.headers[HTTPField.Name(\"access-control-allow-credentials\")!] = \"true\"\n        }\n        \n        return response\n    }\n}\n\n// ❌ Wrong — hardcoded CORS headers in every handler\nrouter.get(\"/api/data\") { request, context in\n    var response = Response(status: .ok, body: .init(string: \"data\"))\n    response.headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n    return response\n}\n\n// ❌ Wrong — missing preflight handling\nstruct IncompleteCORSMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var response = try await next(request, context)\n        response.headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n        return response\n        // ⚠️ No preflight OPTIONS handling — CORS will fail for many requests!\n    }\n}\n```\n\nKey points:\n- CORS middleware must handle both preflight OPTIONS requests and actual requests\n- Preflight responses return 204 No Content with CORS headers\n- Actual responses get CORS headers added before returning\n- Never use wildcard (`*`) origin with `allowCredentials: true` — major security risk\n- Always validate Origin header against an allowlist in production\n- Include `Access-Control-Max-Age` to cache preflight responses (reduces OPTIONS traffic)\n- Use `Access-Control-Expose-Headers` to allow JavaScript access to response headers\n- Order matters: add CORS middleware early in the chain (after error middleware)\n- For APIs serving public data, wildcard origin is acceptable (without credentials)\n- For APIs with authentication, use explicit origin allowlist\n\nCommon mistakes:\n- Reflecting any origin without validation (security vulnerability)\n- Using wildcard origin with credentials enabled (forbidden by CORS spec)\n- Missing preflight OPTIONS handling (causes CORS failures)\n- Hardcoding CORS headers in route handlers (duplication)\n- Not including necessary headers in allowedHeaders (causes preflight rejection)\n- Setting overly permissive CORS in production (use explicit allowlist)\n\nSecurity considerations:\n- CORS is a browser security feature — it does not prevent direct API calls (use authentication)\n- Validate origins against allowlist, never reflect request origin blindly\n- Use HTTPS for all CORS-enabled endpoints (prevent MITM attacks)\n- Keep allowedOrigins as restrictive as possible\n- Review CORS configuration regularly as part of security audits\n- Monitor for unauthorized cross-origin requests",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "cors", "security", "preflight-handling"],
    "violationIds": ["wildcard-origin-with-credentials", "missing-origin-validation", "missing-preflight-handling", "cors-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  }
]
