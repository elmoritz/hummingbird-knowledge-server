[
  {
    "id": "route-handler-dispatcher-only",
    "title": "Route Handlers Are Dispatchers Only",
    "content": "In Hummingbird 2.x clean architecture, route handlers have exactly one job: dispatch to the service layer and return the result. They must not contain business logic, database calls, or service construction.\n\n```swift\n// ✅ Correct — pure dispatcher\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    let user = try await context.dependencies.userService.create(dto)\n    return CreateUserResponse(user)\n}\n\n// ❌ Wrong — business logic in handler\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    guard !dto.email.isEmpty else { throw HTTPError(.badRequest) }\n    let hashed = BCrypt.hash(dto.password)\n    let user = User(email: dto.email, passwordHash: hashed)\n    try await db.save(user)\n    return user\n}\n```",
    "layer": "controller",
    "patternIds": ["dispatcher-pattern", "thin-controller"],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-layer-no-hummingbird",
    "title": "Service Layer Must Not Import Hummingbird",
    "content": "The service layer encodes business logic independently of any web framework. No Hummingbird import means the service can be tested without an HTTP context and can be reused across transports.\n\n```swift\n// ✅ Correct — pure Swift service\nimport Foundation\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n\n    func create(_ request: CreateUserRequest) async throws -> User {\n        guard !request.email.isEmpty else {\n            throw AppError.invalidInput(reason: \"Email must not be empty\")\n        }\n        return try await repository.insert(User(email: request.email))\n    }\n}\n\n// ❌ Wrong — Hummingbird leaked into service layer\nimport Hummingbird\n\nstruct UserService {\n    func create(_ req: Request) async throws -> Response { ... }\n}\n```",
    "layer": "service",
    "patternIds": ["framework-agnostic-service"],
    "violationIds": ["hummingbird-import-in-service"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dependency-injection-via-context",
    "title": "Inject Dependencies via AppRequestContext",
    "content": "All dependencies (services, repositories, stores) must be accessed through `AppRequestContext.dependencies`. This gives you a single, testable, type-safe injection point with zero service-locator magic.\n\n```swift\n// ✅ Correct — from AppRequestContext\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.userService.find(id: id)\n}\n\n// ❌ Wrong — constructed inline\nrouter.get(\"/users/:id\") { request, context in\n    let repo = PostgresUserRepository(pool: globalPool)\n    let service = UserService(repository: repo)\n    return try await service.find(id: request.uri.path)\n}\n```",
    "layer": "context",
    "patternIds": ["dependency-injection", "context-as-container"],
    "violationIds": ["service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "typed-errors-app-error",
    "title": "All Errors Are Typed AppError Values",
    "content": "Every error that crosses a layer boundary must be an `AppError`. Raw third-party errors are caught and wrapped immediately. This keeps HTTP response codes consistent and prevents internal details from leaking to clients.\n\n```swift\n// ✅ Correct — wrap at the boundary\nfunc findUser(id: String) async throws -> User {\n    do {\n        return try await repository.find(id: id)\n    } catch let dbError as DatabaseError {\n        throw AppError.internalError(reason: dbError.localizedDescription)\n    }\n}\n\n// ❌ Wrong — raw error propagates\nfunc findUser(id: String) async throws -> User {\n    return try await repository.find(id: id) // DatabaseError leaks up\n}\n```",
    "layer": null,
    "patternIds": ["typed-errors", "error-wrapping"],
    "violationIds": ["raw-error-thrown-from-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dtos-at-boundaries",
    "title": "DTOs at Every HTTP Boundary",
    "content": "Domain models must never cross the HTTP layer raw. A DTO (Data Transfer Object) gives you a stable public contract independent of internal model evolution.\n\n```swift\n// ✅ Correct — DTO at the boundary\nstruct UserResponse: Codable, ResponseCodable {\n    let id: String\n    let email: String\n    let createdAt: Date\n\n    init(_ user: User) {\n        self.id = user.id.uuidString\n        self.email = user.email\n        self.createdAt = user.createdAt\n    }\n}\n\n// Handler returns DTO, not domain model\nrouter.get(\"/users/:id\") { request, context in\n    let user = try await context.dependencies.userService.find(...)\n    return UserResponse(user) // never `return user` directly\n}\n```",
    "layer": "controller",
    "patternIds": ["dto-pattern", "api-boundary"],
    "violationIds": ["domain-model-across-http-boundary"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "actor-for-shared-state",
    "title": "Use Actors for Shared Mutable State",
    "content": "Any mutable state shared across concurrent requests must be protected by a Swift actor. In Swift 6 strict concurrency mode this is enforced at compile time.\n\n```swift\n// ✅ Correct — actor-protected\nactor RateLimitStore {\n    private var windows: [String: [Date]] = [:]\n\n    func recordRequest(from ip: String, limit: Int) -> Bool {\n        // Safe — all access serialised by the actor\n        ...\n    }\n}\n\n// ❌ Wrong — data race in Swift 6\nvar requestCounts: [String: Int] = [:] // module-level var\n\nrouter.get(\"/\") { request, context in\n    requestCounts[request.uri.path, default: 0] += 1 // data race!\n    ...\n}\n```",
    "layer": "middleware",
    "patternIds": ["actor-model", "swift-concurrency"],
    "violationIds": ["shared-mutable-state-without-actor"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "request-context-di",
    "title": "AppRequestContext as the DI Container",
    "content": "Hummingbird 2.x uses a custom `RequestContext` to thread per-request state. `AppRequestContext` extends this to carry the application's dependency graph. `DependencyInjectionMiddleware` populates it at the start of every request.\n\n```swift\n// The context definition\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies\n\n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        self.dependencies = AppDependencies.placeholder\n    }\n}\n\n// The middleware that fills it in\nstruct DependencyInjectionMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let dependencies: AppDependencies\n\n    func handle(_ request: Request, context: AppRequestContext,\n                next: (Request, AppRequestContext) async throws -> Response) async throws -> Response {\n        var ctx = context\n        ctx.dependencies = dependencies\n        return try await next(request, ctx)\n    }\n}\n```",
    "layer": "context",
    "patternIds": ["request-context", "middleware-di"],
    "violationIds": ["nonisolated-context-access"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "router-middleware-pattern",
    "title": "RouterMiddleware Protocol Pattern",
    "content": "Hummingbird 2.x middleware conforms to `RouterMiddleware`. The associated `Context` type binds the middleware to a specific request context. Middleware is added to the router before routes are registered — order matters.\n\n```swift\nstruct AuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        guard let header = request.headers[.authorization],\n              header == \"Bearer \\(token)\" else {\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// Registration order matters — add before routes\nrouter.add(middleware: DependencyInjectionMiddleware(...))\nrouter.add(middleware: AuthMiddleware(token: ...))\nrouter.get(\"/protected\") { ... }\n```",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "request-pipeline"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-lifecycle-background-service",
    "title": "Background Services via Service Lifecycle",
    "content": "Hummingbird 2.x uses `swift-service-lifecycle` for background work. Implement `Service` and add to the application. The service group manages startup, shutdown, and graceful termination automatically.\n\n```swift\nimport Hummingbird\n\nstruct CacheRefreshService: Service {\n    let cache: CacheStore\n    let interval: Duration\n    let logger: Logger\n\n    func run() async throws {\n        while !Task.isCancelled {\n            do {\n                try await cache.refresh()\n                logger.info(\"Cache refreshed\")\n            } catch {\n                logger.warning(\"Cache refresh failed\", metadata: [\"error\": \"\\(error)\"])\n            }\n            try await Task.sleep(for: interval)\n        }\n    }\n}\n\n// In Application+build.swift:\napp.addServices(CacheRefreshService(cache: cache, interval: .seconds(3600), logger: logger))\n```",
    "layer": "service",
    "patternIds": ["service-lifecycle", "background-service"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "request-validation-via-dto",
    "title": "Request Validation Through DTOs",
    "content": "All HTTP request data (path parameters, query parameters, request bodies) must be validated through DTO decoding, not accessed raw from the request object. DTOs enforce type safety, validation rules, and provide a clean contract between HTTP and service layers.\n\n```swift\n// ✅ Correct — validate through DTO\nstruct CreateUserRequest: Decodable {\n    let email: String\n    let age: Int\n\n    enum CodingKeys: String, CodingKey {\n        case email, age\n    }\n\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        email = try container.decode(String.self, forKey: .email)\n        age = try container.decode(Int.self, forKey: .age)\n        \n        // Validation at the DTO boundary\n        guard email.contains(\"@\") else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .email,\n                in: container,\n                debugDescription: \"Email must be valid\"\n            )\n        }\n        guard age >= 13 else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .age,\n                in: container,\n                debugDescription: \"Must be 13 or older\"\n            )\n        }\n    }\n}\n\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    return try await context.dependencies.userService.create(dto)\n}\n\n// ❌ Wrong — raw parameter access without validation\nrouter.post(\"/users\") { request, context in\n    let email = request.uri.queryParameters[\"email\"] ?? \"\"\n    let ageStr = request.uri.queryParameters[\"age\"] ?? \"0\"\n    let age = Int(ageStr) ?? 0\n    // No validation, unsafe parsing, brittle code\n    return try await context.dependencies.userService.create(email: email, age: age)\n}\n```",
    "layer": "controller",
    "patternIds": ["dto-pattern", "api-boundary", "request-validation"],
    "violationIds": ["unchecked-uri-parameters", "unchecked-query-parameters", "raw-parameter-in-service-call", "missing-request-decode"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "inline-handler-anti-pattern",
    "title": "Anti-Pattern: All Logic Inline in Route Handlers",
    "content": "Tutorials often show all logic inline in a route handler for brevity. This is an anti-pattern in production code: it creates untestable handlers, couples framework to business logic, and makes layers impossible to reason about independently.\n\n```swift\n// ❌ ANTI-PATTERN — tutorial style, not production style\nrouter.post(\"/register\") { request, context in\n    struct Body: Decodable { var email: String; var password: String }\n    let body = try await request.decode(as: Body.self, context: context)\n    guard !body.email.isEmpty else { return Response(status: .badRequest) }\n    let hash = SHA256.hash(data: Data(body.password.utf8)).description\n    // Directly using global DB connection:\n    try await db.execute(\"INSERT INTO users ...\", [body.email, hash])\n    return Response(status: .created)\n}\n```\n\nThe correct approach uses the service layer for all business logic, the repository for DB access, and the context for injection.",
    "layer": "controller",
    "patternIds": [],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": true,
    "correctionId": "route-handler-dispatcher-only",
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "centralized-configuration",
    "title": "Centralized Configuration via AppDependencies",
    "content": "All configuration values (URLs, timeouts, feature flags, limits) must be centralized in a Configuration struct and injected via AppDependencies. Never hardcode values or access environment variables directly in services or handlers.\n\n```swift\n// ✅ Correct — centralized configuration\nstruct AppConfiguration: Sendable {\n    let apiBaseURL: String\n    let databaseURL: String\n    let rateLimitPerMinute: Int\n    let jwtSecret: String\n\n    static func fromEnvironment() throws -> AppConfiguration {\n        guard let apiURL = ProcessInfo.processInfo.environment[\"API_BASE_URL\"],\n              let dbURL = ProcessInfo.processInfo.environment[\"DATABASE_URL\"],\n              let jwtSecret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"] else {\n            throw AppError.configurationError(reason: \"Missing required environment variables\")\n        }\n        return AppConfiguration(\n            apiBaseURL: apiURL,\n            databaseURL: dbURL,\n            rateLimitPerMinute: 60,\n            jwtSecret: jwtSecret\n        )\n    }\n}\n\nstruct AppDependencies: Sendable {\n    let configuration: AppConfiguration\n    let userService: UserService\n    // ... other dependencies\n}\n\n// In service — configuration injected\nstruct UserService {\n    let config: AppConfiguration\n    let repository: any UserRepositoryProtocol\n\n    func authenticate(token: String) throws -> Bool {\n        return JWT.verify(token, secret: config.jwtSecret)\n    }\n}\n\n// ❌ Wrong — direct environment access\nstruct UserService {\n    func authenticate(token: String) throws -> Bool {\n        let secret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"]!\n        return JWT.verify(token, secret: secret)\n    }\n}\n\n// ❌ Wrong — hardcoded values\nstruct RateLimitMiddleware: RouterMiddleware {\n    func handle(_ request: Request, context: AppRequestContext, next: ...) async throws -> Response {\n        let limit = 60 // magic number!\n        ...\n    }\n}\n```",
    "layer": "context",
    "patternIds": ["dependency-injection", "configuration-management"],
    "violationIds": ["direct-env-access", "hardcoded-url", "magic-numbers"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "secure-configuration",
    "title": "Secure Secrets Management",
    "content": "Secrets (API keys, passwords, tokens, encryption keys) must NEVER be hardcoded in source code. They must be loaded from environment variables, secret management services, or encrypted configuration files at application startup.\n\n```swift\n// ✅ Correct — secrets from environment\nstruct AppConfiguration: Sendable {\n    let jwtSecret: String\n    let databasePassword: String\n    let apiKey: String\n\n    static func fromEnvironment() throws -> AppConfiguration {\n        guard let jwtSecret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"],\n              let dbPassword = ProcessInfo.processInfo.environment[\"DATABASE_PASSWORD\"],\n              let apiKey = ProcessInfo.processInfo.environment[\"API_KEY\"],\n              !jwtSecret.isEmpty, !dbPassword.isEmpty, !apiKey.isEmpty else {\n            throw AppError.configurationError(reason: \"Required secrets not found in environment\")\n        }\n        return AppConfiguration(\n            jwtSecret: jwtSecret,\n            databasePassword: dbPassword,\n            apiKey: apiKey\n        )\n    }\n}\n\n// ❌ CRITICAL VULNERABILITY — hardcoded secrets\nstruct AuthService {\n    let jwtSecret = \"super-secret-key-12345\" // ⚠️ NEVER DO THIS!\n    let apiKey = \"sk_live_abc123def456\" // ⚠️ SECURITY BREACH!\n}\n\n// ❌ Wrong — secrets in git-tracked config files\nstruct Config {\n    static let databaseURL = \"postgres://user:password@localhost/db\" // ⚠️ Credentials exposed!\n}\n```\n\nBest practices:\n- Use environment variables for development and production\n- Use secret management services (AWS Secrets Manager, HashiCorp Vault) in production\n- Never commit `.env` files to version control (add to `.gitignore`)\n- Rotate secrets regularly\n- Use different secrets for dev, staging, and production",
    "layer": null,
    "patternIds": ["security", "configuration-management"],
    "violationIds": ["hardcoded-credentials"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "async-concurrency-patterns",
    "title": "Async/Await Concurrency Patterns",
    "content": "Hummingbird 2.x is built on Swift concurrency. All I/O operations (network, file system, database) must use `async`/`await`. Never use blocking APIs (sleep, synchronous URLSession, blocking file I/O) in async contexts — they block the entire thread and prevent other requests from being processed.\n\n```swift\n// ✅ Correct — async/await for all I/O\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user)\n}\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n\n    func find(id: String) async throws -> User {\n        return try await repository.find(id: id) // async database call\n    }\n}\n\n// ❌ Wrong — blocking sleep in handler\nrouter.get(\"/slow\") { request, context in\n    Thread.sleep(forTimeInterval: 1.0) // ⚠️ Blocks executor thread!\n    return Response(status: .ok)\n}\n\n// ❌ Wrong — synchronous network call in async context\nfunc fetchData() async throws -> Data {\n    let url = URL(string: \"https://api.example.com/data\")!\n    let data = try Data(contentsOf: url) // ⚠️ Synchronous I/O blocks thread!\n    return data\n}\n\n// ✅ Correct — async network call\nfunc fetchData() async throws -> Data {\n    let url = URL(string: \"https://api.example.com/data\")!\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n```\n\nFor delays, use `Task.sleep(for:)` instead of `Thread.sleep()`:\n```swift\n// ✅ Correct — non-blocking delay\ntry await Task.sleep(for: .seconds(1))\n\n// ❌ Wrong — blocking delay\nThread.sleep(forTimeInterval: 1.0)\n```",
    "layer": null,
    "patternIds": ["swift-concurrency", "async-await"],
    "violationIds": ["sleep-in-handler", "blocking-sleep-in-async", "synchronous-network-call", "synchronous-database-call-in-async"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "non-blocking-io",
    "title": "Non-Blocking I/O Operations",
    "content": "All file I/O in async contexts must use async APIs. Swift's `FileHandle`, `Data(contentsOf:)`, and `String(contentsOfFile:)` are synchronous and block the thread. Use async file I/O libraries or offload to a background executor.\n\n```swift\n// ✅ Correct — async file I/O (using async FileHandle or custom wrapper)\nimport Foundation\n#if canImport(FoundationNetworking)\nimport FoundationNetworking\n#endif\n\nfunc readFile(at path: String) async throws -> Data {\n    // Option 1: Use async-capable file I/O library (e.g., swift-nio, AsyncFileHandle)\n    // Option 2: Offload to background executor for legacy APIs\n    return try await Task.detached {\n        try Data(contentsOf: URL(fileURLWithPath: path))\n    }.value\n}\n\n// ❌ Wrong — synchronous file I/O in async context\nfunc loadConfig() async throws -> Configuration {\n    let data = try Data(contentsOf: URL(fileURLWithPath: \"/etc/config.json\")) // ⚠️ Blocks thread!\n    return try JSONDecoder().decode(Configuration.self, from: data)\n}\n\n// ✅ Correct — offload to background if no async API available\nfunc loadConfig() async throws -> Configuration {\n    let data = try await Task.detached {\n        try Data(contentsOf: URL(fileURLWithPath: \"/etc/config.json\"))\n    }.value\n    return try JSONDecoder().decode(Configuration.self, from: data)\n}\n```\n\nFor database operations, always use async database clients:\n```swift\n// ✅ Correct — async database client (e.g., PostgresNIO, MongoKitten)\nlet users = try await db.query(\"SELECT * FROM users WHERE id = $1\", [id])\n\n// ❌ Wrong — synchronous database call\nlet users = try db.executeSync(\"SELECT * FROM users WHERE id = $1\", [id])\n```",
    "layer": null,
    "patternIds": ["swift-concurrency", "async-io"],
    "violationIds": ["blocking-io-in-async"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "sendable-types",
    "title": "Sendable Conformance for Concurrent Types",
    "content": "Swift 6 strict concurrency requires that types crossing concurrency boundaries (passed to async functions, stored in actors, captured in closures) conform to `Sendable`. This prevents data races at compile time.\n\n```swift\n// ✅ Correct — Sendable structs for concurrent use\nstruct User: Sendable {\n    let id: UUID\n    let email: String\n    let createdAt: Date\n}\n\nstruct AppConfiguration: Sendable {\n    let apiURL: String\n    let timeout: Duration\n}\n\n// ✅ Correct — @unchecked Sendable for types with internal synchronization\nfinal class DatabasePool: @unchecked Sendable {\n    private let lock = NSLock()\n    private var connections: [Connection] = []\n\n    func getConnection() -> Connection {\n        lock.lock()\n        defer { lock.unlock() }\n        return connections.removeFirst()\n    }\n}\n\n// ❌ Wrong — non-Sendable type crossing concurrency boundary\nclass UserCache { // Missing Sendable conformance\n    var users: [UUID: User] = [:]\n}\n\nfunc cacheUser(_ user: User, in cache: UserCache) async {\n    cache.users[user.id] = user // ⚠️ Data race risk!\n}\n\n// ✅ Correct — use actor instead\nactor UserCache {\n    private var users: [UUID: User] = [:]\n\n    func store(_ user: User) {\n        users[user.id] = user\n    }\n\n    func get(_ id: UUID) -> User? {\n        return users[id]\n    }\n}\n```\n\nSendable conformance rules:\n- Structs with only Sendable properties are automatically Sendable\n- Actors are implicitly Sendable\n- Classes must be `final`, have only immutable properties, and use `@unchecked Sendable` if they have internal synchronization\n- Closures capturing only Sendable values are Sendable",
    "layer": null,
    "patternIds": ["swift-concurrency", "sendable"],
    "violationIds": ["missing-sendable-conformance"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "structured-concurrency",
    "title": "Structured Concurrency with Task Groups",
    "content": "Swift structured concurrency ensures tasks are properly scoped and cancelled. Use `async let` for independent concurrent tasks, `TaskGroup` for dynamic concurrency, and avoid unstructured `Task.detached` unless absolutely necessary.\n\n```swift\n// ✅ Correct — structured concurrency with async let\nfunc fetchUserData(id: String) async throws -> UserData {\n    async let user = userService.find(id: id)\n    async let posts = postService.findByUser(id: id)\n    async let comments = commentService.findByUser(id: id)\n\n    return try await UserData(\n        user: user,\n        posts: posts,\n        comments: comments\n    )\n}\n\n// ✅ Correct — TaskGroup for dynamic concurrency\nfunc fetchMultipleUsers(ids: [String]) async throws -> [User] {\n    return try await withThrowingTaskGroup(of: User.self) { group in\n        for id in ids {\n            group.addTask {\n                try await userService.find(id: id)\n            }\n        }\n        var users: [User] = []\n        for try await user in group {\n            users.append(user)\n        }\n        return users\n    }\n}\n\n// ❌ Wrong — unstructured Task.detached loses cancellation\nfunc processInBackground(data: Data) async {\n    Task.detached { // ⚠️ Not cancelled when parent is cancelled!\n        try? await heavyProcessing(data)\n    }\n    // Function returns immediately, task continues in background\n    // No way to wait for completion or handle errors\n}\n\n// ✅ Correct — child task inherits cancellation\nfunc processInBackground(data: Data) async throws {\n    try await withTaskCancellationHandler {\n        try await heavyProcessing(data)\n    } onCancel: {\n        cleanup()\n    }\n}\n```\n\nUse `Task.detached` only when you need to break actor isolation for a legitimate reason (e.g., avoiding priority inversion). Always handle cancellation explicitly.",
    "layer": null,
    "patternIds": ["swift-concurrency", "task-groups"],
    "violationIds": ["task-detached-without-isolation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "structured-logging",
    "title": "Structured Logging with swift-log",
    "content": "Hummingbird 2.x uses `swift-log` for structured logging. Never use `print()` for logging — it's not structured, can't be filtered by level, and won't appear in production logs. Always log errors with context metadata.\n\n```swift\nimport Logging\n\nstruct UserService {\n    let logger: Logger\n    let repository: any UserRepositoryProtocol\n\n    func create(_ request: CreateUserRequest) async throws -> User {\n        logger.info(\"Creating user\", metadata: [\"email\": \"\\(request.email)\"])\n\n        do {\n            let user = try await repository.insert(User(email: request.email))\n            logger.info(\"User created\", metadata: [\n                \"userId\": \"\\(user.id)\",\n                \"email\": \"\\(user.email)\"\n            ])\n            return user\n        } catch let error as DatabaseError {\n            logger.error(\"Database error creating user\", metadata: [\n                \"email\": \"\\(request.email)\",\n                \"error\": \"\\(error)\",\n                \"errorCode\": \"\\(error.code)\"\n            ])\n            throw AppError.internalError(reason: \"Failed to create user\")\n        }\n    }\n}\n\n// ❌ Wrong — print instead of logger\nfunc deleteUser(id: String) async throws {\n    do {\n        try await repository.delete(id: id)\n    } catch {\n        print(\"Error: \\(error)\") // ⚠️ Not structured, no context, can't filter!\n        throw error\n    }\n}\n\n// ❌ Wrong — swallowed error with no logging\nfunc updateUser(id: String, email: String) async throws {\n    do {\n        try await repository.update(id: id, email: email)\n    } catch {\n        // ⚠️ Error discarded silently — impossible to debug!\n    }\n}\n```\n\nLog levels:\n- `trace`: Very detailed debugging (e.g., request/response bodies)\n- `debug`: Debugging information (e.g., cache hits, query plans)\n- `info`: Normal application flow (e.g., \"User created\", \"Request started\")\n- `notice`: Important but normal events (e.g., \"Configuration loaded\")\n- `warning`: Unusual but recoverable (e.g., \"Retry attempt 2/3\")\n- `error`: Errors that should be investigated (e.g., database failures)\n- `critical`: System instability (e.g., \"Out of memory\")",
    "layer": null,
    "patternIds": ["logging", "observability"],
    "violationIds": ["print-in-error-handler", "swallowed-error", "error-discarded-with-underscore"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "explicit-http-status-codes",
    "title": "Explicit HTTP Status Codes",
    "content": "Every HTTP response must have an explicit status code. Hummingbird infers `.ok` (200) for most types, but you should be explicit, especially for error cases, redirects, and created resources.\n\n```swift\n// ✅ Correct — explicit status codes\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    let user = try await context.dependencies.userService.create(dto)\n    return Response(status: .created, body: .init(data: try JSONEncoder().encode(CreateUserResponse(user))))\n}\n\nrouter.delete(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    try await context.dependencies.userService.delete(id: id)\n    return Response(status: .noContent)\n}\n\nrouter.get(\"/health\") { request, context in\n    return Response(status: .ok, body: .init(string: \"OK\"))\n}\n\n// ❌ Wrong — missing status code (defaults to 200)\nrouter.post(\"/users\") { request, context in\n    let user = try await context.dependencies.userService.create(...)\n    return CreateUserResponse(user) // ⚠️ Should be 201 Created, not 200 OK!\n}\n\n// ❌ Wrong — generic status for errors\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    guard let user = try await context.dependencies.userService.find(id: id) else {\n        return Response(status: .badRequest) // ⚠️ Should be 404 Not Found, not 400 Bad Request!\n    }\n    return UserResponse(user)\n}\n```\n\nCommon status codes:\n- `200 OK`: Successful GET, PUT, PATCH\n- `201 Created`: Successful POST that creates a resource\n- `204 No Content`: Successful DELETE or update with no response body\n- `400 Bad Request`: Invalid input (validation error)\n- `401 Unauthorized`: Missing or invalid authentication\n- `403 Forbidden`: Valid auth but insufficient permissions\n- `404 Not Found`: Resource doesn't exist\n- `409 Conflict`: Duplicate resource or constraint violation\n- `500 Internal Server Error`: Unexpected server error",
    "layer": "controller",
    "patternIds": ["http-status-codes", "rest-api"],
    "violationIds": ["response-without-status-code"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "explicit-content-type-headers",
    "title": "Explicit Content-Type Headers",
    "content": "HTTP responses should explicitly set the Content-Type header to indicate the response format. While Hummingbird can infer types for some responses, being explicit prevents client parsing errors and improves API clarity.\n\n```swift\n// ✅ Correct — explicit Content-Type for JSON\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    let body = try JSONEncoder().encode(UserResponse(user))\n    var response = Response(status: .ok, body: .init(data: body))\n    response.headers[.contentType] = \"application/json\"\n    return response\n}\n\n// ✅ Correct — using ResponseCodable (sets Content-Type automatically)\nstruct UserResponse: ResponseCodable {\n    let id: String\n    let email: String\n}\n\nrouter.get(\"/users/:id\") { request, context in\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user) // Content-Type: application/json set automatically\n}\n\n// ✅ Correct — explicit Content-Type for HTML\nrouter.get(\"/dashboard\") { request, context in\n    let html = \"<html><body>Dashboard</body></html>\"\n    var response = Response(status: .ok, body: .init(string: html))\n    response.headers[.contentType] = \"text/html; charset=utf-8\"\n    return response\n}\n\n// ❌ Wrong — missing Content-Type for binary data\nrouter.get(\"/download\") { request, context in\n    let data = try await fileService.readFile(\"report.pdf\")\n    return Response(status: .ok, body: .init(data: data)) // ⚠️ Missing Content-Type!\n}\n\n// ✅ Correct — explicit Content-Type for binary data\nrouter.get(\"/download\") { request, context in\n    let data = try await fileService.readFile(\"report.pdf\")\n    var response = Response(status: .ok, body: .init(data: data))\n    response.headers[.contentType] = \"application/pdf\"\n    response.headers[.contentDisposition] = \"attachment; filename=\\\"report.pdf\\\"\"\n    return response\n}\n```\n\nCommon Content-Type values:\n- `application/json`: JSON data (most common for REST APIs)\n- `text/html; charset=utf-8`: HTML pages\n- `text/plain; charset=utf-8`: Plain text\n- `application/pdf`: PDF documents\n- `image/png`, `image/jpeg`: Images\n- `application/octet-stream`: Generic binary data",
    "layer": "controller",
    "patternIds": ["http-headers", "rest-api"],
    "violationIds": ["response-missing-content-type"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "router-groups-and-prefixes",
    "title": "Router Groups and Route Prefixes",
    "content": "Hummingbird 2.x routers support grouping routes with shared prefixes and middleware. Use `router.group()` to organize related endpoints logically, apply scoped middleware, and avoid repetitive path segments. Groups can be nested for hierarchical API structures.\n\n```swift\n// ✅ Correct — using router groups with prefixes\nlet apiV1 = router.group(\"/api/v1\")\n\napiV1.group(\"/users\")\n    .get { request, context in\n        // GET /api/v1/users\n        return try await context.dependencies.userService.list()\n    }\n    .get(\"/:id\") { request, context in\n        // GET /api/v1/users/:id\n        let id = try context.parameters.require(\"id\")\n        return try await context.dependencies.userService.find(id: id)\n    }\n    .post { request, context in\n        // POST /api/v1/users\n        let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n        return try await context.dependencies.userService.create(dto)\n    }\n\napiV1.group(\"/posts\")\n    .get { request, context in\n        // GET /api/v1/posts\n        return try await context.dependencies.postService.list()\n    }\n    .get(\"/:id\") { request, context in\n        // GET /api/v1/posts/:id\n        let id = try context.parameters.require(\"id\")\n        return try await context.dependencies.postService.find(id: id)\n    }\n\n// ✅ Correct — applying middleware to a group\nlet authenticated = router.group()\n    .add(middleware: AuthMiddleware())\n\nauthenticated.group(\"/admin\")\n    .get(\"/dashboard\") { request, context in\n        // Requires authentication via AuthMiddleware\n        return try await context.dependencies.adminService.getDashboard()\n    }\n    .delete(\"/users/:id\") { request, context in\n        let id = try context.parameters.require(\"id\")\n        return try await context.dependencies.userService.delete(id: id)\n    }\n\n// ❌ Wrong — repeating prefixes in every route\nrouter.get(\"/api/v1/users\") { request, context in\n    return try await context.dependencies.userService.list()\n}\n\nrouter.get(\"/api/v1/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.userService.find(id: id)\n}\n\nrouter.get(\"/api/v1/posts\") { request, context in\n    return try await context.dependencies.postService.list()\n}\n\nrouter.get(\"/api/v1/posts/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.postService.find(id: id)\n}\n// ⚠️ Repetitive, hard to refactor, middleware must be added to each route\n\n// ❌ Wrong — applying middleware to individual routes instead of groups\nrouter.get(\"/admin/dashboard\") { request, context in\n    // Must manually check auth in every handler\n    guard try await context.dependencies.authService.isAuthenticated(request) else {\n        throw HTTPError(.unauthorized)\n    }\n    return try await context.dependencies.adminService.getDashboard()\n}\n```\n\nBest practices:\n- Group routes by resource (`/users`, `/posts`, `/comments`)\n- Use versioned groups (`/api/v1`, `/api/v2`) for API versioning\n- Apply middleware at the group level, not per route\n- Nest groups for hierarchical structures (`/api/v1/admin/users`)\n- Keep route definitions close to related routes for readability",
    "layer": "controller",
    "patternIds": ["router-groups", "route-organization", "middleware-scoping"],
    "violationIds": ["repeated-route-prefixes", "middleware-duplication"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "response-body-streaming-patterns",
    "title": "Response Body Types and Streaming Patterns",
    "content": "Hummingbird 2.x uses NIO's `ByteBuffer` and Swift's `AsyncSequence` for response bodies. Understanding these types is critical for efficient streaming, file downloads, and large response handling. Never buffer entire large responses in memory — stream them instead.\n\n```swift\nimport Hummingbird\nimport NIOCore\n\n// ✅ Correct — streaming file download with AsyncSequence\nrouter.get(\"/download/:filename\") { request, context in\n    let filename = try context.parameters.require(\"filename\")\n    let fileStream = try await context.dependencies.fileService.streamFile(filename)\n    \n    // ResponseBody accepts AsyncSequence<ByteBuffer, Error>\n    var response = Response(\n        status: .ok,\n        body: .init(asyncSequence: fileStream)\n    )\n    response.headers[.contentType] = \"application/octet-stream\"\n    response.headers[.contentDisposition] = \"attachment; filename=\\\"\\(filename)\\\"\"\n    return response\n}\n\n// ✅ Correct — streaming JSON array with backpressure handling\nstruct UserStreamService {\n    func streamAllUsers() -> AsyncStream<ByteBuffer, Error> {\n        AsyncStream { continuation in\n            Task {\n                do {\n                    let users = try await repository.findAll()\n                    var buffer = ByteBufferAllocator().buffer(capacity: 1024)\n                    buffer.writeString(\"[\")\n                    continuation.yield(buffer)\n                    \n                    for (index, user) in users.enumerated() {\n                        var itemBuffer = ByteBufferAllocator().buffer(capacity: 256)\n                        if index > 0 {\n                            itemBuffer.writeString(\",\")\n                        }\n                        let userData = try JSONEncoder().encode(user)\n                        itemBuffer.writeBytes(userData)\n                        continuation.yield(itemBuffer)\n                    }\n                    \n                    var endBuffer = ByteBufferAllocator().buffer(capacity: 1)\n                    endBuffer.writeString(\"]\")\n                    continuation.yield(endBuffer)\n                    continuation.finish()\n                } catch {\n                    continuation.finish(throwing: error)\n                }\n            }\n        }\n    }\n}\n\n// ✅ Correct — static ByteBuffer for small responses\nrouter.get(\"/health\") { request, context in\n    var buffer = ByteBufferAllocator().buffer(capacity: 16)\n    buffer.writeString(\"{\\\"status\\\":\\\"ok\\\"}\")\n    var response = Response(status: .ok, body: .init(byteBuffer: buffer))\n    response.headers[.contentType] = \"application/json\"\n    return response\n}\n\n// ❌ Wrong — loading entire large file into memory\nrouter.get(\"/download/:filename\") { request, context in\n    let filename = try context.parameters.require(\"filename\")\n    let data = try await fileService.readEntireFile(filename) // ⚠️ OOM for large files!\n    var buffer = ByteBufferAllocator().buffer(capacity: data.count)\n    buffer.writeBytes(data)\n    return Response(status: .ok, body: .init(byteBuffer: buffer))\n}\n\n// ❌ Wrong — buffering entire stream before sending\nrouter.get(\"/users/export\") { request, context in\n    let users = try await context.dependencies.userService.findAll()\n    var allData = Data()\n    for user in users {\n        allData.append(try JSONEncoder().encode(user)) // ⚠️ Builds entire response in memory!\n    }\n    var buffer = ByteBufferAllocator().buffer(capacity: allData.count)\n    buffer.writeBytes(allData)\n    return Response(status: .ok, body: .init(byteBuffer: buffer))\n}\n\n// ❌ Wrong — AsyncSequence without error handling\nfunc streamData() -> AsyncStream<ByteBuffer, Never> {\n    AsyncStream { continuation in\n        Task {\n            let data = try! await fetchData() // ⚠️ Force-try crashes on error!\n            var buffer = ByteBufferAllocator().buffer(capacity: data.count)\n            buffer.writeBytes(data)\n            continuation.yield(buffer)\n            continuation.finish()\n        }\n    }\n}\n\n// ✅ Correct — AsyncSequence with proper error propagation\nfunc streamData() -> AsyncThrowingStream<ByteBuffer, Error> {\n    AsyncThrowingStream { continuation in\n        Task {\n            do {\n                let data = try await fetchData()\n                var buffer = ByteBufferAllocator().buffer(capacity: data.count)\n                buffer.writeBytes(data)\n                continuation.yield(buffer)\n                continuation.finish()\n            } catch {\n                continuation.finish(throwing: error)\n            }\n        }\n    }\n}\n```\n\nKey types:\n- `ByteBuffer`: NIO's efficient byte container (copy-on-write, ref-counted)\n- `ResponseBody`: Wrapper supporting `.init(byteBuffer:)`, `.init(asyncSequence:)`, `.init(data:)`, `.init(string:)`\n- `AsyncSequence<ByteBuffer, Error>`: Protocol for streaming responses\n- `AsyncStream` / `AsyncThrowingStream`: Concrete async sequence types\n\nCommon pitfalls:\n- Loading entire files into memory instead of streaming\n- Buffering entire response before sending (defeats streaming)\n- Using `AsyncStream<ByteBuffer, Never>` for operations that can fail (use `AsyncThrowingStream`)\n- Not setting `Content-Length` header for known-size responses\n- Not handling backpressure (NIO handles this automatically with AsyncSequence)\n- Creating new `ByteBufferAllocator` per request (use shared allocator from context)\n- Force-unwrapping or `try!` in stream producers (always propagate errors via continuation)",
    "layer": "controller",
    "patternIds": ["response-streaming", "bytebuffer", "async-sequence", "backpressure"],
    "violationIds": ["buffering-entire-stream", "missing-stream-error-handling", "force-try-in-stream", "oom-large-file-in-memory"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "multipart-form-data-handling",
    "title": "Multipart Form Data and File Uploads",
    "content": "Hummingbird 2.x handles multipart form data through the request body stream. For file uploads, you must parse the multipart boundary, extract parts, and stream file content to storage without buffering the entire file in memory. Use a multipart parser library or implement streaming multipart parsing.\n\n```swift\nimport Hummingbird\nimport NIOCore\n\n// ✅ Correct — streaming file upload with multipart parsing\nrouter.post(\"/upload\") { request, context in\n    guard let contentType = request.headers[.contentType],\n          contentType.hasPrefix(\"multipart/form-data\") else {\n        throw HTTPError(.badRequest, message: \"Content-Type must be multipart/form-data\")\n    }\n    \n    // Extract boundary from Content-Type header\n    guard let boundary = extractBoundary(from: contentType) else {\n        throw HTTPError(.badRequest, message: \"Missing boundary in Content-Type\")\n    }\n    \n    let uploadService = context.dependencies.uploadService\n    let fileMetadata = try await uploadService.handleMultipartUpload(\n        body: request.body,\n        boundary: boundary\n    )\n    \n    return Response(\n        status: .created,\n        body: .init(data: try JSONEncoder().encode(UploadResponse(fileMetadata)))\n    )\n}\n\n// Service layer — streaming multipart parser\nstruct UploadService {\n    let storage: any FileStorageProtocol\n    let logger: Logger\n    \n    func handleMultipartUpload(\n        body: Request.Body,\n        boundary: String\n    ) async throws -> FileMetadata {\n        var parser = MultipartParser(boundary: boundary)\n        var currentFile: FileUploadContext?\n        \n        for try await chunk in body {\n            let parts = try parser.parse(chunk)\n            \n            for part in parts {\n                switch part {\n                case .headers(let headers):\n                    // Extract filename and content-type from part headers\n                    guard let disposition = headers[\"content-disposition\"],\n                          let filename = extractFilename(from: disposition) else {\n                        throw AppError.invalidInput(reason: \"Missing filename\")\n                    }\n                    \n                    let contentType = headers[\"content-type\"] ?? \"application/octet-stream\"\n                    currentFile = try await storage.createUpload(\n                        filename: filename,\n                        contentType: contentType\n                    )\n                    \n                case .body(let data):\n                    guard let file = currentFile else {\n                        throw AppError.invalidInput(reason: \"Received body before headers\")\n                    }\n                    try await storage.writeChunk(data, to: file)\n                    \n                case .end:\n                    guard let file = currentFile else {\n                        throw AppError.invalidInput(reason: \"Received end before file start\")\n                    }\n                    try await storage.finalizeUpload(file)\n                    currentFile = nil\n                }\n            }\n        }\n        \n        guard let file = currentFile else {\n            throw AppError.invalidInput(reason: \"No file uploaded\")\n        }\n        \n        return try await storage.getMetadata(for: file)\n    }\n}\n\nfunc extractBoundary(from contentType: String) -> String? {\n    let components = contentType.split(separator: \";\")\n    for component in components {\n        let trimmed = component.trimmingCharacters(in: .whitespaces)\n        if trimmed.hasPrefix(\"boundary=\") {\n            return String(trimmed.dropFirst(\"boundary=\".count))\n        }\n    }\n    return nil\n}\n\n// ❌ Wrong — buffering entire file upload in memory\nrouter.post(\"/upload\") { request, context in\n    var allData = Data()\n    for try await chunk in request.body {\n        allData.append(contentsOf: chunk.readableBytesView) // ⚠️ OOM for large files!\n    }\n    \n    // Parse entire multipart body from memory\n    let file = try parseMultipart(allData)\n    try await storage.save(file)\n    return Response(status: .created)\n}\n\n// ❌ Wrong — missing Content-Type validation\nrouter.post(\"/upload\") { request, context in\n    // No check for multipart/form-data!\n    let file = try await uploadService.handleUpload(request.body)\n    return Response(status: .created)\n}\n\n// ❌ Wrong — synchronous file write in async context\nrouter.post(\"/upload\") { request, context in\n    let filename = UUID().uuidString\n    let handle = FileHandle(forWritingAtPath: \"/uploads/\\(filename)\")! // ⚠️ Synchronous!\n    \n    for try await chunk in request.body {\n        handle.write(Data(buffer: chunk)) // ⚠️ Blocks executor thread!\n    }\n    \n    handle.closeFile()\n    return Response(status: .created)\n}\n```\n\nBest practices:\n- Always validate `Content-Type: multipart/form-data` before parsing\n- Extract and validate the boundary parameter from Content-Type header\n- Stream file chunks directly to storage (disk, S3, etc.) without buffering entire file\n- Set upload size limits to prevent DoS attacks (use middleware or check Content-Length)\n- Validate filenames to prevent directory traversal attacks (sanitize `../`, absolute paths)\n- Use async file I/O or object storage SDKs (never synchronous file operations)\n- Return file metadata (ID, size, content-type) in response, not the file content itself\n- Clean up partial uploads on errors (delete incomplete files)\n- Consider using a battle-tested multipart parser library instead of custom parsing",
    "layer": "controller",
    "patternIds": ["multipart-form-data", "file-upload", "request-streaming"],
    "violationIds": ["buffering-entire-upload", "missing-content-type-validation", "synchronous-file-write", "directory-traversal-vulnerability"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "request-body-streaming",
    "title": "Streaming Request Bodies with AsyncSequence",
    "content": "Hummingbird 2.x provides `Request.Body` as an `AsyncSequence<ByteBuffer>` for streaming large request payloads. Never call `request.decode()` for large uploads — it buffers the entire body. Instead, iterate the body stream chunk-by-chunk for memory-efficient processing.\n\n```swift\nimport Hummingbird\nimport NIOCore\n\n// ✅ Correct — streaming request body processing\nrouter.post(\"/ingest\") { request, context in\n    var totalBytes = 0\n    var hasher = SHA256()\n    \n    // Process request body as stream\n    for try await chunk in request.body {\n        totalBytes += chunk.readableBytes\n        hasher.update(data: chunk.readableBytesView)\n        \n        // Stream to storage or process incrementally\n        try await context.dependencies.dataService.processChunk(chunk)\n    }\n    \n    let hash = hasher.finalize()\n    logger.info(\"Processed streaming request\", metadata: [\n        \"totalBytes\": \"\\(totalBytes)\",\n        \"hash\": \"\\(hash.hexString)\"\n    ])\n    \n    return Response(status: .accepted)\n}\n\n// ✅ Correct — streaming CSV import line-by-line\nrouter.post(\"/import/csv\") { request, context in\n    var lineBuffer = ByteBufferAllocator().buffer(capacity: 1024)\n    var recordsImported = 0\n    \n    for try await chunk in request.body {\n        lineBuffer.writeImmutableBuffer(chunk)\n        \n        // Process complete lines\n        while let line = lineBuffer.readLine() {\n            let record = try parseCSVLine(line)\n            try await context.dependencies.importService.insertRecord(record)\n            recordsImported += 1\n        }\n    }\n    \n    // Process remaining partial line if any\n    if lineBuffer.readableBytes > 0 {\n        let line = lineBuffer.readString(length: lineBuffer.readableBytes)!\n        let record = try parseCSVLine(line)\n        try await context.dependencies.importService.insertRecord(record)\n        recordsImported += 1\n    }\n    \n    return Response(\n        status: .ok,\n        body: .init(data: try JSONEncoder().encode(ImportResponse(recordsImported: recordsImported)))\n    )\n}\n\n// ✅ Correct — streaming request with Content-Length validation\nrouter.post(\"/upload\") { request, context in\n    guard let contentLengthStr = request.headers[.contentLength],\n          let contentLength = Int(contentLengthStr) else {\n        throw HTTPError(.lengthRequired, message: \"Content-Length header required\")\n    }\n    \n    let maxUploadSize = 100 * 1024 * 1024 // 100 MB\n    guard contentLength <= maxUploadSize else {\n        throw HTTPError(.payloadTooLarge, message: \"Upload exceeds \\(maxUploadSize) bytes\")\n    }\n    \n    var totalReceived = 0\n    for try await chunk in request.body {\n        totalReceived += chunk.readableBytes\n        \n        // Enforce limit even if Content-Length header is wrong\n        guard totalReceived <= maxUploadSize else {\n            throw HTTPError(.payloadTooLarge, message: \"Upload size exceeded during transfer\")\n        }\n        \n        try await context.dependencies.uploadService.writeChunk(chunk)\n    }\n    \n    guard totalReceived == contentLength else {\n        throw HTTPError(.badRequest, message: \"Received \\(totalReceived) bytes, expected \\(contentLength)\")\n    }\n    \n    return Response(status: .created)\n}\n\n// ❌ Wrong — buffering entire request body\nrouter.post(\"/process\") { request, context in\n    var allData = ByteBufferAllocator().buffer(capacity: 0)\n    for try await chunk in request.body {\n        allData.writeImmutableBuffer(chunk) // ⚠️ Buffers entire request in memory!\n    }\n    \n    try await processData(allData) // Memory spike for large requests\n    return Response(status: .ok)\n}\n\n// ❌ Wrong — using request.decode() for large payloads\nrouter.post(\"/import\") { request, context in\n    // ⚠️ Buffers entire JSON array in memory before parsing!\n    let records = try await request.decode(as: [ImportRecord].self, context: context)\n    \n    for record in records {\n        try await context.dependencies.importService.insertRecord(record)\n    }\n    \n    return Response(status: .ok)\n}\n\n// ❌ Wrong — no upload size limit enforcement\nrouter.post(\"/upload\") { request, context in\n    // No size limit! ⚠️ Attacker can send unlimited data\n    for try await chunk in request.body {\n        try await storage.write(chunk)\n    }\n    return Response(status: .created)\n}\n\n// ❌ Wrong — ignoring backpressure in stream processing\nrouter.post(\"/ingest\") { request, context in\n    for try await chunk in request.body {\n        // Spawning detached task loses backpressure!\n        Task.detached {\n            try? await slowProcessor.process(chunk) // ⚠️ Tasks queue up unbounded!\n        }\n    }\n    return Response(status: .accepted)\n}\n\n// ✅ Correct — respecting backpressure\nrouter.post(\"/ingest\") { request, context in\n    for try await chunk in request.body {\n        // Await each chunk processing before reading next\n        try await slowProcessor.process(chunk) // Backpressure maintained\n    }\n    return Response(status: .accepted)\n}\n```\n\nKey points:\n- `Request.Body` is `AsyncSequence<ByteBuffer>` — iterate with `for try await`\n- Each iteration yields a `ByteBuffer` chunk (not necessarily the entire body)\n- Use `request.decode()` only for small, trusted payloads (< 1 MB)\n- For large uploads, stream chunks to storage without buffering\n- Always enforce upload size limits (check `Content-Length`, track bytes received)\n- Validate `Content-Length` header matches actual received bytes\n- Respect backpressure — await async operations inside loop, don't spawn detached tasks\n- For line-based protocols (CSV, NDJSON), accumulate chunks into line buffer\n- Use `ByteBuffer.readLine()` or manual parsing for incremental processing\n- Clean up resources on error (close files, abort multipart uploads, etc.)\n\nCommon mistakes:\n- Buffering entire body before processing (defeats streaming)\n- Using `request.decode()` for large uploads (OOM risk)\n- Missing upload size limits (DoS vulnerability)\n- Spawning detached tasks in loop (loses backpressure, unbounded memory growth)\n- Not validating Content-Length header\n- Synchronous I/O in stream processing (blocks executor threads)",
    "layer": "controller",
    "patternIds": ["request-streaming", "async-sequence", "backpressure", "upload-limits"],
    "violationIds": ["buffering-entire-request", "missing-upload-size-limit", "detached-task-in-stream-loop", "request-decode-for-large-payload"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "file-upload-security",
    "title": "File Upload Security Best Practices",
    "content": "File uploads are a major security risk. Every file upload endpoint must validate file type, size, filename, and content. Never trust client-provided filenames, MIME types, or file extensions. Always sanitize, validate, and scan uploaded files before storage or processing.\n\n```swift\nimport Hummingbird\nimport Foundation\n\n// ✅ Correct — comprehensive file upload validation\nstruct FileUploadService {\n    let storage: any FileStorageProtocol\n    let logger: Logger\n    let config: UploadConfiguration\n    \n    func validateAndStoreUpload(\n        filename: String,\n        contentType: String,\n        body: Request.Body\n    ) async throws -> FileMetadata {\n        // 1. Validate and sanitize filename\n        let sanitizedFilename = try sanitizeFilename(filename)\n        \n        // 2. Validate MIME type against allowlist\n        guard config.allowedMimeTypes.contains(contentType) else {\n            logger.warning(\"Rejected upload with disallowed MIME type\", metadata: [\n                \"filename\": \"\\(sanitizedFilename)\",\n                \"contentType\": \"\\(contentType)\"\n            ])\n            throw AppError.invalidInput(reason: \"File type \\(contentType) not allowed\")\n        }\n        \n        // 3. Extract and validate file extension\n        let fileExtension = (sanitizedFilename as NSString).pathExtension.lowercased()\n        guard config.allowedExtensions.contains(fileExtension) else {\n            throw AppError.invalidInput(reason: \"File extension .\\(fileExtension) not allowed\")\n        }\n        \n        // 4. Generate secure random filename (don't use client filename)\n        let secureFilename = \"\\(UUID().uuidString).\\(fileExtension)\"\n        \n        // 5. Stream to temporary location with size limit\n        let tempPath = try await storage.createTempFile(secureFilename)\n        var bytesWritten = 0\n        \n        do {\n            for try await chunk in body {\n                bytesWritten += chunk.readableBytes\n                \n                // Enforce size limit during upload\n                guard bytesWritten <= config.maxUploadSizeBytes else {\n                    try await storage.deleteTempFile(tempPath)\n                    throw AppError.invalidInput(reason: \"File exceeds maximum size of \\(config.maxUploadSizeBytes) bytes\")\n                }\n                \n                try await storage.writeToTempFile(chunk, at: tempPath)\n            }\n            \n            // 6. Validate actual content type by inspecting file magic bytes\n            let actualContentType = try await detectContentType(at: tempPath)\n            guard actualContentType == contentType else {\n                logger.warning(\"Content-Type mismatch\", metadata: [\n                    \"declared\": \"\\(contentType)\",\n                    \"actual\": \"\\(actualContentType)\"\n                ])\n                try await storage.deleteTempFile(tempPath)\n                throw AppError.invalidInput(reason: \"File content does not match declared type\")\n            }\n            \n            // 7. Optional: Virus scan (if available)\n            if let virusScanner = config.virusScanner {\n                let isSafe = try await virusScanner.scan(tempPath)\n                guard isSafe else {\n                    logger.error(\"Virus detected in uploaded file\", metadata: [\n                        \"filename\": \"\\(sanitizedFilename)\"\n                    ])\n                    try await storage.deleteTempFile(tempPath)\n                    throw AppError.securityViolation(reason: \"File failed security scan\")\n                }\n            }\n            \n            // 8. Move to permanent storage\n            let permanentPath = try await storage.moveToPermStorage(tempPath, as: secureFilename)\n            \n            return FileMetadata(\n                id: UUID().uuidString,\n                filename: sanitizedFilename,\n                secureFilename: secureFilename,\n                path: permanentPath,\n                sizeBytes: bytesWritten,\n                contentType: actualContentType\n            )\n            \n        } catch {\n            // Clean up temp file on any error\n            try? await storage.deleteTempFile(tempPath)\n            throw error\n        }\n    }\n    \n    func sanitizeFilename(_ filename: String) throws -> String {\n        // Remove path separators to prevent directory traversal\n        var sanitized = filename.replacingOccurrences(of: \"/\", with: \"_\")\n        sanitized = sanitized.replacingOccurrences(of: \"\\\\\", with: \"_\")\n        sanitized = sanitized.replacingOccurrences(of: \"..\", with: \"_\")\n        \n        // Remove null bytes\n        sanitized = sanitized.replacingOccurrences(of: \"\\0\", with: \"\")\n        \n        // Limit length\n        if sanitized.count > 255 {\n            sanitized = String(sanitized.prefix(255))\n        }\n        \n        // Ensure filename is not empty after sanitization\n        guard !sanitized.isEmpty else {\n            throw AppError.invalidInput(reason: \"Invalid filename\")\n        }\n        \n        return sanitized\n    }\n    \n    func detectContentType(at path: String) async throws -> String {\n        // Read first few bytes (magic bytes) to detect actual file type\n        let magicBytes = try await storage.readBytes(at: path, count: 16)\n        \n        // Check magic bytes against known file signatures\n        if magicBytes.starts(with: [0xFF, 0xD8, 0xFF]) {\n            return \"image/jpeg\"\n        } else if magicBytes.starts(with: [0x89, 0x50, 0x4E, 0x47]) {\n            return \"image/png\"\n        } else if magicBytes.starts(with: [0x25, 0x50, 0x44, 0x46]) {\n            return \"application/pdf\"\n        }\n        // ... more magic byte checks\n        \n        return \"application/octet-stream\"\n    }\n}\n\nstruct UploadConfiguration: Sendable {\n    let maxUploadSizeBytes: Int\n    let allowedMimeTypes: Set<String>\n    let allowedExtensions: Set<String>\n    let virusScanner: (any VirusScannerProtocol)?\n}\n\n// ❌ CRITICAL VULNERABILITY — using client filename directly\nrouter.post(\"/upload\") { request, context in\n    let filename = request.headers[\"x-filename\"] ?? \"upload.bin\"\n    let path = \"/uploads/\\(filename)\" // ⚠️ DIRECTORY TRAVERSAL!\n    // Attacker sends: x-filename: ../../../../etc/passwd\n    try await storage.writeFile(path, body: request.body)\n    return Response(status: .created)\n}\n\n// ❌ CRITICAL — trusting Content-Type header without validation\nrouter.post(\"/upload\") { request, context in\n    let contentType = request.headers[.contentType] ?? \"application/octet-stream\"\n    // ⚠️ Attacker sets Content-Type: image/jpeg but uploads executable!\n    let file = try await storage.save(request.body, as: contentType)\n    return Response(status: .created)\n}\n\n// ❌ CRITICAL — no file size limit\nrouter.post(\"/upload\") { request, context in\n    // ⚠️ Attacker can fill disk with unlimited upload!\n    try await storage.save(request.body)\n    return Response(status: .created)\n}\n\n// ❌ Wrong — file extension validation only\nfunc validateFile(filename: String) -> Bool {\n    return filename.hasSuffix(\".jpg\") || filename.hasSuffix(\".png\")\n    // ⚠️ Attacker uploads malware.exe.jpg — passes validation!\n}\n```\n\nSecurity checklist:\n- ✅ Sanitize filenames (remove `../`, `/`, `\\\\`, null bytes)\n- ✅ Never use client-provided filenames for storage paths (use UUIDs)\n- ✅ Validate MIME type against allowlist (never use blocklist)\n- ✅ Validate file extension against allowlist\n- ✅ Detect actual file type from magic bytes, not extension or Content-Type header\n- ✅ Enforce maximum upload size (both Content-Length and actual bytes)\n- ✅ Store uploads outside web root (prevent direct URL access)\n- ✅ Use random filenames (UUIDs) to prevent filename collisions and guessing\n- ✅ Scan for viruses/malware if handling untrusted uploads\n- ✅ Set restrictive file permissions on upload directory\n- ✅ Rate-limit upload endpoints to prevent abuse\n- ✅ Log all upload attempts (successful and failed) for security monitoring\n- ✅ Clean up temp files on errors\n- ✅ Consider storing uploads in object storage (S3) instead of local filesystem\n\nCommon vulnerabilities:\n- Directory traversal (filename: `../../etc/passwd`)\n- Arbitrary file upload (upload `.php`, `.jsp` to execute server-side code)\n- MIME type mismatch (declare image/jpeg, upload executable)\n- Zip bombs / billion laughs (compressed files that expand to GB)\n- XXE attacks in XML/SVG uploads\n- Malware distribution (upload infected files)\n- Disk space exhaustion (unlimited upload size)\n- Path disclosure (error messages reveal filesystem structure)",
    "layer": "service",
    "patternIds": ["security", "file-upload", "input-validation"],
    "violationIds": ["directory-traversal-vulnerability", "untrusted-filename", "missing-mime-type-validation", "missing-upload-size-limit", "missing-magic-byte-validation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "error-middleware-pattern",
    "title": "Error Middleware for Centralized Error Handling",
    "content": "Error middleware catches all errors thrown by handlers and transforms them into appropriate HTTP responses. This centralizes error handling logic, ensures consistent error responses, prevents error details from leaking to clients, and provides a single point for error logging.\n\n```swift\nimport Hummingbird\nimport Logging\n\n// ✅ Correct — centralized error middleware\nstruct ErrorMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let logger: Logger\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        do {\n            return try await next(request, context)\n        } catch let error as AppError {\n            // Handle typed application errors\n            return handleAppError(error, request: request)\n        } catch let error as HTTPError {\n            // Handle Hummingbird HTTP errors\n            return handleHTTPError(error, request: request)\n        } catch {\n            // Catch any unexpected errors\n            logger.error(\"Unexpected error\", metadata: [\n                \"error\": \"\\(error)\",\n                \"path\": \"\\(request.uri.path)\",\n                \"method\": \"\\(request.method)\"\n            ])\n            return Response(\n                status: .internalServerError,\n                headers: [.contentType: \"application/json\"],\n                body: .init(data: errorJSON(\"Internal server error\", code: 500))\n            )\n        }\n    }\n\n    private func handleAppError(_ error: AppError, request: Request) -> Response {\n        let (status, message, code) = mapAppErrorToHTTP(error)\n        \n        // Log based on severity\n        switch status {\n        case .internalServerError, .serviceUnavailable:\n            logger.error(\"Application error\", metadata: [\n                \"error\": \"\\(error)\",\n                \"path\": \"\\(request.uri.path)\",\n                \"method\": \"\\(request.method)\"\n            ])\n        case .badRequest, .unauthorized, .forbidden, .notFound:\n            logger.info(\"Client error\", metadata: [\n                \"error\": \"\\(error)\",\n                \"status\": \"\\(status.code)\"\n            ])\n        default:\n            logger.warning(\"Error\", metadata: [\"error\": \"\\(error)\"])\n        }\n\n        return Response(\n            status: status,\n            headers: [.contentType: \"application/json\"],\n            body: .init(data: errorJSON(message, code: code))\n        )\n    }\n\n    private func handleHTTPError(_ error: HTTPError, request: Request) -> Response {\n        logger.info(\"HTTP error\", metadata: [\n            \"status\": \"\\(error.status.code)\",\n            \"path\": \"\\(request.uri.path)\"\n        ])\n        return Response(\n            status: error.status,\n            headers: [.contentType: \"application/json\"],\n            body: .init(data: errorJSON(\n                error.status.reasonPhrase,\n                code: Int(error.status.code)\n            ))\n        )\n    }\n\n    private func mapAppErrorToHTTP(_ error: AppError) -> (HTTPResponse.Status, String, Int) {\n        switch error {\n        case .invalidInput(let reason):\n            return (.badRequest, reason, 400)\n        case .unauthorized(let reason):\n            return (.unauthorized, reason, 401)\n        case .forbidden(let reason):\n            return (.forbidden, reason, 403)\n        case .notFound(let reason):\n            return (.notFound, reason, 404)\n        case .conflict(let reason):\n            return (.conflict, reason, 409)\n        case .validationError(let reason):\n            return (.unprocessableEntity, reason, 422)\n        case .internalError:\n            // Never expose internal error details to clients!\n            return (.internalServerError, \"Internal server error\", 500)\n        case .serviceUnavailable(let reason):\n            return (.serviceUnavailable, reason, 503)\n        }\n    }\n\n    private func errorJSON(_ message: String, code: Int) -> Data {\n        let json = \"\"\"\n        {\n            \"error\": {\n                \"message\": \"\\(message)\",\n                \"code\": \\(code)\n            }\n        }\n        \"\"\"\n        return Data(json.utf8)\n    }\n}\n\n// Register error middleware FIRST — order matters!\nrouter.add(middleware: ErrorMiddleware(logger: logger))\nrouter.add(middleware: DependencyInjectionMiddleware(dependencies: deps))\nrouter.get(\"/users/:id\") { request, context in\n    // Any error thrown here will be caught by ErrorMiddleware\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user)\n}\n\n// ❌ Wrong — error handling in every route handler\nrouter.get(\"/users/:id\") { request, context in\n    do {\n        let id = try context.parameters.require(\"id\")\n        let user = try await context.dependencies.userService.find(id: id)\n        return UserResponse(user)\n    } catch {\n        // Duplicated error handling logic!\n        return Response(\n            status: .internalServerError,\n            body: .init(string: \"Error: \\(error)\")\n        )\n    }\n}\n\n// ❌ CRITICAL — leaking internal error details\nrouter.get(\"/users/:id\") { request, context in\n    do {\n        let user = try await context.dependencies.userService.find(id: \"123\")\n        return UserResponse(user)\n    } catch {\n        // ⚠️ Exposes database connection strings, stack traces, etc!\n        return Response(\n            status: .internalServerError,\n            body: .init(string: \"Database error: \\(error)\")\n        )\n    }\n}\n\n// ❌ Wrong — inconsistent error response format\nrouter.get(\"/users/:id\") { request, context in\n    guard let user = try? await context.dependencies.userService.find(id: \"123\") else {\n        return Response(status: .notFound, body: .init(string: \"Not found\"))\n    }\n    return UserResponse(user)\n}\n\nrouter.get(\"/posts/:id\") { request, context in\n    guard let post = try? await context.dependencies.postService.find(id: \"123\") else {\n        // Different format from /users/:id!\n        return Response(\n            status: .notFound,\n            headers: [.contentType: \"application/json\"],\n            body: .init(string: \"{\\\"error\\\":\\\"Post not found\\\"}\")\n        )\n    }\n    return PostResponse(post)\n}\n```\n\nBest practices:\n- Add error middleware FIRST in the middleware chain\n- Map all AppError cases to appropriate HTTP status codes\n- Return consistent JSON error format across all endpoints\n- Log errors with appropriate severity (error vs warning vs info)\n- Never expose internal error details (database errors, stack traces) to clients\n- Include request metadata in error logs (path, method, user ID)\n- Use structured logging (Logger.Metadata) for searchability\n- Return user-friendly error messages\n- Consider adding error tracking integration (Sentry, Rollbar)\n- Test error responses in integration tests",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "error-handling", "centralized-error-handling"],
    "violationIds": ["inline-error-handling", "error-detail-leakage", "inconsistent-error-responses"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "cors-middleware-pattern",
    "title": "CORS Middleware Pattern",
    "content": "CORS (Cross-Origin Resource Sharing) middleware handles preflight OPTIONS requests and adds appropriate CORS headers to responses. Configure allowed origins, methods, headers, and credentials policy. Never use wildcard (`*`) origins with credentials, and always validate origins against an allowlist in production.\n\n```swift\nimport Hummingbird\nimport HTTPTypes\n\n// ✅ Correct — production-ready CORS middleware\nstruct CORSMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    private let config: CORSConfiguration\n\n    init(config: CORSConfiguration) {\n        self.config = config\n    }\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Handle preflight OPTIONS request\n        if request.method == .options {\n            return handlePreflight(request: request)\n        }\n\n        // Process actual request and add CORS headers to response\n        var response = try await next(request, context)\n        response = addCORSHeaders(to: response, for: request)\n        return response\n    }\n\n    private func handlePreflight(request: Request) -> Response {\n        var headers: HTTPFields = [:]\n\n        // Validate origin\n        if let origin = request.headers[HTTPField.Name(\"origin\")!],\n           isOriginAllowed(origin) {\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = origin\n\n            if config.allowCredentials {\n                headers[HTTPField.Name(\"access-control-allow-credentials\")!] = \"true\"\n            }\n        } else if config.allowedOrigins.contains(\"*\") {\n            // Wildcard only if credentials not allowed\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n        }\n\n        // Add allowed methods\n        let allowedMethods = config.allowedMethods.map { $0.rawValue }.joined(separator: \", \")\n        headers[HTTPField.Name(\"access-control-allow-methods\")!] = allowedMethods\n\n        // Add allowed headers\n        if !config.allowedHeaders.isEmpty {\n            let allowedHeaders = config.allowedHeaders.joined(separator: \", \")\n            headers[HTTPField.Name(\"access-control-allow-headers\")!] = allowedHeaders\n        }\n\n        // Add max age for preflight cache\n        if let maxAge = config.maxAge {\n            headers[HTTPField.Name(\"access-control-max-age\")!] = \"\\(maxAge)\"\n        }\n\n        return Response(status: .noContent, headers: headers)\n    }\n\n    private func addCORSHeaders(to response: Response, for request: Request) -> Response {\n        var headers = response.headers\n\n        // Validate and set origin\n        if let origin = request.headers[HTTPField.Name(\"origin\")!],\n           isOriginAllowed(origin) {\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = origin\n\n            if config.allowCredentials {\n                headers[HTTPField.Name(\"access-control-allow-credentials\")!] = \"true\"\n            }\n        } else if config.allowedOrigins.contains(\"*\") {\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n        }\n\n        // Add exposed headers\n        if !config.exposedHeaders.isEmpty {\n            let exposedHeaders = config.exposedHeaders.joined(separator: \", \")\n            headers[HTTPField.Name(\"access-control-expose-headers\")!] = exposedHeaders\n        }\n\n        return Response(\n            status: response.status,\n            headers: headers,\n            body: response.body\n        )\n    }\n\n    private func isOriginAllowed(_ origin: String) -> Bool {\n        if config.allowedOrigins.contains(\"*\") {\n            return true\n        }\n        return config.allowedOrigins.contains(origin)\n    }\n}\n\n// CORS configuration\nstruct CORSConfiguration: Sendable {\n    let allowedOrigins: Set<String>\n    let allowedMethods: Set<HTTPRequest.Method>\n    let allowedHeaders: Set<String>\n    let exposedHeaders: Set<String>\n    let allowCredentials: Bool\n    let maxAge: Int?\n\n    // Production configuration — explicit origin allowlist\n    static func production(allowedOrigins: Set<String>) -> CORSConfiguration {\n        CORSConfiguration(\n            allowedOrigins: allowedOrigins,\n            allowedMethods: [.get, .post, .put, .patch, .delete, .options],\n            allowedHeaders: [\"content-type\", \"authorization\", \"x-requested-with\"],\n            exposedHeaders: [\"content-length\", \"content-type\"],\n            allowCredentials: true,\n            maxAge: 3600\n        )\n    }\n\n    // Development configuration — allow all origins (use only in development!)\n    static var development: CORSConfiguration {\n        CORSConfiguration(\n            allowedOrigins: [\"*\"],\n            allowedMethods: [.get, .post, .put, .patch, .delete, .options],\n            allowedHeaders: [\"*\"],\n            exposedHeaders: [],\n            allowCredentials: false,  // Cannot use credentials with wildcard origin\n            maxAge: 3600\n        )\n    }\n}\n\n// ✅ Correct — production usage with explicit origins\nlet corsConfig = CORSConfiguration.production(allowedOrigins: [\n    \"https://app.example.com\",\n    \"https://admin.example.com\"\n])\nrouter.add(middleware: CORSMiddleware(config: corsConfig))\n\n// ✅ Correct — development usage (localhost only)\n#if DEBUG\nlet corsConfig = CORSConfiguration.development\nrouter.add(middleware: CORSMiddleware(config: corsConfig))\n#endif\n\n// ❌ CRITICAL SECURITY ISSUE — wildcard origin with credentials\nlet badConfig = CORSConfiguration(\n    allowedOrigins: [\"*\"],\n    allowedMethods: [.get, .post],\n    allowedHeaders: [\"*\"],\n    exposedHeaders: [],\n    allowCredentials: true,  // ⚠️ SECURITY VULNERABILITY!\n    maxAge: 3600\n)\n// This allows ANY website to make authenticated requests to your API!\n\n// ❌ Wrong — no origin validation\nstruct BadCORSMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var response = try await next(request, context)\n        \n        // ⚠️ Reflects any origin without validation!\n        if let origin = request.headers[HTTPField.Name(\"origin\")!] {\n            response.headers[HTTPField.Name(\"access-control-allow-origin\")!] = origin\n            response.headers[HTTPField.Name(\"access-control-allow-credentials\")!] = \"true\"\n        }\n        \n        return response\n    }\n}\n\n// ❌ Wrong — hardcoded CORS headers in every handler\nrouter.get(\"/api/data\") { request, context in\n    var response = Response(status: .ok, body: .init(string: \"data\"))\n    response.headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n    return response\n}\n\n// ❌ Wrong — missing preflight handling\nstruct IncompleteCORSMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var response = try await next(request, context)\n        response.headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n        return response\n        // ⚠️ No preflight OPTIONS handling — CORS will fail for many requests!\n    }\n}\n```\n\nKey points:\n- CORS middleware must handle both preflight OPTIONS requests and actual requests\n- Preflight responses return 204 No Content with CORS headers\n- Actual responses get CORS headers added before returning\n- Never use wildcard (`*`) origin with `allowCredentials: true` — major security risk\n- Always validate Origin header against an allowlist in production\n- Include `Access-Control-Max-Age` to cache preflight responses (reduces OPTIONS traffic)\n- Use `Access-Control-Expose-Headers` to allow JavaScript access to response headers\n- Order matters: add CORS middleware early in the chain (after error middleware)\n- For APIs serving public data, wildcard origin is acceptable (without credentials)\n- For APIs with authentication, use explicit origin allowlist\n\nCommon mistakes:\n- Reflecting any origin without validation (security vulnerability)\n- Using wildcard origin with credentials enabled (forbidden by CORS spec)\n- Missing preflight OPTIONS handling (causes CORS failures)\n- Hardcoding CORS headers in route handlers (duplication)\n- Not including necessary headers in allowedHeaders (causes preflight rejection)\n- Setting overly permissive CORS in production (use explicit allowlist)\n\nSecurity considerations:\n- CORS is a browser security feature — it does not prevent direct API calls (use authentication)\n- Validate origins against allowlist, never reflect request origin blindly\n- Use HTTPS for all CORS-enabled endpoints (prevent MITM attacks)\n- Keep allowedOrigins as restrictive as possible\n- Review CORS configuration regularly as part of security audits\n- Monitor for unauthorized cross-origin requests",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "cors", "security", "preflight-handling"],
    "violationIds": ["wildcard-origin-with-credentials", "missing-origin-validation", "missing-preflight-handling", "cors-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "postgresnio-integration",
    "title": "PostgresNIO Database Integration Pattern",
    "content": "PostgresNIO is the official SSWG database driver for PostgreSQL with lowest overhead and full async/await support. Always use parameterized queries, properly size connection pools, implement the repository pattern for data access, and handle errors appropriately.\n\n```swift\nimport PostgresNIO\nimport Logging\nimport NIOCore\n\n// ✅ Correct — connection pool setup with proper sizing\nstruct DatabaseConfiguration: Sendable {\n    let host: String\n    let port: Int\n    let username: String\n    let password: String\n    let database: String\n    let maxConnections: Int\n    \n    static func fromEnvironment() throws -> DatabaseConfiguration {\n        guard let host = ProcessInfo.processInfo.environment[\"DB_HOST\"],\n              let username = ProcessInfo.processInfo.environment[\"DB_USER\"],\n              let password = ProcessInfo.processInfo.environment[\"DB_PASSWORD\"],\n              let database = ProcessInfo.processInfo.environment[\"DB_NAME\"] else {\n            throw AppError.configurationError(reason: \"Missing database environment variables\")\n        }\n        \n        let port = Int(ProcessInfo.processInfo.environment[\"DB_PORT\"] ?? \"5432\") ?? 5432\n        \n        // Rule of thumb: (num_cpu_cores × 2) + num_spindle_disks\n        // For cloud databases, check max_connections limit\n        let cpuCount = System.coreCount\n        let maxConnections = (cpuCount * 2) + 1\n        \n        return DatabaseConfiguration(\n            host: host,\n            port: port,\n            username: username,\n            password: password,\n            database: database,\n            maxConnections: min(maxConnections, 20) // Leave headroom for other services\n        )\n    }\n}\n\nfunc createPostgresPool(\n    config: DatabaseConfiguration,\n    eventLoopGroup: EventLoopGroup,\n    logger: Logger\n) -> PostgresClient {\n    let postgresConfig = PostgresClient.Configuration(\n        host: config.host,\n        port: config.port,\n        username: config.username,\n        password: config.password,\n        database: config.database,\n        tls: .prefer(try! .makeClientConfiguration()) // Use TLS in production\n    )\n    \n    return PostgresClient(\n        configuration: postgresConfig,\n        eventLoopGroupProvider: .shared(eventLoopGroup),\n        backgroundLogger: logger\n    )\n}\n\n// ✅ Correct — parameterized queries with \\(variable) interpolation\nstruct PostgresUserRepository: UserRepositoryProtocol {\n    let pool: PostgresClient\n    let logger: Logger\n    \n    func find(id: UUID) async throws -> User? {\n        // The \\(id) interpolation creates a BIND PARAMETER, not string substitution\n        let rows = try await pool.query(\n            \"SELECT id, email, name, created_at FROM users WHERE id = \\(id)\",\n            logger: logger\n        )\n        \n        // Decode first row\n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            return User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            )\n        }\n        \n        return nil\n    }\n    \n    func findAll(limit: Int, offset: Int) async throws -> [User] {\n        // Multiple parameters — all type-safe and SQL-injection proof\n        let rows = try await pool.query(\n            \"SELECT id, email, name, created_at FROM users ORDER BY created_at DESC LIMIT \\(limit) OFFSET \\(offset)\",\n            logger: logger\n        )\n        \n        var users: [User] = []\n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            users.append(User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            ))\n        }\n        \n        return users\n    }\n    \n    func insert(_ user: User) async throws -> User {\n        let rows = try await pool.query(\n            \"\"\"\n            INSERT INTO users (id, email, name, created_at)\n            VALUES (\\(user.id), \\(user.email), \\(user.name), \\(user.createdAt))\n            RETURNING id, email, name, created_at\n            \"\"\",\n            logger: logger\n        )\n        \n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            return User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            )\n        }\n        \n        throw AppError.internalError(reason: \"Failed to insert user\")\n    }\n    \n    func update(_ user: User) async throws -> User {\n        let rows = try await pool.query(\n            \"\"\"\n            UPDATE users\n            SET email = \\(user.email), name = \\(user.name)\n            WHERE id = \\(user.id)\n            RETURNING id, email, name, created_at\n            \"\"\",\n            logger: logger\n        )\n        \n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            return User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            )\n        }\n        \n        throw AppError.notFound(reason: \"User not found\")\n    }\n    \n    func delete(id: UUID) async throws {\n        _ = try await pool.query(\n            \"DELETE FROM users WHERE id = \\(id)\",\n            logger: logger\n        )\n    }\n    \n    // Complex query with multiple conditions\n    func search(query: String, isActive: Bool) async throws -> [User] {\n        let searchPattern = \"%\\(query)%\"\n        let rows = try await pool.query(\n            \"\"\"\n            SELECT id, email, name, created_at\n            FROM users\n            WHERE (email ILIKE \\(searchPattern) OR name ILIKE \\(searchPattern))\n              AND is_active = \\(isActive)\n            ORDER BY created_at DESC\n            \"\"\",\n            logger: logger\n        )\n        \n        var users: [User] = []\n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            users.append(User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            ))\n        }\n        \n        return users\n    }\n}\n\n// ✅ Correct — repository protocol for testability\nprotocol UserRepositoryProtocol: Sendable {\n    func find(id: UUID) async throws -> User?\n    func findAll(limit: Int, offset: Int) async throws -> [User]\n    func insert(_ user: User) async throws -> User\n    func update(_ user: User) async throws -> User\n    func delete(id: UUID) async throws\n    func search(query: String, isActive: Bool) async throws -> [User]\n}\n\n// ✅ Correct — error wrapping at repository boundary\nstruct PostgresUserRepositoryWithErrorWrapping: UserRepositoryProtocol {\n    let pool: PostgresClient\n    let logger: Logger\n    \n    func find(id: UUID) async throws -> User? {\n        do {\n            let rows = try await pool.query(\n                \"SELECT id, email, name, created_at FROM users WHERE id = \\(id)\",\n                logger: logger\n            )\n            \n            for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n                return User(id: id, email: email, name: name, createdAt: createdAt)\n            }\n            \n            return nil\n        } catch let error as PostgresError {\n            // Wrap database errors at the boundary\n            logger.error(\"Database error in find\", metadata: [\n                \"error\": \"\\(error)\",\n                \"userId\": \"\\(id)\"\n            ])\n            throw AppError.internalError(reason: \"Database query failed\")\n        }\n    }\n    \n    // ... other methods with similar error wrapping\n}\n\n// ✅ Correct — transaction support\nextension PostgresUserRepository {\n    func createUserWithProfile(\n        user: User,\n        profile: UserProfile\n    ) async throws -> (User, UserProfile) {\n        // Use withConnection for transactions\n        return try await pool.withConnection { connection in\n            // Begin transaction\n            try await connection.query(\"BEGIN\", logger: logger)\n            \n            do {\n                // Insert user\n                let userRows = try await connection.query(\n                    \"INSERT INTO users (id, email, name, created_at) VALUES (\\(user.id), \\(user.email), \\(user.name), \\(user.createdAt)) RETURNING id, email, name, created_at\",\n                    logger: logger\n                )\n                \n                var insertedUser: User? = nil\n                for try await (id, email, name, createdAt) in userRows.decode((UUID, String, String, Date).self) {\n                    insertedUser = User(id: id, email: email, name: name, createdAt: createdAt)\n                    break\n                }\n                \n                guard let user = insertedUser else {\n                    throw AppError.internalError(reason: \"Failed to insert user\")\n                }\n                \n                // Insert profile\n                let profileRows = try await connection.query(\n                    \"INSERT INTO user_profiles (user_id, bio, avatar_url) VALUES (\\(user.id), \\(profile.bio), \\(profile.avatarUrl)) RETURNING user_id, bio, avatar_url\",\n                    logger: logger\n                )\n                \n                var insertedProfile: UserProfile? = nil\n                for try await (userId, bio, avatarUrl) in profileRows.decode((UUID, String, String?).self) {\n                    insertedProfile = UserProfile(userId: userId, bio: bio, avatarUrl: avatarUrl)\n                    break\n                }\n                \n                guard let profile = insertedProfile else {\n                    throw AppError.internalError(reason: \"Failed to insert profile\")\n                }\n                \n                // Commit transaction\n                try await connection.query(\"COMMIT\", logger: logger)\n                \n                return (user, profile)\n            } catch {\n                // Rollback on error\n                try await connection.query(\"ROLLBACK\", logger: logger)\n                throw error\n            }\n        }\n    }\n}\n\n// ❌ CRITICAL SECURITY VULNERABILITY — string concatenation instead of parameterization\nfunc findUserByEmailUNSAFE(email: String) async throws -> User? {\n    // ⚠️ SQL INJECTION VULNERABILITY!\n    // If email = \"' OR '1'='1\", this returns all users!\n    let query = \"SELECT * FROM users WHERE email = '\\(email)'\"\n    let rows = try await pool.query(query, logger: logger)\n    // ...\n}\n\n// ❌ Wrong — using string interpolation instead of PostgresNIO's bind interpolation\nfunc findUserWrong(id: UUID) async throws -> User? {\n    // This looks like parameterization but it's NOT!\n    // Must use pool.query() with \\(variable) inside the query string\n    let query = \"SELECT * FROM users WHERE id = '\\(id.uuidString)'\"\n    let rows = try await pool.query(query, logger: logger)\n    // ...\n}\n\n// ❌ Wrong — excessive connection pool size\nlet badConfig = DatabaseConfiguration(\n    host: \"localhost\",\n    port: 5432,\n    username: \"user\",\n    password: \"pass\",\n    database: \"mydb\",\n    maxConnections: 200 // ⚠️ Will exhaust database max_connections!\n)\n// PostgreSQL default max_connections is 100 — running multiple app instances\n// will hit the limit and cause connection failures\n\n// ❌ Wrong — not using connection pool (creating new connection per query)\nfunc findUserNonPooled(id: UUID) async throws -> User? {\n    let connection = try await PostgresConnection.connect(\n        configuration: .init(\n            host: \"localhost\",\n            port: 5432,\n            username: \"user\",\n            password: \"pass\",\n            database: \"mydb\"\n        ),\n        id: 1,\n        logger: logger\n    )\n    defer { try? await connection.close() }\n    \n    let rows = try await connection.query(\n        \"SELECT id, email, name, created_at FROM users WHERE id = \\(id)\",\n        logger: logger\n    )\n    // ... ⚠️ Connection overhead on every query!\n}\n\n// ❌ Wrong — blocking decode pattern\nfunc findAllUsersBlocking() async throws -> [User] {\n    let rows = try await pool.query(\n        \"SELECT id, email, name, created_at FROM users\",\n        logger: logger\n    )\n    \n    // ⚠️ collect() buffers all rows in memory!\n    let allRows = try await rows.collect()\n    \n    return try allRows.map { row in\n        try row.decode((UUID, String, String, Date).self)\n    }.map { (id, email, name, createdAt) in\n        User(id: id, email: email, name: name, createdAt: createdAt)\n    }\n}\n\n// ✅ Correct — streaming decode pattern (memory efficient)\nfunc findAllUsersStreaming() async throws -> [User] {\n    let rows = try await pool.query(\n        \"SELECT id, email, name, created_at FROM users\",\n        logger: logger\n    )\n    \n    var users: [User] = []\n    // Process rows as they arrive — memory efficient\n    for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n        users.append(User(id: id, email: email, name: name, createdAt: createdAt))\n    }\n    \n    return users\n}\n\n// ❌ Wrong — repository in route handler (not via dependencies)\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\", as: UUID.self)\n    \n    // ⚠️ Direct repository construction in handler!\n    let repo = PostgresUserRepository(pool: globalPool, logger: context.logger)\n    let user = try await repo.find(id: id)\n    \n    guard let user = user else {\n        throw HTTPError(.notFound)\n    }\n    \n    return UserResponse(user)\n}\n\n// ✅ Correct — repository via dependencies\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\", as: UUID.self)\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user)\n}\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n    \n    func find(id: UUID) async throws -> User {\n        guard let user = try await repository.find(id: id) else {\n            throw AppError.notFound(reason: \"User not found\")\n        }\n        return user\n    }\n}\n```\n\nKey points:\n- PostgresNIO's `\\(variable)` interpolation creates bind parameters (NOT string substitution)\n- Never build queries with string concatenation — always use parameterized queries\n- Connection pool sizing: `(num_cpu_cores × 2) + num_spindle_disks`\n- Watch PostgreSQL's `max_connections` limit (default 100)\n- Use PgBouncer or connection pooler in production\n- Always use the repository pattern — never call PostgresNIO directly from handlers\n- Decode rows with `for try await` for memory efficiency (don't use `.collect()`)\n- Wrap database errors at repository boundary into `AppError`\n- Use transactions with `withConnection` for multi-statement operations\n- Always use connection pooling (PostgresClient), never create connections per-query\n- Include logger in all queries for observability\n- Use TLS/SSL for production database connections\n\nCommon pitfalls:\n- String concatenation instead of parameterization (SQL injection vulnerability)\n- Excessive pool size exhausting `max_connections`\n- Creating connections per-query instead of using pool (performance issue)\n- Buffering all rows with `.collect()` (memory issue for large result sets)\n- Not wrapping database errors (leaks implementation details)\n- Direct database calls in handlers (violates clean architecture)\n- Missing transaction rollback on errors (data corruption risk)",
    "layer": "repository",
    "patternIds": ["database-integration", "repository-pattern", "parameterized-queries", "connection-pooling", "async-queries"],
    "violationIds": ["sql-injection", "string-concatenation-in-query", "excessive-pool-size", "missing-connection-pool", "repository-in-handler", "blocking-decode-pattern"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "bearer-token-auth-middleware",
    "title": "Bearer Token Authentication Middleware",
    "content": "Authentication via bearer token is implemented as RouterMiddleware that validates the Authorization header before passing requests to downstream handlers. Infrastructure endpoints like /health and /ready must always be exempt so that load balancers and orchestrators can probe without credentials.\n\n```swift\nimport Hummingbird\nimport Logging\n\n// ✅ Correct — Bearer token middleware with exempt paths\nstruct AuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    private let token: String\n\n    init(token: String) {\n        self.token = token\n    }\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Always exempt infrastructure endpoints\n        let path = request.uri.path\n        guard path != \"/health\", path != \"/ready\" else {\n            return try await next(request, context)\n        }\n\n        guard\n            let header = request.headers[.authorization],\n            header.hasPrefix(\"Bearer \"),\n            String(header.dropFirst(7)) == token\n        else {\n            context.logger.warning(\n                \"Rejected unauthenticated request\",\n                metadata: [\"path\": \"\\(path)\", \"method\": \"\\(request.method)\"]\n            )\n            throw HTTPError(\n                .unauthorized,\n                message: \"Valid Bearer token required. Set Authorization: Bearer <token>\"\n            )\n        }\n\n        return try await next(request, context)\n    }\n}\n\n// ✅ Correct — conditional middleware registration\nfunc buildRouter(dependencies: AppDependencies) -> Router<AppRequestContext> {\n    let router = Router(context: AppRequestContext.self)\n    \n    // Add DI middleware first\n    router.add(middleware: DependencyInjectionMiddleware(dependencies: dependencies))\n    \n    // Only add auth middleware if MCP_AUTH_TOKEN is set\n    if let token = ProcessInfo.processInfo.environment[\"MCP_AUTH_TOKEN\"], !token.isEmpty {\n        router.add(middleware: AuthMiddleware(token: token))\n    }\n    \n    // Register routes\n    router.get(\"/health\") { _, _ in Response(status: .ok) }\n    router.get(\"/ready\") { _, _ in Response(status: .ok) }\n    router.post(\"/mcp\") { request, context in\n        // This endpoint requires auth when MCP_AUTH_TOKEN is set\n        try await context.dependencies.mcpService.handle(request)\n    }\n    \n    return router\n}\n\n// ❌ Wrong — hardcoded token in source\nstruct BadAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    let token = \"super-secret-token\" // ⚠️ SECURITY BREACH!\n    \n    func handle(...) async throws -> Response {\n        guard request.headers[.authorization] == \"Bearer \\(token)\" else {\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// ❌ Wrong — missing exempt paths (breaks load balancer health checks)\nstruct OverlyStrictAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n    \n    func handle(...) async throws -> Response {\n        // ⚠️ No exempt paths — /health and /ready require auth!\n        guard request.headers[.authorization] == \"Bearer \\(token)\" else {\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// ❌ Wrong — silent failure (no logging)\nstruct SilentAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n    \n    func handle(...) async throws -> Response {\n        guard request.headers[.authorization] == \"Bearer \\(token)\" else {\n            // ⚠️ No logging — impossible to debug failed auth attempts!\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// ❌ Wrong — incorrect header parsing\nstruct BrokenHeaderParsingMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n    \n    func handle(...) async throws -> Response {\n        // ⚠️ Doesn't check \"Bearer \" prefix!\n        let header = request.headers[.authorization] ?? \"\"\n        guard header == token else { // Should be \"Bearer <token>\"\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n```\n\nKey requirements:\n- Always exempt /health and /ready for infrastructure probes\n- Load token from environment variable, never hardcode\n- Log all rejected requests with path and method for security auditing\n- Verify \"Bearer \" prefix and extract token correctly\n- Return descriptive error message for debugging\n- Only add middleware when auth token is configured (zero overhead for local dev)\n- Middleware ordering: DI middleware must come before auth middleware",
    "layer": "middleware",
    "patternIds": ["bearer-token-auth", "auth-middleware", "conditional-middleware", "exempt-paths"],
    "violationIds": ["hardcoded-auth-token", "missing-health-check-exemption", "missing-auth-logging", "incorrect-bearer-parsing"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "jwt-authentication-pattern",
    "title": "JWT Authentication and Validation",
    "content": "JSON Web Tokens (JWT) provide stateless authentication. Use a JWT library (JWTKit or swift-jwt) to verify signatures, validate claims (exp, iat, iss, aud), and extract user identity. Never trust JWT payloads without signature verification.\n\n```swift\nimport Hummingbird\nimport JWTKit\nimport Foundation\n\n// ✅ Correct — JWT validation middleware with claim verification\nstruct JWTAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    private let signers: JWTSigners\n    \n    init(signers: JWTSigners) {\n        self.signers = signers\n    }\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Exempt infrastructure endpoints\n        let path = request.uri.path\n        guard path != \"/health\", path != \"/ready\" else {\n            return try await next(request, context)\n        }\n        \n        // Extract Bearer token\n        guard let header = request.headers[.authorization],\n              header.hasPrefix(\"Bearer \"),\n              !header.isEmpty else {\n            context.logger.warning(\"Missing or malformed Authorization header\")\n            throw HTTPError(.unauthorized, message: \"JWT token required\")\n        }\n        \n        let token = String(header.dropFirst(7))\n        \n        do {\n            // Verify signature and decode claims\n            let payload = try signers.verify(token, as: JWTPayload.self)\n            \n            // Validate expiration\n            guard payload.exp.value > Date() else {\n                context.logger.warning(\"Expired JWT token\", metadata: [\"sub\": \"\\(payload.sub.value)\"])\n                throw HTTPError(.unauthorized, message: \"Token expired\")\n            }\n            \n            // Inject user context\n            var ctx = context\n            ctx.userID = payload.sub.value\n            ctx.userEmail = payload.email\n            \n            context.logger.info(\n                \"Authenticated request\",\n                metadata: [\"userId\": \"\\(payload.sub.value)\", \"path\": \"\\(path)\"]\n            )\n            \n            return try await next(request, ctx)\n        } catch let jwtError as JWTError {\n            context.logger.warning(\"JWT validation failed\", metadata: [\"error\": \"\\(jwtError)\"])\n            throw HTTPError(.unauthorized, message: \"Invalid token\")\n        }\n    }\n}\n\n// JWT payload structure\nstruct JWTPayload: JWTPayload {\n    let sub: SubjectClaim  // User ID\n    let email: String\n    let exp: ExpirationClaim\n    let iat: IssuedAtClaim\n    let iss: IssuerClaim\n    \n    func verify(using signer: JWTSigner) throws {\n        // Verify expiration\n        try exp.verifyNotExpired()\n    }\n}\n\n// ✅ Correct — JWT signing for token generation\nstruct AuthService {\n    let signers: JWTSigners\n    let issuer: String\n    let tokenLifetime: TimeInterval\n    \n    func generateToken(for user: User) throws -> String {\n        let payload = JWTPayload(\n            sub: SubjectClaim(value: user.id.uuidString),\n            email: user.email,\n            exp: ExpirationClaim(value: Date().addingTimeInterval(tokenLifetime)),\n            iat: IssuedAtClaim(value: Date()),\n            iss: IssuerClaim(value: issuer)\n        )\n        \n        return try signers.sign(payload)\n    }\n}\n\n// ✅ Correct — JWT configuration from environment\nstruct JWTConfiguration: Sendable {\n    let secret: String\n    let issuer: String\n    let tokenLifetime: TimeInterval\n    \n    static func fromEnvironment() throws -> JWTConfiguration {\n        guard let secret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"],\n              !secret.isEmpty else {\n            throw AppError.configurationError(reason: \"JWT_SECRET not set\")\n        }\n        \n        guard secret.count >= 32 else {\n            throw AppError.configurationError(reason: \"JWT_SECRET must be at least 32 characters\")\n        }\n        \n        let issuer = ProcessInfo.processInfo.environment[\"JWT_ISSUER\"] ?? \"hummingbird-app\"\n        let lifetime = TimeInterval(ProcessInfo.processInfo.environment[\"JWT_LIFETIME\"] ?? \"3600\") ?? 3600\n        \n        return JWTConfiguration(\n            secret: secret,\n            issuer: issuer,\n            tokenLifetime: lifetime\n        )\n    }\n    \n    func createSigners() throws -> JWTSigners {\n        let signers = JWTSigners()\n        try signers.use(.hs256(key: secret))\n        return signers\n    }\n}\n\n// ❌ CRITICAL VULNERABILITY — no signature verification\nfunc decodeJWTUnsafe(token: String) throws -> JWTPayload {\n    // ⚠️ Decodes JWT without verifying signature!\n    // Attacker can forge any payload and it will be trusted!\n    let parts = token.split(separator: \".\")\n    guard parts.count == 3 else {\n        throw AppError.invalidInput(reason: \"Malformed JWT\")\n    }\n    \n    let payloadData = Data(base64Encoded: String(parts[1])) ?? Data()\n    return try JSONDecoder().decode(JWTPayload.self, from: payloadData)\n}\n\n// ❌ Wrong — weak secret\nlet weakJWTConfig = JWTConfiguration(\n    secret: \"secret123\", // ⚠️ Too short and predictable!\n    issuer: \"app\",\n    tokenLifetime: 3600\n)\n\n// ❌ Wrong — no expiration validation\nstruct NoExpirationCheckMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let signers: JWTSigners\n    \n    func handle(...) async throws -> Response {\n        let token = extractToken(from: request)\n        let payload = try signers.verify(token, as: JWTPayload.self)\n        \n        // ⚠️ No exp claim validation — tokens never expire!\n        var ctx = context\n        ctx.userID = payload.sub.value\n        return try await next(request, ctx)\n    }\n}\n\n// ❌ Wrong — excessive token lifetime\nlet badConfig = JWTConfiguration(\n    secret: \"properly-long-secret-key-12345\",\n    issuer: \"app\",\n    tokenLifetime: 86400 * 365 // ⚠️ 1 year! If compromised, valid for a year!\n)\n\n// ❌ Wrong — missing issuer/audience validation\nstruct MissingClaimValidationMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let signers: JWTSigners\n    \n    func handle(...) async throws -> Response {\n        let token = extractToken(from: request)\n        let payload = try signers.verify(token, as: JWTPayload.self)\n        \n        // ⚠️ No iss/aud validation — accepts tokens from any issuer!\n        try payload.exp.verifyNotExpired()\n        \n        var ctx = context\n        ctx.userID = payload.sub.value\n        return try await next(request, ctx)\n    }\n}\n```\n\nKey requirements:\n- Always verify JWT signature before trusting payload\n- Validate exp (expiration), iat (issued at), iss (issuer), aud (audience) claims\n- Use strong secrets (minimum 32 characters, cryptographically random)\n- Set reasonable token lifetime (1 hour is typical, never more than 24 hours)\n- Log all authentication events (success and failure) with user ID\n- Inject authenticated user context for downstream handlers\n- Use HMAC-SHA256 (HS256) for symmetric keys or RSA (RS256) for asymmetric\n- Store JWT secret in environment variable, never hardcode\n- Implement token refresh mechanism for long-lived sessions\n\nCommon vulnerabilities:\n- Decoding JWT without signature verification (critical security breach)\n- Weak or short secrets (enables brute force attacks)\n- No expiration validation (tokens never expire)\n- Missing issuer/audience validation (accepts forged tokens)\n- Excessive token lifetime (increases compromise window)\n- Hardcoded secrets in source code",
    "layer": "middleware",
    "patternIds": ["jwt-auth", "stateless-auth", "token-validation", "claims-verification"],
    "violationIds": ["jwt-no-signature-verification", "jwt-weak-secret", "jwt-no-expiration-check", "jwt-excessive-lifetime", "jwt-missing-claim-validation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "session-based-authentication",
    "title": "Session-Based Authentication with Stateful Sessions",
    "content": "Session-based authentication stores session state server-side (in memory, Redis, or database) and uses a session ID cookie to identify users. Sessions are stateful but can be invalidated immediately and support complex session data beyond what fits in a JWT.\n\n```swift\nimport Hummingbird\nimport Foundation\n\n// ✅ Correct — session store with actor protection\nactor SessionStore {\n    private var sessions: [String: Session] = [:]\n    private let sessionLifetime: TimeInterval\n    \n    init(sessionLifetime: TimeInterval = 3600) {\n        self.sessionLifetime = sessionLifetime\n    }\n    \n    func create(userID: UUID) -> Session {\n        let session = Session(\n            id: UUID().uuidString,\n            userID: userID,\n            createdAt: Date(),\n            expiresAt: Date().addingTimeInterval(sessionLifetime)\n        )\n        sessions[session.id] = session\n        return session\n    }\n    \n    func get(id: String) -> Session? {\n        guard let session = sessions[id] else {\n            return nil\n        }\n        \n        // Check expiration\n        guard session.expiresAt > Date() else {\n            sessions.removeValue(forKey: id)\n            return nil\n        }\n        \n        return session\n    }\n    \n    func delete(id: String) {\n        sessions.removeValue(forKey: id)\n    }\n    \n    func extend(id: String) {\n        guard var session = sessions[id] else { return }\n        session.expiresAt = Date().addingTimeInterval(sessionLifetime)\n        sessions[id] = session\n    }\n    \n    func cleanup() {\n        let now = Date()\n        sessions = sessions.filter { $0.value.expiresAt > now }\n    }\n}\n\nstruct Session: Sendable {\n    let id: String\n    let userID: UUID\n    let createdAt: Date\n    var expiresAt: Date\n}\n\n// ✅ Correct — session authentication middleware\nstruct SessionAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    private let sessionStore: SessionStore\n    \n    init(sessionStore: SessionStore) {\n        self.sessionStore = sessionStore\n    }\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Exempt infrastructure and auth endpoints\n        let path = request.uri.path\n        guard path != \"/health\",\n              path != \"/ready\",\n              path != \"/login\",\n              path != \"/register\" else {\n            return try await next(request, context)\n        }\n        \n        // Extract session ID from cookie\n        guard let sessionID = request.cookies[\"session_id\"]?.value else {\n            context.logger.warning(\"No session cookie\", metadata: [\"path\": \"\\(path)\"])\n            throw HTTPError(.unauthorized, message: \"Authentication required\")\n        }\n        \n        // Validate session\n        guard let session = await sessionStore.get(id: sessionID) else {\n            context.logger.warning(\n                \"Invalid or expired session\",\n                metadata: [\"sessionId\": \"\\(sessionID)\", \"path\": \"\\(path)\"]\n            )\n            throw HTTPError(.unauthorized, message: \"Session expired\")\n        }\n        \n        // Extend session on activity\n        await sessionStore.extend(id: sessionID)\n        \n        // Inject user context\n        var ctx = context\n        ctx.userID = session.userID.uuidString\n        ctx.sessionID = session.id\n        \n        context.logger.info(\n            \"Authenticated request\",\n            metadata: [\"userId\": \"\\(session.userID)\", \"path\": \"\\(path)\"]\n        )\n        \n        return try await next(request, ctx)\n    }\n}\n\n// ✅ Correct — login handler that creates session\nrouter.post(\"/login\") { request, context in\n    struct LoginRequest: Decodable {\n        let email: String\n        let password: String\n    }\n    \n    let req = try await request.decode(as: LoginRequest.self, context: context)\n    \n    // Validate credentials\n    let user = try await context.dependencies.authService.authenticate(\n        email: req.email,\n        password: req.password\n    )\n    \n    // Create session\n    let session = await context.dependencies.sessionStore.create(userID: user.id)\n    \n    // Set secure cookie\n    var response = Response(status: .ok)\n    response.setCookie(\n        .init(\n            name: \"session_id\",\n            value: session.id,\n            path: \"/\",\n            expires: session.expiresAt,\n            maxAge: 3600,\n            httpOnly: true,\n            secure: true, // HTTPS only\n            sameSite: .strict\n        )\n    )\n    \n    return response\n}\n\n// ✅ Correct — logout handler that destroys session\nrouter.post(\"/logout\") { request, context in\n    guard let sessionID = request.cookies[\"session_id\"]?.value else {\n        return Response(status: .ok)\n    }\n    \n    await context.dependencies.sessionStore.delete(id: sessionID)\n    \n    // Clear cookie\n    var response = Response(status: .ok)\n    response.setCookie(\n        .init(\n            name: \"session_id\",\n            value: \"\",\n            path: \"/\",\n            expires: Date(timeIntervalSince1970: 0),\n            maxAge: 0\n        )\n    )\n    \n    return response\n}\n\n// ✅ Correct — background service for session cleanup\nstruct SessionCleanupService: Service {\n    let sessionStore: SessionStore\n    let interval: Duration\n    let logger: Logger\n    \n    func run() async throws {\n        while !Task.isCancelled {\n            try await Task.sleep(for: interval)\n            \n            await sessionStore.cleanup()\n            logger.debug(\"Session cleanup completed\")\n        }\n    }\n}\n\n// ❌ Wrong — sessions without actor protection (data race)\nvar sessions: [String: Session] = [:] // ⚠️ Shared mutable state!\n\nstruct UnsafeSessionMiddleware: RouterMiddleware {\n    func handle(...) async throws -> Response {\n        let session = sessions[sessionID] // ⚠️ Data race in Swift 6!\n        ...\n    }\n}\n\n// ❌ Wrong — insecure cookie (missing httpOnly, secure flags)\nrouter.post(\"/login\") { request, context in\n    let session = await sessionStore.create(userID: user.id)\n    \n    var response = Response(status: .ok)\n    response.setCookie(\n        .init(\n            name: \"session_id\",\n            value: session.id\n            // ⚠️ Missing httpOnly: true — vulnerable to XSS!\n            // ⚠️ Missing secure: true — transmitted over HTTP!\n            // ⚠️ Missing sameSite: .strict — vulnerable to CSRF!\n        )\n    )\n    \n    return response\n}\n\n// ❌ Wrong — predictable session IDs\nfunc createSessionWithWeakID(userID: UUID) -> Session {\n    let sessionID = \"\\(userID)_\\(Date().timeIntervalSince1970)\" // ⚠️ Predictable!\n    // Attacker can guess session IDs and hijack sessions\n    return Session(id: sessionID, userID: userID, createdAt: Date(), expiresAt: Date().addingTimeInterval(3600))\n}\n\n// ❌ Wrong — no session expiration\nactor NoExpirationSessionStore {\n    private var sessions: [String: Session] = [:]\n    \n    func get(id: String) -> Session? {\n        return sessions[id] // ⚠️ No expiration check — sessions live forever!\n    }\n}\n\n// ❌ Wrong — no session extension on activity (poor UX)\nstruct NoExtensionMiddleware: RouterMiddleware {\n    func handle(...) async throws -> Response {\n        let session = await sessionStore.get(id: sessionID)\n        // ⚠️ No session extension — user gets logged out mid-activity!\n        return try await next(request, context)\n    }\n}\n```\n\nKey requirements:\n- Protect session store with actor for thread safety\n- Use cryptographically random session IDs (UUID is sufficient)\n- Set secure cookie flags: httpOnly, secure, sameSite: .strict\n- Implement session expiration and cleanup\n- Extend session lifetime on user activity (sliding expiration)\n- Provide immediate logout/invalidation capability\n- Log authentication events\n- Exempt login/register endpoints from auth requirement\n- Use HTTPS in production (secure: true cookie flag)\n\nSession store backends:\n- In-memory (development, single instance)\n- Redis (production, distributed)\n- Database (production, persistent)\n\nCommon vulnerabilities:\n- Shared mutable state without actor protection (data races)\n- Insecure cookies (missing httpOnly, secure, sameSite flags)\n- Predictable session IDs (enables session hijacking)\n- No session expiration (sessions never expire)\n- No cleanup mechanism (memory leak)\n- Transmitting session IDs over HTTP (secure: false)",
    "layer": "middleware",
    "patternIds": ["session-auth", "stateful-auth", "cookie-based-auth", "session-management"],
    "violationIds": ["session-without-actor", "insecure-session-cookie", "predictable-session-id", "no-session-expiration", "missing-session-cleanup"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "user-context-injection",
    "title": "Authenticated User Context Injection",
    "content": "After successful authentication, middleware must inject user identity and metadata into AppRequestContext so that downstream handlers and services can access authenticated user information without re-parsing tokens or sessions.\n\n```swift\nimport Hummingbird\nimport Foundation\n\n// ✅ Correct — AppRequestContext with optional user fields\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies\n    \n    // User context fields (populated by auth middleware)\n    var userID: String?\n    var userEmail: String?\n    var userRoles: Set<String>?\n    var sessionID: String?\n    \n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        self.dependencies = AppDependencies.placeholder\n        self.userID = nil\n        self.userEmail = nil\n        self.userRoles = nil\n        self.sessionID = nil\n    }\n}\n\n// ✅ Correct — authentication middleware injects user context\nstruct JWTAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let signers: JWTSigners\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        let path = request.uri.path\n        guard path != \"/health\", path != \"/ready\" else {\n            return try await next(request, context)\n        }\n        \n        let token = try extractBearerToken(from: request)\n        let payload = try signers.verify(token, as: JWTPayload.self)\n        try payload.exp.verifyNotExpired()\n        \n        // Inject user context\n        var ctx = context\n        ctx.userID = payload.sub.value\n        ctx.userEmail = payload.email\n        ctx.userRoles = Set(payload.roles ?? [])\n        \n        context.logger.info(\n            \"User authenticated\",\n            metadata: [\n                \"userId\": \"\\(payload.sub.value)\",\n                \"email\": \"\\(payload.email)\",\n                \"path\": \"\\(path)\"\n            ]\n        )\n        \n        // Pass modified context to next handler\n        return try await next(request, ctx)\n    }\n}\n\n// ✅ Correct — handler accesses authenticated user via context\nrouter.get(\"/profile\") { request, context in\n    guard let userID = context.userID else {\n        throw HTTPError(.unauthorized, message: \"Authentication required\")\n    }\n    \n    let user = try await context.dependencies.userService.find(id: UUID(uuidString: userID)!)\n    return UserProfileResponse(user)\n}\n\n// ✅ Correct — service receives user ID as explicit parameter\nstruct PostService {\n    let repository: any PostRepositoryProtocol\n    \n    func createPost(authorID: UUID, title: String, content: String) async throws -> Post {\n        let post = Post(\n            id: UUID(),\n            authorID: authorID,\n            title: title,\n            content: content,\n            createdAt: Date()\n        )\n        \n        return try await repository.insert(post)\n    }\n    \n    func updatePost(id: UUID, authorID: UUID, title: String, content: String) async throws -> Post {\n        // Verify ownership\n        guard let post = try await repository.find(id: id),\n              post.authorID == authorID else {\n            throw AppError.forbidden(reason: \"Can only update own posts\")\n        }\n        \n        var updated = post\n        updated.title = title\n        updated.content = content\n        \n        return try await repository.update(updated)\n    }\n}\n\n// ✅ Correct — handler passes user ID to service\nrouter.post(\"/posts\") { request, context in\n    guard let userID = context.userID else {\n        throw HTTPError(.unauthorized)\n    }\n    \n    struct CreatePostRequest: Decodable {\n        let title: String\n        let content: String\n    }\n    \n    let req = try await request.decode(as: CreatePostRequest.self, context: context)\n    \n    let post = try await context.dependencies.postService.createPost(\n        authorID: UUID(uuidString: userID)!,\n        title: req.title,\n        content: req.content\n    )\n    \n    return PostResponse(post)\n}\n\n// ✅ Correct — role-based authorization helper\nextension AppRequestContext {\n    func requireRole(_ role: String) throws {\n        guard let roles = userRoles, roles.contains(role) else {\n            logger.warning(\n                \"Role check failed\",\n                metadata: [\n                    \"userId\": \"\\(userID ?? \"none\")\",\n                    \"requiredRole\": \"\\(role)\",\n                    \"userRoles\": \"\\(userRoles?.description ?? \"none\")\"\n                ]\n            )\n            throw HTTPError(.forbidden, message: \"Insufficient permissions\")\n        }\n    }\n    \n    func requireAuthentication() throws -> String {\n        guard let userID = userID else {\n            throw HTTPError(.unauthorized, message: \"Authentication required\")\n        }\n        return userID\n    }\n}\n\n// ✅ Correct — admin-only endpoint with role check\nrouter.delete(\"/users/:id\") { request, context in\n    try context.requireRole(\"admin\")\n    \n    let id = try context.parameters.require(\"id\", as: UUID.self)\n    try await context.dependencies.userService.delete(id: id)\n    \n    return Response(status: .noContent)\n}\n\n// ❌ Wrong — service takes entire AppRequestContext\nstruct BadPostService {\n    let repository: any PostRepositoryProtocol\n    \n    // ⚠️ Service depends on HTTP context — not testable!\n    func createPost(context: AppRequestContext, title: String, content: String) async throws -> Post {\n        guard let authorID = context.userID else {\n            throw AppError.unauthorized(reason: \"User not authenticated\")\n        }\n        // ...\n    }\n}\n\n// ❌ Wrong — handler re-parses JWT instead of using injected context\nrouter.get(\"/profile\") { request, context in\n    // ⚠️ Redundant JWT parsing — context.userID already available!\n    let token = try extractBearerToken(from: request)\n    let payload = try context.dependencies.jwtSigners.verify(token, as: JWTPayload.self)\n    let userID = payload.sub.value\n    \n    let user = try await context.dependencies.userService.find(id: UUID(uuidString: userID)!)\n    return UserProfileResponse(user)\n}\n\n// ❌ Wrong — missing authentication check\nrouter.post(\"/posts\") { request, context in\n    // ⚠️ No check for context.userID — allows unauthenticated requests!\n    let req = try await request.decode(as: CreatePostRequest.self, context: context)\n    \n    // ⚠️ Using empty UUID as author — data integrity issue!\n    let post = try await context.dependencies.postService.createPost(\n        authorID: UUID(),\n        title: req.title,\n        content: req.content\n    )\n    \n    return PostResponse(post)\n}\n\n// ❌ Wrong — storing user in global variable\nvar currentUser: User? // ⚠️ Shared mutable state — data race!\n\nstruct BadAuthMiddleware: RouterMiddleware {\n    func handle(...) async throws -> Response {\n        let user = try await authenticateUser(request)\n        currentUser = user // ⚠️ Concurrent requests will overwrite!\n        return try await next(request, context)\n    }\n}\n\nrouter.get(\"/profile\") { request, context in\n    guard let user = currentUser else { // ⚠️ Wrong user or nil!\n        throw HTTPError(.unauthorized)\n    }\n    return UserProfileResponse(user)\n}\n```\n\nKey requirements:\n- Add optional user fields to AppRequestContext (userID, userEmail, userRoles, sessionID)\n- Authentication middleware populates user context after successful validation\n- Pass modified context to next middleware/handler in chain\n- Handlers access user via context.userID (not by re-parsing tokens)\n- Services receive user ID as explicit parameters (not entire context)\n- Implement helper methods (requireRole, requireAuthentication) for common checks\n- Log authentication and authorization events with user ID\n- Never store authenticated user in global/shared state\n\nContext modification pattern:\n```swift\nvar ctx = context  // Copy context\nctx.userID = \"...\" // Modify copy\nreturn try await next(request, ctx) // Pass modified copy\n```\n\nCommon mistakes:\n- Service taking entire AppRequestContext (couples service to HTTP layer)\n- Re-parsing JWT in handlers (redundant, inefficient)\n- Missing authentication checks in protected endpoints\n- Storing user in global variable (data race, wrong user)\n- Not passing modified context to next handler\n- Forgetting to make context var mutable before modification",
    "layer": "context",
    "patternIds": ["user-context", "context-injection", "authentication-context", "authorization-helpers"],
    "violationIds": ["service-takes-request-context", "redundant-jwt-parsing", "missing-auth-check", "global-user-state", "immutable-context-modification"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  }
]
