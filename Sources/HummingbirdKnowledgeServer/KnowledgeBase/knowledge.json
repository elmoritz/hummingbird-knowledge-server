[
  {
    "id": "route-handler-dispatcher-only",
    "title": "Route Handlers Are Dispatchers Only",
    "content": "In Hummingbird 2.x clean architecture, route handlers have exactly one job: dispatch to the service layer and return the result. They must not contain business logic, database calls, or service construction.\n\n```swift\n// ✅ Correct — pure dispatcher\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    let user = try await context.dependencies.userService.create(dto)\n    return CreateUserResponse(user)\n}\n\n// ❌ Wrong — business logic in handler\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    guard !dto.email.isEmpty else { throw HTTPError(.badRequest) }\n    let hashed = BCrypt.hash(dto.password)\n    let user = User(email: dto.email, passwordHash: hashed)\n    try await db.save(user)\n    return user\n}\n```",
    "layer": "controller",
    "patternIds": ["dispatcher-pattern", "thin-controller"],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-layer-no-hummingbird",
    "title": "Service Layer Must Not Import Hummingbird",
    "content": "The service layer encodes business logic independently of any web framework. No Hummingbird import means the service can be tested without an HTTP context and can be reused across transports.\n\n```swift\n// ✅ Correct — pure Swift service\nimport Foundation\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n\n    func create(_ request: CreateUserRequest) async throws -> User {\n        guard !request.email.isEmpty else {\n            throw AppError.invalidInput(reason: \"Email must not be empty\")\n        }\n        return try await repository.insert(User(email: request.email))\n    }\n}\n\n// ❌ Wrong — Hummingbird leaked into service layer\nimport Hummingbird\n\nstruct UserService {\n    func create(_ req: Request) async throws -> Response { ... }\n}\n```",
    "layer": "service",
    "patternIds": ["framework-agnostic-service"],
    "violationIds": ["hummingbird-import-in-service"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dependency-injection-via-context",
    "title": "Inject Dependencies via AppRequestContext",
    "content": "All dependencies (services, repositories, stores) must be accessed through `AppRequestContext.dependencies`. This gives you a single, testable, type-safe injection point with zero service-locator magic.\n\n```swift\n// ✅ Correct — from AppRequestContext\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.userService.find(id: id)\n}\n\n// ❌ Wrong — constructed inline\nrouter.get(\"/users/:id\") { request, context in\n    let repo = PostgresUserRepository(pool: globalPool)\n    let service = UserService(repository: repo)\n    return try await service.find(id: request.uri.path)\n}\n```",
    "layer": "context",
    "patternIds": ["dependency-injection", "context-as-container"],
    "violationIds": ["service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "typed-errors-app-error",
    "title": "All Errors Are Typed AppError Values",
    "content": "Every error that crosses a layer boundary must be an `AppError`. Raw third-party errors are caught and wrapped immediately. This keeps HTTP response codes consistent and prevents internal details from leaking to clients.\n\n```swift\n// ✅ Correct — wrap at the boundary\nfunc findUser(id: String) async throws -> User {\n    do {\n        return try await repository.find(id: id)\n    } catch let dbError as DatabaseError {\n        throw AppError.internalError(reason: dbError.localizedDescription)\n    }\n}\n\n// ❌ Wrong — raw error propagates\nfunc findUser(id: String) async throws -> User {\n    return try await repository.find(id: id) // DatabaseError leaks up\n}\n```",
    "layer": null,
    "patternIds": ["typed-errors", "error-wrapping"],
    "violationIds": ["raw-error-thrown-from-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dtos-at-boundaries",
    "title": "DTOs at Every HTTP Boundary",
    "content": "Domain models must never cross the HTTP layer raw. A DTO (Data Transfer Object) gives you a stable public contract independent of internal model evolution.\n\n```swift\n// ✅ Correct — DTO at the boundary\nstruct UserResponse: Codable, ResponseCodable {\n    let id: String\n    let email: String\n    let createdAt: Date\n\n    init(_ user: User) {\n        self.id = user.id.uuidString\n        self.email = user.email\n        self.createdAt = user.createdAt\n    }\n}\n\n// Handler returns DTO, not domain model\nrouter.get(\"/users/:id\") { request, context in\n    let user = try await context.dependencies.userService.find(...)\n    return UserResponse(user) // never `return user` directly\n}\n```",
    "layer": "controller",
    "patternIds": ["dto-pattern", "api-boundary"],
    "violationIds": ["domain-model-across-http-boundary"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "actor-for-shared-state",
    "title": "Use Actors for Shared Mutable State",
    "content": "Any mutable state shared across concurrent requests must be protected by a Swift actor. In Swift 6 strict concurrency mode this is enforced at compile time.\n\n```swift\n// ✅ Correct — actor-protected\nactor RateLimitStore {\n    private var windows: [String: [Date]] = [:]\n\n    func recordRequest(from ip: String, limit: Int) -> Bool {\n        // Safe — all access serialised by the actor\n        ...\n    }\n}\n\n// ❌ Wrong — data race in Swift 6\nvar requestCounts: [String: Int] = [:] // module-level var\n\nrouter.get(\"/\") { request, context in\n    requestCounts[request.uri.path, default: 0] += 1 // data race!\n    ...\n}\n```",
    "layer": "middleware",
    "patternIds": ["actor-model", "swift-concurrency"],
    "violationIds": ["shared-mutable-state-without-actor"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "request-context-di",
    "title": "AppRequestContext as the DI Container",
    "content": "Hummingbird 2.x uses a custom `RequestContext` to thread per-request state. `AppRequestContext` extends this to carry the application's dependency graph. `DependencyInjectionMiddleware` populates it at the start of every request.\n\n```swift\n// The context definition\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies\n\n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        self.dependencies = AppDependencies.placeholder\n    }\n}\n\n// The middleware that fills it in\nstruct DependencyInjectionMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let dependencies: AppDependencies\n\n    func handle(_ request: Request, context: AppRequestContext,\n                next: (Request, AppRequestContext) async throws -> Response) async throws -> Response {\n        var ctx = context\n        ctx.dependencies = dependencies\n        return try await next(request, ctx)\n    }\n}\n```",
    "layer": "context",
    "patternIds": ["request-context", "middleware-di"],
    "violationIds": ["nonisolated-context-access"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "middleware-migration-1x-to-2x",
    "title": "Middleware Protocol Migration: Hummingbird 1.x → 2.x",
    "content": "Hummingbird 2.x completely redesigned the middleware API. The three critical changes are: (1) `MiddlewareProtocol` is now `RouterMiddleware`, (2) explicit `Context` type binding is required, and (3) the `next()` closure signature changed to accept both `Request` and `Context` parameters.\n\n```swift\n// ❌ Hummingbird 1.x — OLD API\nimport Hummingbird\n\nstruct LoggingMiddleware: HBMiddleware {\n    func apply(\n        to request: HBRequest,\n        next: HBResponder\n    ) async throws -> HBResponse {\n        let start = Date()\n        let response = try await next.respond(to: request)\n        let ms = Int(Date().timeIntervalSince(start) * 1000)\n        request.logger.info(\"Request completed in \\(ms)ms\")\n        return response\n    }\n}\n\n// ✅ Hummingbird 2.x — NEW API\nimport Hummingbird\n\nstruct LoggingMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext  // ← REQUIRED: Context type binding\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,  // ← NEW: explicit context parameter\n        next: (Request, AppRequestContext) async throws -> Response  // ← NEW: next signature\n    ) async throws -> Response {\n        let start = Date()\n        let response = try await next(request, context)  // ← NEW: pass both request and context\n        let ms = Int(Date().timeIntervalSince(start) * 1000)\n        context.logger.info(\"Request completed in \\(ms)ms\")  // ← context.logger instead of request.logger\n        return response\n    }\n}\n```\n\n**Key Migration Steps:**\n\n1. **Protocol**: Change `HBMiddleware` or `MiddlewareProtocol` → `RouterMiddleware`\n2. **Context Type**: Add `typealias Context = AppRequestContext` to bind the middleware to your custom context type\n3. **Method Signature**: Change `apply(to:next:)` → `handle(_:context:next:)`\n4. **Next Closure**: The `next` parameter is now a closure that takes `(Request, AppRequestContext)` instead of a `HBResponder`\n5. **Context Access**: Logger and other context properties move from `request.logger` → `context.logger`\n6. **Types**: `HBRequest` → `Request`, `HBResponse` → `Response`\n\n**Common Pitfall:**\nForgetting to pass both `request` and `context` to the `next` closure will cause a compile error. The context carries per-request state and must be threaded through the entire middleware chain.",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "migration-guide"],
    "violationIds": ["hummingbird-1x-middleware"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "router-middleware-pattern",
    "title": "RouterMiddleware Protocol Pattern",
    "content": "Hummingbird 2.x middleware conforms to `RouterMiddleware`. The associated `Context` type binds the middleware to a specific request context. Middleware is added to the router before routes are registered — order matters.\n\n```swift\nstruct AuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        guard let header = request.headers[.authorization],\n              header == \"Bearer \\(token)\" else {\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// Registration order matters — add before routes\nrouter.add(middleware: DependencyInjectionMiddleware(...))\nrouter.add(middleware: AuthMiddleware(token: ...))\nrouter.get(\"/protected\") { ... }\n```",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "request-pipeline"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-lifecycle-background-service",
    "title": "Background Services via Service Lifecycle",
    "content": "Hummingbird 2.x uses `swift-service-lifecycle` for background work. Implement `Service` and add to the application. The service group manages startup, shutdown, and graceful termination automatically.\n\n```swift\nimport Hummingbird\n\nstruct CacheRefreshService: Service {\n    let cache: CacheStore\n    let interval: Duration\n    let logger: Logger\n\n    func run() async throws {\n        while !Task.isCancelled {\n            do {\n                try await cache.refresh()\n                logger.info(\"Cache refreshed\")\n            } catch {\n                logger.warning(\"Cache refresh failed\", metadata: [\"error\": \"\\(error)\"])\n            }\n            try await Task.sleep(for: interval)\n        }\n    }\n}\n\n// In Application+build.swift:\napp.addServices(CacheRefreshService(cache: cache, interval: .seconds(3600), logger: logger))\n```",
    "layer": "service",
    "patternIds": ["service-lifecycle", "background-service"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "request-validation-via-dto",
    "title": "Request Validation Through DTOs",
    "content": "All HTTP request data (path parameters, query parameters, request bodies) must be validated through DTO decoding, not accessed raw from the request object. DTOs enforce type safety, validation rules, and provide a clean contract between HTTP and service layers.\n\n```swift\n// ✅ Correct — validate through DTO\nstruct CreateUserRequest: Decodable {\n    let email: String\n    let age: Int\n\n    enum CodingKeys: String, CodingKey {\n        case email, age\n    }\n\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        email = try container.decode(String.self, forKey: .email)\n        age = try container.decode(Int.self, forKey: .age)\n        \n        // Validation at the DTO boundary\n        guard email.contains(\"@\") else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .email,\n                in: container,\n                debugDescription: \"Email must be valid\"\n            )\n        }\n        guard age >= 13 else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .age,\n                in: container,\n                debugDescription: \"Must be 13 or older\"\n            )\n        }\n    }\n}\n\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    return try await context.dependencies.userService.create(dto)\n}\n\n// ❌ Wrong — raw parameter access without validation\nrouter.post(\"/users\") { request, context in\n    let email = request.uri.queryParameters[\"email\"] ?? \"\"\n    let ageStr = request.uri.queryParameters[\"age\"] ?? \"0\"\n    let age = Int(ageStr) ?? 0\n    // No validation, unsafe parsing, brittle code\n    return try await context.dependencies.userService.create(email: email, age: age)\n}\n```",
    "layer": "controller",
    "patternIds": ["dto-pattern", "api-boundary", "request-validation"],
    "violationIds": ["unchecked-uri-parameters", "unchecked-query-parameters", "raw-parameter-in-service-call", "missing-request-decode"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "inline-handler-anti-pattern",
    "title": "Anti-Pattern: All Logic Inline in Route Handlers",
    "content": "Tutorials often show all logic inline in a route handler for brevity. This is an anti-pattern in production code: it creates untestable handlers, couples framework to business logic, and makes layers impossible to reason about independently.\n\n```swift\n// ❌ ANTI-PATTERN — tutorial style, not production style\nrouter.post(\"/register\") { request, context in\n    struct Body: Decodable { var email: String; var password: String }\n    let body = try await request.decode(as: Body.self, context: context)\n    guard !body.email.isEmpty else { return Response(status: .badRequest) }\n    let hash = SHA256.hash(data: Data(body.password.utf8)).description\n    // Directly using global DB connection:\n    try await db.execute(\"INSERT INTO users ...\", [body.email, hash])\n    return Response(status: .created)\n}\n```\n\nThe correct approach uses the service layer for all business logic, the repository for DB access, and the context for injection.",
    "layer": "controller",
    "patternIds": [],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": true,
    "correctionId": "route-handler-dispatcher-only",
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "centralized-configuration",
    "title": "Centralized Configuration via AppDependencies",
    "content": "All configuration values (URLs, timeouts, feature flags, limits) must be centralized in a Configuration struct and injected via AppDependencies. Never hardcode values or access environment variables directly in services or handlers.\n\n```swift\n// ✅ Correct — centralized configuration\nstruct AppConfiguration: Sendable {\n    let apiBaseURL: String\n    let databaseURL: String\n    let rateLimitPerMinute: Int\n    let jwtSecret: String\n\n    static func fromEnvironment() throws -> AppConfiguration {\n        guard let apiURL = ProcessInfo.processInfo.environment[\"API_BASE_URL\"],\n              let dbURL = ProcessInfo.processInfo.environment[\"DATABASE_URL\"],\n              let jwtSecret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"] else {\n            throw AppError.configurationError(reason: \"Missing required environment variables\")\n        }\n        return AppConfiguration(\n            apiBaseURL: apiURL,\n            databaseURL: dbURL,\n            rateLimitPerMinute: 60,\n            jwtSecret: jwtSecret\n        )\n    }\n}\n\nstruct AppDependencies: Sendable {\n    let configuration: AppConfiguration\n    let userService: UserService\n    // ... other dependencies\n}\n\n// In service — configuration injected\nstruct UserService {\n    let config: AppConfiguration\n    let repository: any UserRepositoryProtocol\n\n    func authenticate(token: String) throws -> Bool {\n        return JWT.verify(token, secret: config.jwtSecret)\n    }\n}\n\n// ❌ Wrong — direct environment access\nstruct UserService {\n    func authenticate(token: String) throws -> Bool {\n        let secret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"]!\n        return JWT.verify(token, secret: secret)\n    }\n}\n\n// ❌ Wrong — hardcoded values\nstruct RateLimitMiddleware: RouterMiddleware {\n    func handle(_ request: Request, context: AppRequestContext, next: ...) async throws -> Response {\n        let limit = 60 // magic number!\n        ...\n    }\n}\n```",
    "layer": "context",
    "patternIds": ["dependency-injection", "configuration-management"],
    "violationIds": ["direct-env-access", "hardcoded-url", "magic-numbers"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "secure-configuration",
    "title": "Secure Secrets Management",
    "content": "Secrets (API keys, passwords, tokens, encryption keys) must NEVER be hardcoded in source code. They must be loaded from environment variables, secret management services, or encrypted configuration files at application startup.\n\n```swift\n// ✅ Correct — secrets from environment\nstruct AppConfiguration: Sendable {\n    let jwtSecret: String\n    let databasePassword: String\n    let apiKey: String\n\n    static func fromEnvironment() throws -> AppConfiguration {\n        guard let jwtSecret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"],\n              let dbPassword = ProcessInfo.processInfo.environment[\"DATABASE_PASSWORD\"],\n              let apiKey = ProcessInfo.processInfo.environment[\"API_KEY\"],\n              !jwtSecret.isEmpty, !dbPassword.isEmpty, !apiKey.isEmpty else {\n            throw AppError.configurationError(reason: \"Required secrets not found in environment\")\n        }\n        return AppConfiguration(\n            jwtSecret: jwtSecret,\n            databasePassword: dbPassword,\n            apiKey: apiKey\n        )\n    }\n}\n\n// ❌ CRITICAL VULNERABILITY — hardcoded secrets\nstruct AuthService {\n    let jwtSecret = \"super-secret-key-12345\" // ⚠️ NEVER DO THIS!\n    let apiKey = \"sk_live_abc123def456\" // ⚠️ SECURITY BREACH!\n}\n\n// ❌ Wrong — secrets in git-tracked config files\nstruct Config {\n    static let databaseURL = \"postgres://user:password@localhost/db\" // ⚠️ Credentials exposed!\n}\n```\n\nBest practices:\n- Use environment variables for development and production\n- Use secret management services (AWS Secrets Manager, HashiCorp Vault) in production\n- Never commit `.env` files to version control (add to `.gitignore`)\n- Rotate secrets regularly\n- Use different secrets for dev, staging, and production",
    "layer": null,
    "patternIds": ["security", "configuration-management"],
    "violationIds": ["hardcoded-credentials"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "async-concurrency-patterns",
    "title": "Async/Await Concurrency Patterns",
    "content": "Hummingbird 2.x is built on Swift concurrency. All I/O operations (network, file system, database) must use `async`/`await`. Never use blocking APIs (sleep, synchronous URLSession, blocking file I/O) in async contexts — they block the entire thread and prevent other requests from being processed.\n\n```swift\n// ✅ Correct — async/await for all I/O\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user)\n}\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n\n    func find(id: String) async throws -> User {\n        return try await repository.find(id: id) // async database call\n    }\n}\n\n// ❌ Wrong — blocking sleep in handler\nrouter.get(\"/slow\") { request, context in\n    Thread.sleep(forTimeInterval: 1.0) // ⚠️ Blocks executor thread!\n    return Response(status: .ok)\n}\n\n// ❌ Wrong — synchronous network call in async context\nfunc fetchData() async throws -> Data {\n    let url = URL(string: \"https://api.example.com/data\")!\n    let data = try Data(contentsOf: url) // ⚠️ Synchronous I/O blocks thread!\n    return data\n}\n\n// ✅ Correct — async network call\nfunc fetchData() async throws -> Data {\n    let url = URL(string: \"https://api.example.com/data\")!\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n```\n\nFor delays, use `Task.sleep(for:)` instead of `Thread.sleep()`:\n```swift\n// ✅ Correct — non-blocking delay\ntry await Task.sleep(for: .seconds(1))\n\n// ❌ Wrong — blocking delay\nThread.sleep(forTimeInterval: 1.0)\n```",
    "layer": null,
    "patternIds": ["swift-concurrency", "async-await"],
    "violationIds": ["sleep-in-handler", "blocking-sleep-in-async", "synchronous-network-call", "synchronous-database-call-in-async"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "non-blocking-io",
    "title": "Non-Blocking I/O Operations",
    "content": "All file I/O in async contexts must use async APIs. Swift's `FileHandle`, `Data(contentsOf:)`, and `String(contentsOfFile:)` are synchronous and block the thread. Use async file I/O libraries or offload to a background executor.\n\n```swift\n// ✅ Correct — async file I/O (using async FileHandle or custom wrapper)\nimport Foundation\n#if canImport(FoundationNetworking)\nimport FoundationNetworking\n#endif\n\nfunc readFile(at path: String) async throws -> Data {\n    // Option 1: Use async-capable file I/O library (e.g., swift-nio, AsyncFileHandle)\n    // Option 2: Offload to background executor for legacy APIs\n    return try await Task.detached {\n        try Data(contentsOf: URL(fileURLWithPath: path))\n    }.value\n}\n\n// ❌ Wrong — synchronous file I/O in async context\nfunc loadConfig() async throws -> Configuration {\n    let data = try Data(contentsOf: URL(fileURLWithPath: \"/etc/config.json\")) // ⚠️ Blocks thread!\n    return try JSONDecoder().decode(Configuration.self, from: data)\n}\n\n// ✅ Correct — offload to background if no async API available\nfunc loadConfig() async throws -> Configuration {\n    let data = try await Task.detached {\n        try Data(contentsOf: URL(fileURLWithPath: \"/etc/config.json\"))\n    }.value\n    return try JSONDecoder().decode(Configuration.self, from: data)\n}\n```\n\nFor database operations, always use async database clients:\n```swift\n// ✅ Correct — async database client (e.g., PostgresNIO, MongoKitten)\nlet users = try await db.query(\"SELECT * FROM users WHERE id = $1\", [id])\n\n// ❌ Wrong — synchronous database call\nlet users = try db.executeSync(\"SELECT * FROM users WHERE id = $1\", [id])\n```",
    "layer": null,
    "patternIds": ["swift-concurrency", "async-io"],
    "violationIds": ["blocking-io-in-async"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "sendable-types",
    "title": "Sendable Conformance for Concurrent Types",
    "content": "Swift 6 strict concurrency requires that types crossing concurrency boundaries (passed to async functions, stored in actors, captured in closures) conform to `Sendable`. This prevents data races at compile time.\n\n```swift\n// ✅ Correct — Sendable structs for concurrent use\nstruct User: Sendable {\n    let id: UUID\n    let email: String\n    let createdAt: Date\n}\n\nstruct AppConfiguration: Sendable {\n    let apiURL: String\n    let timeout: Duration\n}\n\n// ✅ Correct — @unchecked Sendable for types with internal synchronization\nfinal class DatabasePool: @unchecked Sendable {\n    private let lock = NSLock()\n    private var connections: [Connection] = []\n\n    func getConnection() -> Connection {\n        lock.lock()\n        defer { lock.unlock() }\n        return connections.removeFirst()\n    }\n}\n\n// ❌ Wrong — non-Sendable type crossing concurrency boundary\nclass UserCache { // Missing Sendable conformance\n    var users: [UUID: User] = [:]\n}\n\nfunc cacheUser(_ user: User, in cache: UserCache) async {\n    cache.users[user.id] = user // ⚠️ Data race risk!\n}\n\n// ✅ Correct — use actor instead\nactor UserCache {\n    private var users: [UUID: User] = [:]\n\n    func store(_ user: User) {\n        users[user.id] = user\n    }\n\n    func get(_ id: UUID) -> User? {\n        return users[id]\n    }\n}\n```\n\nSendable conformance rules:\n- Structs with only Sendable properties are automatically Sendable\n- Actors are implicitly Sendable\n- Classes must be `final`, have only immutable properties, and use `@unchecked Sendable` if they have internal synchronization\n- Closures capturing only Sendable values are Sendable",
    "layer": null,
    "patternIds": ["swift-concurrency", "sendable"],
    "violationIds": ["missing-sendable-conformance"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "structured-concurrency",
    "title": "Structured Concurrency with Task Groups",
    "content": "Swift structured concurrency ensures tasks are properly scoped and cancelled. Use `async let` for independent concurrent tasks, `TaskGroup` for dynamic concurrency, and avoid unstructured `Task.detached` unless absolutely necessary.\n\n```swift\n// ✅ Correct — structured concurrency with async let\nfunc fetchUserData(id: String) async throws -> UserData {\n    async let user = userService.find(id: id)\n    async let posts = postService.findByUser(id: id)\n    async let comments = commentService.findByUser(id: id)\n\n    return try await UserData(\n        user: user,\n        posts: posts,\n        comments: comments\n    )\n}\n\n// ✅ Correct — TaskGroup for dynamic concurrency\nfunc fetchMultipleUsers(ids: [String]) async throws -> [User] {\n    return try await withThrowingTaskGroup(of: User.self) { group in\n        for id in ids {\n            group.addTask {\n                try await userService.find(id: id)\n            }\n        }\n        var users: [User] = []\n        for try await user in group {\n            users.append(user)\n        }\n        return users\n    }\n}\n\n// ❌ Wrong — unstructured Task.detached loses cancellation\nfunc processInBackground(data: Data) async {\n    Task.detached { // ⚠️ Not cancelled when parent is cancelled!\n        try? await heavyProcessing(data)\n    }\n    // Function returns immediately, task continues in background\n    // No way to wait for completion or handle errors\n}\n\n// ✅ Correct — child task inherits cancellation\nfunc processInBackground(data: Data) async throws {\n    try await withTaskCancellationHandler {\n        try await heavyProcessing(data)\n    } onCancel: {\n        cleanup()\n    }\n}\n```\n\nUse `Task.detached` only when you need to break actor isolation for a legitimate reason (e.g., avoiding priority inversion). Always handle cancellation explicitly.",
    "layer": null,
    "patternIds": ["swift-concurrency", "task-groups"],
    "violationIds": ["task-detached-without-isolation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "structured-logging",
    "title": "Structured Logging with swift-log",
    "content": "Hummingbird 2.x uses `swift-log` for structured logging. Never use `print()` for logging — it's not structured, can't be filtered by level, and won't appear in production logs. Always log errors with context metadata.\n\n```swift\nimport Logging\n\nstruct UserService {\n    let logger: Logger\n    let repository: any UserRepositoryProtocol\n\n    func create(_ request: CreateUserRequest) async throws -> User {\n        logger.info(\"Creating user\", metadata: [\"email\": \"\\(request.email)\"])\n\n        do {\n            let user = try await repository.insert(User(email: request.email))\n            logger.info(\"User created\", metadata: [\n                \"userId\": \"\\(user.id)\",\n                \"email\": \"\\(user.email)\"\n            ])\n            return user\n        } catch let error as DatabaseError {\n            logger.error(\"Database error creating user\", metadata: [\n                \"email\": \"\\(request.email)\",\n                \"error\": \"\\(error)\",\n                \"errorCode\": \"\\(error.code)\"\n            ])\n            throw AppError.internalError(reason: \"Failed to create user\")\n        }\n    }\n}\n\n// ❌ Wrong — print instead of logger\nfunc deleteUser(id: String) async throws {\n    do {\n        try await repository.delete(id: id)\n    } catch {\n        print(\"Error: \\(error)\") // ⚠️ Not structured, no context, can't filter!\n        throw error\n    }\n}\n\n// ❌ Wrong — swallowed error with no logging\nfunc updateUser(id: String, email: String) async throws {\n    do {\n        try await repository.update(id: id, email: email)\n    } catch {\n        // ⚠️ Error discarded silently — impossible to debug!\n    }\n}\n```\n\nLog levels:\n- `trace`: Very detailed debugging (e.g., request/response bodies)\n- `debug`: Debugging information (e.g., cache hits, query plans)\n- `info`: Normal application flow (e.g., \"User created\", \"Request started\")\n- `notice`: Important but normal events (e.g., \"Configuration loaded\")\n- `warning`: Unusual but recoverable (e.g., \"Retry attempt 2/3\")\n- `error`: Errors that should be investigated (e.g., database failures)\n- `critical`: System instability (e.g., \"Out of memory\")",
    "layer": null,
    "patternIds": ["logging", "observability"],
    "violationIds": ["print-in-error-handler", "swallowed-error", "error-discarded-with-underscore"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "explicit-http-status-codes",
    "title": "Explicit HTTP Status Codes",
    "content": "Every HTTP response must have an explicit status code. Hummingbird infers `.ok` (200) for most types, but you should be explicit, especially for error cases, redirects, and created resources.\n\n```swift\n// ✅ Correct — explicit status codes\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    let user = try await context.dependencies.userService.create(dto)\n    return Response(status: .created, body: .init(data: try JSONEncoder().encode(CreateUserResponse(user))))\n}\n\nrouter.delete(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    try await context.dependencies.userService.delete(id: id)\n    return Response(status: .noContent)\n}\n\nrouter.get(\"/health\") { request, context in\n    return Response(status: .ok, body: .init(string: \"OK\"))\n}\n\n// ❌ Wrong — missing status code (defaults to 200)\nrouter.post(\"/users\") { request, context in\n    let user = try await context.dependencies.userService.create(...)\n    return CreateUserResponse(user) // ⚠️ Should be 201 Created, not 200 OK!\n}\n\n// ❌ Wrong — generic status for errors\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    guard let user = try await context.dependencies.userService.find(id: id) else {\n        return Response(status: .badRequest) // ⚠️ Should be 404 Not Found, not 400 Bad Request!\n    }\n    return UserResponse(user)\n}\n```\n\nCommon status codes:\n- `200 OK`: Successful GET, PUT, PATCH\n- `201 Created`: Successful POST that creates a resource\n- `204 No Content`: Successful DELETE or update with no response body\n- `400 Bad Request`: Invalid input (validation error)\n- `401 Unauthorized`: Missing or invalid authentication\n- `403 Forbidden`: Valid auth but insufficient permissions\n- `404 Not Found`: Resource doesn't exist\n- `409 Conflict`: Duplicate resource or constraint violation\n- `500 Internal Server Error`: Unexpected server error",
    "layer": "controller",
    "patternIds": ["http-status-codes", "rest-api"],
    "violationIds": ["response-without-status-code"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "explicit-content-type-headers",
    "title": "Explicit Content-Type Headers",
    "content": "HTTP responses should explicitly set the Content-Type header to indicate the response format. While Hummingbird can infer types for some responses, being explicit prevents client parsing errors and improves API clarity.\n\n```swift\n// ✅ Correct — explicit Content-Type for JSON\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    let body = try JSONEncoder().encode(UserResponse(user))\n    var response = Response(status: .ok, body: .init(data: body))\n    response.headers[.contentType] = \"application/json\"\n    return response\n}\n\n// ✅ Correct — using ResponseCodable (sets Content-Type automatically)\nstruct UserResponse: ResponseCodable {\n    let id: String\n    let email: String\n}\n\nrouter.get(\"/users/:id\") { request, context in\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user) // Content-Type: application/json set automatically\n}\n\n// ✅ Correct — explicit Content-Type for HTML\nrouter.get(\"/dashboard\") { request, context in\n    let html = \"<html><body>Dashboard</body></html>\"\n    var response = Response(status: .ok, body: .init(string: html))\n    response.headers[.contentType] = \"text/html; charset=utf-8\"\n    return response\n}\n\n// ❌ Wrong — missing Content-Type for binary data\nrouter.get(\"/download\") { request, context in\n    let data = try await fileService.readFile(\"report.pdf\")\n    return Response(status: .ok, body: .init(data: data)) // ⚠️ Missing Content-Type!\n}\n\n// ✅ Correct — explicit Content-Type for binary data\nrouter.get(\"/download\") { request, context in\n    let data = try await fileService.readFile(\"report.pdf\")\n    var response = Response(status: .ok, body: .init(data: data))\n    response.headers[.contentType] = \"application/pdf\"\n    response.headers[.contentDisposition] = \"attachment; filename=\\\"report.pdf\\\"\"\n    return response\n}\n```\n\nCommon Content-Type values:\n- `application/json`: JSON data (most common for REST APIs)\n- `text/html; charset=utf-8`: HTML pages\n- `text/plain; charset=utf-8`: Plain text\n- `application/pdf`: PDF documents\n- `image/png`, `image/jpeg`: Images\n- `application/octet-stream`: Generic binary data",
    "layer": "controller",
    "patternIds": ["http-headers", "rest-api"],
    "violationIds": ["response-missing-content-type"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-02-28T00:00:00Z"
  },
  {
    "id": "router-groups-and-prefixes",
    "title": "Router Groups and Route Prefixes",
    "content": "Hummingbird 2.x routers support grouping routes with shared prefixes and middleware. Use `router.group()` to organize related endpoints logically, apply scoped middleware, and avoid repetitive path segments. Groups can be nested for hierarchical API structures.\n\n```swift\n// ✅ Correct — using router groups with prefixes\nlet apiV1 = router.group(\"/api/v1\")\n\napiV1.group(\"/users\")\n    .get { request, context in\n        // GET /api/v1/users\n        return try await context.dependencies.userService.list()\n    }\n    .get(\"/:id\") { request, context in\n        // GET /api/v1/users/:id\n        let id = try context.parameters.require(\"id\")\n        return try await context.dependencies.userService.find(id: id)\n    }\n    .post { request, context in\n        // POST /api/v1/users\n        let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n        return try await context.dependencies.userService.create(dto)\n    }\n\napiV1.group(\"/posts\")\n    .get { request, context in\n        // GET /api/v1/posts\n        return try await context.dependencies.postService.list()\n    }\n    .get(\"/:id\") { request, context in\n        // GET /api/v1/posts/:id\n        let id = try context.parameters.require(\"id\")\n        return try await context.dependencies.postService.find(id: id)\n    }\n\n// ✅ Correct — applying middleware to a group\nlet authenticated = router.group()\n    .add(middleware: AuthMiddleware())\n\nauthenticated.group(\"/admin\")\n    .get(\"/dashboard\") { request, context in\n        // Requires authentication via AuthMiddleware\n        return try await context.dependencies.adminService.getDashboard()\n    }\n    .delete(\"/users/:id\") { request, context in\n        let id = try context.parameters.require(\"id\")\n        return try await context.dependencies.userService.delete(id: id)\n    }\n\n// ❌ Wrong — repeating prefixes in every route\nrouter.get(\"/api/v1/users\") { request, context in\n    return try await context.dependencies.userService.list()\n}\n\nrouter.get(\"/api/v1/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.userService.find(id: id)\n}\n\nrouter.get(\"/api/v1/posts\") { request, context in\n    return try await context.dependencies.postService.list()\n}\n\nrouter.get(\"/api/v1/posts/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.postService.find(id: id)\n}\n// ⚠️ Repetitive, hard to refactor, middleware must be added to each route\n\n// ❌ Wrong — applying middleware to individual routes instead of groups\nrouter.get(\"/admin/dashboard\") { request, context in\n    // Must manually check auth in every handler\n    guard try await context.dependencies.authService.isAuthenticated(request) else {\n        throw HTTPError(.unauthorized)\n    }\n    return try await context.dependencies.adminService.getDashboard()\n}\n```\n\nBest practices:\n- Group routes by resource (`/users`, `/posts`, `/comments`)\n- Use versioned groups (`/api/v1`, `/api/v2`) for API versioning\n- Apply middleware at the group level, not per route\n- Nest groups for hierarchical structures (`/api/v1/admin/users`)\n- Keep route definitions close to related routes for readability",
    "layer": "controller",
    "patternIds": ["router-groups", "route-organization", "middleware-scoping"],
    "violationIds": ["repeated-route-prefixes", "middleware-duplication"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "response-body-streaming-patterns",
    "title": "Response Body Types and Streaming Patterns",
    "content": "Hummingbird 2.x uses NIO's `ByteBuffer` and Swift's `AsyncSequence` for response bodies. Understanding these types is critical for efficient streaming, file downloads, and large response handling. Never buffer entire large responses in memory — stream them instead.\n\n```swift\nimport Hummingbird\nimport NIOCore\n\n// ✅ Correct — streaming file download with AsyncSequence\nrouter.get(\"/download/:filename\") { request, context in\n    let filename = try context.parameters.require(\"filename\")\n    let fileStream = try await context.dependencies.fileService.streamFile(filename)\n    \n    // ResponseBody accepts AsyncSequence<ByteBuffer, Error>\n    var response = Response(\n        status: .ok,\n        body: .init(asyncSequence: fileStream)\n    )\n    response.headers[.contentType] = \"application/octet-stream\"\n    response.headers[.contentDisposition] = \"attachment; filename=\\\"\\(filename)\\\"\"\n    return response\n}\n\n// ✅ Correct — streaming JSON array with backpressure handling\nstruct UserStreamService {\n    func streamAllUsers() -> AsyncStream<ByteBuffer, Error> {\n        AsyncStream { continuation in\n            Task {\n                do {\n                    let users = try await repository.findAll()\n                    var buffer = ByteBufferAllocator().buffer(capacity: 1024)\n                    buffer.writeString(\"[\")\n                    continuation.yield(buffer)\n                    \n                    for (index, user) in users.enumerated() {\n                        var itemBuffer = ByteBufferAllocator().buffer(capacity: 256)\n                        if index > 0 {\n                            itemBuffer.writeString(\",\")\n                        }\n                        let userData = try JSONEncoder().encode(user)\n                        itemBuffer.writeBytes(userData)\n                        continuation.yield(itemBuffer)\n                    }\n                    \n                    var endBuffer = ByteBufferAllocator().buffer(capacity: 1)\n                    endBuffer.writeString(\"]\")\n                    continuation.yield(endBuffer)\n                    continuation.finish()\n                } catch {\n                    continuation.finish(throwing: error)\n                }\n            }\n        }\n    }\n}\n\n// ✅ Correct — static ByteBuffer for small responses\nrouter.get(\"/health\") { request, context in\n    var buffer = ByteBufferAllocator().buffer(capacity: 16)\n    buffer.writeString(\"{\\\"status\\\":\\\"ok\\\"}\")\n    var response = Response(status: .ok, body: .init(byteBuffer: buffer))\n    response.headers[.contentType] = \"application/json\"\n    return response\n}\n\n// ❌ Wrong — loading entire large file into memory\nrouter.get(\"/download/:filename\") { request, context in\n    let filename = try context.parameters.require(\"filename\")\n    let data = try await fileService.readEntireFile(filename) // ⚠️ OOM for large files!\n    var buffer = ByteBufferAllocator().buffer(capacity: data.count)\n    buffer.writeBytes(data)\n    return Response(status: .ok, body: .init(byteBuffer: buffer))\n}\n\n// ❌ Wrong — buffering entire stream before sending\nrouter.get(\"/users/export\") { request, context in\n    let users = try await context.dependencies.userService.findAll()\n    var allData = Data()\n    for user in users {\n        allData.append(try JSONEncoder().encode(user)) // ⚠️ Builds entire response in memory!\n    }\n    var buffer = ByteBufferAllocator().buffer(capacity: allData.count)\n    buffer.writeBytes(allData)\n    return Response(status: .ok, body: .init(byteBuffer: buffer))\n}\n\n// ❌ Wrong — AsyncSequence without error handling\nfunc streamData() -> AsyncStream<ByteBuffer, Never> {\n    AsyncStream { continuation in\n        Task {\n            let data = try! await fetchData() // ⚠️ Force-try crashes on error!\n            var buffer = ByteBufferAllocator().buffer(capacity: data.count)\n            buffer.writeBytes(data)\n            continuation.yield(buffer)\n            continuation.finish()\n        }\n    }\n}\n\n// ✅ Correct — AsyncSequence with proper error propagation\nfunc streamData() -> AsyncThrowingStream<ByteBuffer, Error> {\n    AsyncThrowingStream { continuation in\n        Task {\n            do {\n                let data = try await fetchData()\n                var buffer = ByteBufferAllocator().buffer(capacity: data.count)\n                buffer.writeBytes(data)\n                continuation.yield(buffer)\n                continuation.finish()\n            } catch {\n                continuation.finish(throwing: error)\n            }\n        }\n    }\n}\n```\n\nKey types:\n- `ByteBuffer`: NIO's efficient byte container (copy-on-write, ref-counted)\n- `ResponseBody`: Wrapper supporting `.init(byteBuffer:)`, `.init(asyncSequence:)`, `.init(data:)`, `.init(string:)`\n- `AsyncSequence<ByteBuffer, Error>`: Protocol for streaming responses\n- `AsyncStream` / `AsyncThrowingStream`: Concrete async sequence types\n\nCommon pitfalls:\n- Loading entire files into memory instead of streaming\n- Buffering entire response before sending (defeats streaming)\n- Using `AsyncStream<ByteBuffer, Never>` for operations that can fail (use `AsyncThrowingStream`)\n- Not setting `Content-Length` header for known-size responses\n- Not handling backpressure (NIO handles this automatically with AsyncSequence)\n- Creating new `ByteBufferAllocator` per request (use shared allocator from context)\n- Force-unwrapping or `try!` in stream producers (always propagate errors via continuation)",
    "layer": "controller",
    "patternIds": ["response-streaming", "bytebuffer", "async-sequence", "backpressure"],
    "violationIds": ["buffering-entire-stream", "missing-stream-error-handling", "force-try-in-stream", "oom-large-file-in-memory"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "multipart-form-data-handling",
    "title": "Multipart Form Data and File Uploads",
    "content": "Hummingbird 2.x handles multipart form data through the request body stream. For file uploads, you must parse the multipart boundary, extract parts, and stream file content to storage without buffering the entire file in memory. Use a multipart parser library or implement streaming multipart parsing.\n\n```swift\nimport Hummingbird\nimport NIOCore\n\n// ✅ Correct — streaming file upload with multipart parsing\nrouter.post(\"/upload\") { request, context in\n    guard let contentType = request.headers[.contentType],\n          contentType.hasPrefix(\"multipart/form-data\") else {\n        throw HTTPError(.badRequest, message: \"Content-Type must be multipart/form-data\")\n    }\n    \n    // Extract boundary from Content-Type header\n    guard let boundary = extractBoundary(from: contentType) else {\n        throw HTTPError(.badRequest, message: \"Missing boundary in Content-Type\")\n    }\n    \n    let uploadService = context.dependencies.uploadService\n    let fileMetadata = try await uploadService.handleMultipartUpload(\n        body: request.body,\n        boundary: boundary\n    )\n    \n    return Response(\n        status: .created,\n        body: .init(data: try JSONEncoder().encode(UploadResponse(fileMetadata)))\n    )\n}\n\n// Service layer — streaming multipart parser\nstruct UploadService {\n    let storage: any FileStorageProtocol\n    let logger: Logger\n    \n    func handleMultipartUpload(\n        body: Request.Body,\n        boundary: String\n    ) async throws -> FileMetadata {\n        var parser = MultipartParser(boundary: boundary)\n        var currentFile: FileUploadContext?\n        \n        for try await chunk in body {\n            let parts = try parser.parse(chunk)\n            \n            for part in parts {\n                switch part {\n                case .headers(let headers):\n                    // Extract filename and content-type from part headers\n                    guard let disposition = headers[\"content-disposition\"],\n                          let filename = extractFilename(from: disposition) else {\n                        throw AppError.invalidInput(reason: \"Missing filename\")\n                    }\n                    \n                    let contentType = headers[\"content-type\"] ?? \"application/octet-stream\"\n                    currentFile = try await storage.createUpload(\n                        filename: filename,\n                        contentType: contentType\n                    )\n                    \n                case .body(let data):\n                    guard let file = currentFile else {\n                        throw AppError.invalidInput(reason: \"Received body before headers\")\n                    }\n                    try await storage.writeChunk(data, to: file)\n                    \n                case .end:\n                    guard let file = currentFile else {\n                        throw AppError.invalidInput(reason: \"Received end before file start\")\n                    }\n                    try await storage.finalizeUpload(file)\n                    currentFile = nil\n                }\n            }\n        }\n        \n        guard let file = currentFile else {\n            throw AppError.invalidInput(reason: \"No file uploaded\")\n        }\n        \n        return try await storage.getMetadata(for: file)\n    }\n}\n\nfunc extractBoundary(from contentType: String) -> String? {\n    let components = contentType.split(separator: \";\")\n    for component in components {\n        let trimmed = component.trimmingCharacters(in: .whitespaces)\n        if trimmed.hasPrefix(\"boundary=\") {\n            return String(trimmed.dropFirst(\"boundary=\".count))\n        }\n    }\n    return nil\n}\n\n// ❌ Wrong — buffering entire file upload in memory\nrouter.post(\"/upload\") { request, context in\n    var allData = Data()\n    for try await chunk in request.body {\n        allData.append(contentsOf: chunk.readableBytesView) // ⚠️ OOM for large files!\n    }\n    \n    // Parse entire multipart body from memory\n    let file = try parseMultipart(allData)\n    try await storage.save(file)\n    return Response(status: .created)\n}\n\n// ❌ Wrong — missing Content-Type validation\nrouter.post(\"/upload\") { request, context in\n    // No check for multipart/form-data!\n    let file = try await uploadService.handleUpload(request.body)\n    return Response(status: .created)\n}\n\n// ❌ Wrong — synchronous file write in async context\nrouter.post(\"/upload\") { request, context in\n    let filename = UUID().uuidString\n    let handle = FileHandle(forWritingAtPath: \"/uploads/\\(filename)\")! // ⚠️ Synchronous!\n    \n    for try await chunk in request.body {\n        handle.write(Data(buffer: chunk)) // ⚠️ Blocks executor thread!\n    }\n    \n    handle.closeFile()\n    return Response(status: .created)\n}\n```\n\nBest practices:\n- Always validate `Content-Type: multipart/form-data` before parsing\n- Extract and validate the boundary parameter from Content-Type header\n- Stream file chunks directly to storage (disk, S3, etc.) without buffering entire file\n- Set upload size limits to prevent DoS attacks (use middleware or check Content-Length)\n- Validate filenames to prevent directory traversal attacks (sanitize `../`, absolute paths)\n- Use async file I/O or object storage SDKs (never synchronous file operations)\n- Return file metadata (ID, size, content-type) in response, not the file content itself\n- Clean up partial uploads on errors (delete incomplete files)\n- Consider using a battle-tested multipart parser library instead of custom parsing",
    "layer": "controller",
    "patternIds": ["multipart-form-data", "file-upload", "request-streaming"],
    "violationIds": ["buffering-entire-upload", "missing-content-type-validation", "synchronous-file-write", "directory-traversal-vulnerability"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "request-body-streaming",
    "title": "Streaming Request Bodies with AsyncSequence",
    "content": "Hummingbird 2.x provides `Request.Body` as an `AsyncSequence<ByteBuffer>` for streaming large request payloads. Never call `request.decode()` for large uploads — it buffers the entire body. Instead, iterate the body stream chunk-by-chunk for memory-efficient processing.\n\n```swift\nimport Hummingbird\nimport NIOCore\n\n// ✅ Correct — streaming request body processing\nrouter.post(\"/ingest\") { request, context in\n    var totalBytes = 0\n    var hasher = SHA256()\n    \n    // Process request body as stream\n    for try await chunk in request.body {\n        totalBytes += chunk.readableBytes\n        hasher.update(data: chunk.readableBytesView)\n        \n        // Stream to storage or process incrementally\n        try await context.dependencies.dataService.processChunk(chunk)\n    }\n    \n    let hash = hasher.finalize()\n    logger.info(\"Processed streaming request\", metadata: [\n        \"totalBytes\": \"\\(totalBytes)\",\n        \"hash\": \"\\(hash.hexString)\"\n    ])\n    \n    return Response(status: .accepted)\n}\n\n// ✅ Correct — streaming CSV import line-by-line\nrouter.post(\"/import/csv\") { request, context in\n    var lineBuffer = ByteBufferAllocator().buffer(capacity: 1024)\n    var recordsImported = 0\n    \n    for try await chunk in request.body {\n        lineBuffer.writeImmutableBuffer(chunk)\n        \n        // Process complete lines\n        while let line = lineBuffer.readLine() {\n            let record = try parseCSVLine(line)\n            try await context.dependencies.importService.insertRecord(record)\n            recordsImported += 1\n        }\n    }\n    \n    // Process remaining partial line if any\n    if lineBuffer.readableBytes > 0 {\n        let line = lineBuffer.readString(length: lineBuffer.readableBytes)!\n        let record = try parseCSVLine(line)\n        try await context.dependencies.importService.insertRecord(record)\n        recordsImported += 1\n    }\n    \n    return Response(\n        status: .ok,\n        body: .init(data: try JSONEncoder().encode(ImportResponse(recordsImported: recordsImported)))\n    )\n}\n\n// ✅ Correct — streaming request with Content-Length validation\nrouter.post(\"/upload\") { request, context in\n    guard let contentLengthStr = request.headers[.contentLength],\n          let contentLength = Int(contentLengthStr) else {\n        throw HTTPError(.lengthRequired, message: \"Content-Length header required\")\n    }\n    \n    let maxUploadSize = 100 * 1024 * 1024 // 100 MB\n    guard contentLength <= maxUploadSize else {\n        throw HTTPError(.payloadTooLarge, message: \"Upload exceeds \\(maxUploadSize) bytes\")\n    }\n    \n    var totalReceived = 0\n    for try await chunk in request.body {\n        totalReceived += chunk.readableBytes\n        \n        // Enforce limit even if Content-Length header is wrong\n        guard totalReceived <= maxUploadSize else {\n            throw HTTPError(.payloadTooLarge, message: \"Upload size exceeded during transfer\")\n        }\n        \n        try await context.dependencies.uploadService.writeChunk(chunk)\n    }\n    \n    guard totalReceived == contentLength else {\n        throw HTTPError(.badRequest, message: \"Received \\(totalReceived) bytes, expected \\(contentLength)\")\n    }\n    \n    return Response(status: .created)\n}\n\n// ❌ Wrong — buffering entire request body\nrouter.post(\"/process\") { request, context in\n    var allData = ByteBufferAllocator().buffer(capacity: 0)\n    for try await chunk in request.body {\n        allData.writeImmutableBuffer(chunk) // ⚠️ Buffers entire request in memory!\n    }\n    \n    try await processData(allData) // Memory spike for large requests\n    return Response(status: .ok)\n}\n\n// ❌ Wrong — using request.decode() for large payloads\nrouter.post(\"/import\") { request, context in\n    // ⚠️ Buffers entire JSON array in memory before parsing!\n    let records = try await request.decode(as: [ImportRecord].self, context: context)\n    \n    for record in records {\n        try await context.dependencies.importService.insertRecord(record)\n    }\n    \n    return Response(status: .ok)\n}\n\n// ❌ Wrong — no upload size limit enforcement\nrouter.post(\"/upload\") { request, context in\n    // No size limit! ⚠️ Attacker can send unlimited data\n    for try await chunk in request.body {\n        try await storage.write(chunk)\n    }\n    return Response(status: .created)\n}\n\n// ❌ Wrong — ignoring backpressure in stream processing\nrouter.post(\"/ingest\") { request, context in\n    for try await chunk in request.body {\n        // Spawning detached task loses backpressure!\n        Task.detached {\n            try? await slowProcessor.process(chunk) // ⚠️ Tasks queue up unbounded!\n        }\n    }\n    return Response(status: .accepted)\n}\n\n// ✅ Correct — respecting backpressure\nrouter.post(\"/ingest\") { request, context in\n    for try await chunk in request.body {\n        // Await each chunk processing before reading next\n        try await slowProcessor.process(chunk) // Backpressure maintained\n    }\n    return Response(status: .accepted)\n}\n```\n\nKey points:\n- `Request.Body` is `AsyncSequence<ByteBuffer>` — iterate with `for try await`\n- Each iteration yields a `ByteBuffer` chunk (not necessarily the entire body)\n- Use `request.decode()` only for small, trusted payloads (< 1 MB)\n- For large uploads, stream chunks to storage without buffering\n- Always enforce upload size limits (check `Content-Length`, track bytes received)\n- Validate `Content-Length` header matches actual received bytes\n- Respect backpressure — await async operations inside loop, don't spawn detached tasks\n- For line-based protocols (CSV, NDJSON), accumulate chunks into line buffer\n- Use `ByteBuffer.readLine()` or manual parsing for incremental processing\n- Clean up resources on error (close files, abort multipart uploads, etc.)\n\nCommon mistakes:\n- Buffering entire body before processing (defeats streaming)\n- Using `request.decode()` for large uploads (OOM risk)\n- Missing upload size limits (DoS vulnerability)\n- Spawning detached tasks in loop (loses backpressure, unbounded memory growth)\n- Not validating Content-Length header\n- Synchronous I/O in stream processing (blocks executor threads)",
    "layer": "controller",
    "patternIds": ["request-streaming", "async-sequence", "backpressure", "upload-limits"],
    "violationIds": ["buffering-entire-request", "missing-upload-size-limit", "detached-task-in-stream-loop", "request-decode-for-large-payload"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "file-upload-security",
    "title": "File Upload Security Best Practices",
    "content": "File uploads are a major security risk. Every file upload endpoint must validate file type, size, filename, and content. Never trust client-provided filenames, MIME types, or file extensions. Always sanitize, validate, and scan uploaded files before storage or processing.\n\n```swift\nimport Hummingbird\nimport Foundation\n\n// ✅ Correct — comprehensive file upload validation\nstruct FileUploadService {\n    let storage: any FileStorageProtocol\n    let logger: Logger\n    let config: UploadConfiguration\n    \n    func validateAndStoreUpload(\n        filename: String,\n        contentType: String,\n        body: Request.Body\n    ) async throws -> FileMetadata {\n        // 1. Validate and sanitize filename\n        let sanitizedFilename = try sanitizeFilename(filename)\n        \n        // 2. Validate MIME type against allowlist\n        guard config.allowedMimeTypes.contains(contentType) else {\n            logger.warning(\"Rejected upload with disallowed MIME type\", metadata: [\n                \"filename\": \"\\(sanitizedFilename)\",\n                \"contentType\": \"\\(contentType)\"\n            ])\n            throw AppError.invalidInput(reason: \"File type \\(contentType) not allowed\")\n        }\n        \n        // 3. Extract and validate file extension\n        let fileExtension = (sanitizedFilename as NSString).pathExtension.lowercased()\n        guard config.allowedExtensions.contains(fileExtension) else {\n            throw AppError.invalidInput(reason: \"File extension .\\(fileExtension) not allowed\")\n        }\n        \n        // 4. Generate secure random filename (don't use client filename)\n        let secureFilename = \"\\(UUID().uuidString).\\(fileExtension)\"\n        \n        // 5. Stream to temporary location with size limit\n        let tempPath = try await storage.createTempFile(secureFilename)\n        var bytesWritten = 0\n        \n        do {\n            for try await chunk in body {\n                bytesWritten += chunk.readableBytes\n                \n                // Enforce size limit during upload\n                guard bytesWritten <= config.maxUploadSizeBytes else {\n                    try await storage.deleteTempFile(tempPath)\n                    throw AppError.invalidInput(reason: \"File exceeds maximum size of \\(config.maxUploadSizeBytes) bytes\")\n                }\n                \n                try await storage.writeToTempFile(chunk, at: tempPath)\n            }\n            \n            // 6. Validate actual content type by inspecting file magic bytes\n            let actualContentType = try await detectContentType(at: tempPath)\n            guard actualContentType == contentType else {\n                logger.warning(\"Content-Type mismatch\", metadata: [\n                    \"declared\": \"\\(contentType)\",\n                    \"actual\": \"\\(actualContentType)\"\n                ])\n                try await storage.deleteTempFile(tempPath)\n                throw AppError.invalidInput(reason: \"File content does not match declared type\")\n            }\n            \n            // 7. Optional: Virus scan (if available)\n            if let virusScanner = config.virusScanner {\n                let isSafe = try await virusScanner.scan(tempPath)\n                guard isSafe else {\n                    logger.error(\"Virus detected in uploaded file\", metadata: [\n                        \"filename\": \"\\(sanitizedFilename)\"\n                    ])\n                    try await storage.deleteTempFile(tempPath)\n                    throw AppError.securityViolation(reason: \"File failed security scan\")\n                }\n            }\n            \n            // 8. Move to permanent storage\n            let permanentPath = try await storage.moveToPermStorage(tempPath, as: secureFilename)\n            \n            return FileMetadata(\n                id: UUID().uuidString,\n                filename: sanitizedFilename,\n                secureFilename: secureFilename,\n                path: permanentPath,\n                sizeBytes: bytesWritten,\n                contentType: actualContentType\n            )\n            \n        } catch {\n            // Clean up temp file on any error\n            try? await storage.deleteTempFile(tempPath)\n            throw error\n        }\n    }\n    \n    func sanitizeFilename(_ filename: String) throws -> String {\n        // Remove path separators to prevent directory traversal\n        var sanitized = filename.replacingOccurrences(of: \"/\", with: \"_\")\n        sanitized = sanitized.replacingOccurrences(of: \"\\\\\", with: \"_\")\n        sanitized = sanitized.replacingOccurrences(of: \"..\", with: \"_\")\n        \n        // Remove null bytes\n        sanitized = sanitized.replacingOccurrences(of: \"\\0\", with: \"\")\n        \n        // Limit length\n        if sanitized.count > 255 {\n            sanitized = String(sanitized.prefix(255))\n        }\n        \n        // Ensure filename is not empty after sanitization\n        guard !sanitized.isEmpty else {\n            throw AppError.invalidInput(reason: \"Invalid filename\")\n        }\n        \n        return sanitized\n    }\n    \n    func detectContentType(at path: String) async throws -> String {\n        // Read first few bytes (magic bytes) to detect actual file type\n        let magicBytes = try await storage.readBytes(at: path, count: 16)\n        \n        // Check magic bytes against known file signatures\n        if magicBytes.starts(with: [0xFF, 0xD8, 0xFF]) {\n            return \"image/jpeg\"\n        } else if magicBytes.starts(with: [0x89, 0x50, 0x4E, 0x47]) {\n            return \"image/png\"\n        } else if magicBytes.starts(with: [0x25, 0x50, 0x44, 0x46]) {\n            return \"application/pdf\"\n        }\n        // ... more magic byte checks\n        \n        return \"application/octet-stream\"\n    }\n}\n\nstruct UploadConfiguration: Sendable {\n    let maxUploadSizeBytes: Int\n    let allowedMimeTypes: Set<String>\n    let allowedExtensions: Set<String>\n    let virusScanner: (any VirusScannerProtocol)?\n}\n\n// ❌ CRITICAL VULNERABILITY — using client filename directly\nrouter.post(\"/upload\") { request, context in\n    let filename = request.headers[\"x-filename\"] ?? \"upload.bin\"\n    let path = \"/uploads/\\(filename)\" // ⚠️ DIRECTORY TRAVERSAL!\n    // Attacker sends: x-filename: ../../../../etc/passwd\n    try await storage.writeFile(path, body: request.body)\n    return Response(status: .created)\n}\n\n// ❌ CRITICAL — trusting Content-Type header without validation\nrouter.post(\"/upload\") { request, context in\n    let contentType = request.headers[.contentType] ?? \"application/octet-stream\"\n    // ⚠️ Attacker sets Content-Type: image/jpeg but uploads executable!\n    let file = try await storage.save(request.body, as: contentType)\n    return Response(status: .created)\n}\n\n// ❌ CRITICAL — no file size limit\nrouter.post(\"/upload\") { request, context in\n    // ⚠️ Attacker can fill disk with unlimited upload!\n    try await storage.save(request.body)\n    return Response(status: .created)\n}\n\n// ❌ Wrong — file extension validation only\nfunc validateFile(filename: String) -> Bool {\n    return filename.hasSuffix(\".jpg\") || filename.hasSuffix(\".png\")\n    // ⚠️ Attacker uploads malware.exe.jpg — passes validation!\n}\n```\n\nSecurity checklist:\n- ✅ Sanitize filenames (remove `../`, `/`, `\\\\`, null bytes)\n- ✅ Never use client-provided filenames for storage paths (use UUIDs)\n- ✅ Validate MIME type against allowlist (never use blocklist)\n- ✅ Validate file extension against allowlist\n- ✅ Detect actual file type from magic bytes, not extension or Content-Type header\n- ✅ Enforce maximum upload size (both Content-Length and actual bytes)\n- ✅ Store uploads outside web root (prevent direct URL access)\n- ✅ Use random filenames (UUIDs) to prevent filename collisions and guessing\n- ✅ Scan for viruses/malware if handling untrusted uploads\n- ✅ Set restrictive file permissions on upload directory\n- ✅ Rate-limit upload endpoints to prevent abuse\n- ✅ Log all upload attempts (successful and failed) for security monitoring\n- ✅ Clean up temp files on errors\n- ✅ Consider storing uploads in object storage (S3) instead of local filesystem\n\nCommon vulnerabilities:\n- Directory traversal (filename: `../../etc/passwd`)\n- Arbitrary file upload (upload `.php`, `.jsp` to execute server-side code)\n- MIME type mismatch (declare image/jpeg, upload executable)\n- Zip bombs / billion laughs (compressed files that expand to GB)\n- XXE attacks in XML/SVG uploads\n- Malware distribution (upload infected files)\n- Disk space exhaustion (unlimited upload size)\n- Path disclosure (error messages reveal filesystem structure)",
    "layer": "service",
    "patternIds": ["security", "file-upload", "input-validation"],
    "violationIds": ["directory-traversal-vulnerability", "untrusted-filename", "missing-mime-type-validation", "missing-upload-size-limit", "missing-magic-byte-validation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "error-middleware-pattern",
    "title": "Error Middleware for Centralized Error Handling",
    "content": "Error middleware catches all errors thrown by handlers and transforms them into appropriate HTTP responses. This centralizes error handling logic, ensures consistent error responses, prevents error details from leaking to clients, and provides a single point for error logging.\n\n```swift\nimport Hummingbird\nimport Logging\n\n// ✅ Correct — centralized error middleware\nstruct ErrorMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let logger: Logger\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        do {\n            return try await next(request, context)\n        } catch let error as AppError {\n            // Handle typed application errors\n            return handleAppError(error, request: request)\n        } catch let error as HTTPError {\n            // Handle Hummingbird HTTP errors\n            return handleHTTPError(error, request: request)\n        } catch {\n            // Catch any unexpected errors\n            logger.error(\"Unexpected error\", metadata: [\n                \"error\": \"\\(error)\",\n                \"path\": \"\\(request.uri.path)\",\n                \"method\": \"\\(request.method)\"\n            ])\n            return Response(\n                status: .internalServerError,\n                headers: [.contentType: \"application/json\"],\n                body: .init(data: errorJSON(\"Internal server error\", code: 500))\n            )\n        }\n    }\n\n    private func handleAppError(_ error: AppError, request: Request) -> Response {\n        let (status, message, code) = mapAppErrorToHTTP(error)\n        \n        // Log based on severity\n        switch status {\n        case .internalServerError, .serviceUnavailable:\n            logger.error(\"Application error\", metadata: [\n                \"error\": \"\\(error)\",\n                \"path\": \"\\(request.uri.path)\",\n                \"method\": \"\\(request.method)\"\n            ])\n        case .badRequest, .unauthorized, .forbidden, .notFound:\n            logger.info(\"Client error\", metadata: [\n                \"error\": \"\\(error)\",\n                \"status\": \"\\(status.code)\"\n            ])\n        default:\n            logger.warning(\"Error\", metadata: [\"error\": \"\\(error)\"])\n        }\n\n        return Response(\n            status: status,\n            headers: [.contentType: \"application/json\"],\n            body: .init(data: errorJSON(message, code: code))\n        )\n    }\n\n    private func handleHTTPError(_ error: HTTPError, request: Request) -> Response {\n        logger.info(\"HTTP error\", metadata: [\n            \"status\": \"\\(error.status.code)\",\n            \"path\": \"\\(request.uri.path)\"\n        ])\n        return Response(\n            status: error.status,\n            headers: [.contentType: \"application/json\"],\n            body: .init(data: errorJSON(\n                error.status.reasonPhrase,\n                code: Int(error.status.code)\n            ))\n        )\n    }\n\n    private func mapAppErrorToHTTP(_ error: AppError) -> (HTTPResponse.Status, String, Int) {\n        switch error {\n        case .invalidInput(let reason):\n            return (.badRequest, reason, 400)\n        case .unauthorized(let reason):\n            return (.unauthorized, reason, 401)\n        case .forbidden(let reason):\n            return (.forbidden, reason, 403)\n        case .notFound(let reason):\n            return (.notFound, reason, 404)\n        case .conflict(let reason):\n            return (.conflict, reason, 409)\n        case .validationError(let reason):\n            return (.unprocessableEntity, reason, 422)\n        case .internalError:\n            // Never expose internal error details to clients!\n            return (.internalServerError, \"Internal server error\", 500)\n        case .serviceUnavailable(let reason):\n            return (.serviceUnavailable, reason, 503)\n        }\n    }\n\n    private func errorJSON(_ message: String, code: Int) -> Data {\n        let json = \"\"\"\n        {\n            \"error\": {\n                \"message\": \"\\(message)\",\n                \"code\": \\(code)\n            }\n        }\n        \"\"\"\n        return Data(json.utf8)\n    }\n}\n\n// Register error middleware FIRST — order matters!\nrouter.add(middleware: ErrorMiddleware(logger: logger))\nrouter.add(middleware: DependencyInjectionMiddleware(dependencies: deps))\nrouter.get(\"/users/:id\") { request, context in\n    // Any error thrown here will be caught by ErrorMiddleware\n    let id = try context.parameters.require(\"id\")\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user)\n}\n\n// ❌ Wrong — error handling in every route handler\nrouter.get(\"/users/:id\") { request, context in\n    do {\n        let id = try context.parameters.require(\"id\")\n        let user = try await context.dependencies.userService.find(id: id)\n        return UserResponse(user)\n    } catch {\n        // Duplicated error handling logic!\n        return Response(\n            status: .internalServerError,\n            body: .init(string: \"Error: \\(error)\")\n        )\n    }\n}\n\n// ❌ CRITICAL — leaking internal error details\nrouter.get(\"/users/:id\") { request, context in\n    do {\n        let user = try await context.dependencies.userService.find(id: \"123\")\n        return UserResponse(user)\n    } catch {\n        // ⚠️ Exposes database connection strings, stack traces, etc!\n        return Response(\n            status: .internalServerError,\n            body: .init(string: \"Database error: \\(error)\")\n        )\n    }\n}\n\n// ❌ Wrong — inconsistent error response format\nrouter.get(\"/users/:id\") { request, context in\n    guard let user = try? await context.dependencies.userService.find(id: \"123\") else {\n        return Response(status: .notFound, body: .init(string: \"Not found\"))\n    }\n    return UserResponse(user)\n}\n\nrouter.get(\"/posts/:id\") { request, context in\n    guard let post = try? await context.dependencies.postService.find(id: \"123\") else {\n        // Different format from /users/:id!\n        return Response(\n            status: .notFound,\n            headers: [.contentType: \"application/json\"],\n            body: .init(string: \"{\\\"error\\\":\\\"Post not found\\\"}\")\n        )\n    }\n    return PostResponse(post)\n}\n```\n\nBest practices:\n- Add error middleware FIRST in the middleware chain\n- Map all AppError cases to appropriate HTTP status codes\n- Return consistent JSON error format across all endpoints\n- Log errors with appropriate severity (error vs warning vs info)\n- Never expose internal error details (database errors, stack traces) to clients\n- Include request metadata in error logs (path, method, user ID)\n- Use structured logging (Logger.Metadata) for searchability\n- Return user-friendly error messages\n- Consider adding error tracking integration (Sentry, Rollbar)\n- Test error responses in integration tests",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "error-handling", "centralized-error-handling"],
    "violationIds": ["inline-error-handling", "error-detail-leakage", "inconsistent-error-responses"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "cors-middleware-pattern",
    "title": "CORS Middleware Pattern",
    "content": "CORS (Cross-Origin Resource Sharing) middleware handles preflight OPTIONS requests and adds appropriate CORS headers to responses. Configure allowed origins, methods, headers, and credentials policy. Never use wildcard (`*`) origins with credentials, and always validate origins against an allowlist in production.\n\n```swift\nimport Hummingbird\nimport HTTPTypes\n\n// ✅ Correct — production-ready CORS middleware\nstruct CORSMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    private let config: CORSConfiguration\n\n    init(config: CORSConfiguration) {\n        self.config = config\n    }\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Handle preflight OPTIONS request\n        if request.method == .options {\n            return handlePreflight(request: request)\n        }\n\n        // Process actual request and add CORS headers to response\n        var response = try await next(request, context)\n        response = addCORSHeaders(to: response, for: request)\n        return response\n    }\n\n    private func handlePreflight(request: Request) -> Response {\n        var headers: HTTPFields = [:]\n\n        // Validate origin\n        if let origin = request.headers[HTTPField.Name(\"origin\")!],\n           isOriginAllowed(origin) {\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = origin\n\n            if config.allowCredentials {\n                headers[HTTPField.Name(\"access-control-allow-credentials\")!] = \"true\"\n            }\n        } else if config.allowedOrigins.contains(\"*\") {\n            // Wildcard only if credentials not allowed\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n        }\n\n        // Add allowed methods\n        let allowedMethods = config.allowedMethods.map { $0.rawValue }.joined(separator: \", \")\n        headers[HTTPField.Name(\"access-control-allow-methods\")!] = allowedMethods\n\n        // Add allowed headers\n        if !config.allowedHeaders.isEmpty {\n            let allowedHeaders = config.allowedHeaders.joined(separator: \", \")\n            headers[HTTPField.Name(\"access-control-allow-headers\")!] = allowedHeaders\n        }\n\n        // Add max age for preflight cache\n        if let maxAge = config.maxAge {\n            headers[HTTPField.Name(\"access-control-max-age\")!] = \"\\(maxAge)\"\n        }\n\n        return Response(status: .noContent, headers: headers)\n    }\n\n    private func addCORSHeaders(to response: Response, for request: Request) -> Response {\n        var headers = response.headers\n\n        // Validate and set origin\n        if let origin = request.headers[HTTPField.Name(\"origin\")!],\n           isOriginAllowed(origin) {\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = origin\n\n            if config.allowCredentials {\n                headers[HTTPField.Name(\"access-control-allow-credentials\")!] = \"true\"\n            }\n        } else if config.allowedOrigins.contains(\"*\") {\n            headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n        }\n\n        // Add exposed headers\n        if !config.exposedHeaders.isEmpty {\n            let exposedHeaders = config.exposedHeaders.joined(separator: \", \")\n            headers[HTTPField.Name(\"access-control-expose-headers\")!] = exposedHeaders\n        }\n\n        return Response(\n            status: response.status,\n            headers: headers,\n            body: response.body\n        )\n    }\n\n    private func isOriginAllowed(_ origin: String) -> Bool {\n        if config.allowedOrigins.contains(\"*\") {\n            return true\n        }\n        return config.allowedOrigins.contains(origin)\n    }\n}\n\n// CORS configuration\nstruct CORSConfiguration: Sendable {\n    let allowedOrigins: Set<String>\n    let allowedMethods: Set<HTTPRequest.Method>\n    let allowedHeaders: Set<String>\n    let exposedHeaders: Set<String>\n    let allowCredentials: Bool\n    let maxAge: Int?\n\n    // Production configuration — explicit origin allowlist\n    static func production(allowedOrigins: Set<String>) -> CORSConfiguration {\n        CORSConfiguration(\n            allowedOrigins: allowedOrigins,\n            allowedMethods: [.get, .post, .put, .patch, .delete, .options],\n            allowedHeaders: [\"content-type\", \"authorization\", \"x-requested-with\"],\n            exposedHeaders: [\"content-length\", \"content-type\"],\n            allowCredentials: true,\n            maxAge: 3600\n        )\n    }\n\n    // Development configuration — allow all origins (use only in development!)\n    static var development: CORSConfiguration {\n        CORSConfiguration(\n            allowedOrigins: [\"*\"],\n            allowedMethods: [.get, .post, .put, .patch, .delete, .options],\n            allowedHeaders: [\"*\"],\n            exposedHeaders: [],\n            allowCredentials: false,  // Cannot use credentials with wildcard origin\n            maxAge: 3600\n        )\n    }\n}\n\n// ✅ Correct — production usage with explicit origins\nlet corsConfig = CORSConfiguration.production(allowedOrigins: [\n    \"https://app.example.com\",\n    \"https://admin.example.com\"\n])\nrouter.add(middleware: CORSMiddleware(config: corsConfig))\n\n// ✅ Correct — development usage (localhost only)\n#if DEBUG\nlet corsConfig = CORSConfiguration.development\nrouter.add(middleware: CORSMiddleware(config: corsConfig))\n#endif\n\n// ❌ CRITICAL SECURITY ISSUE — wildcard origin with credentials\nlet badConfig = CORSConfiguration(\n    allowedOrigins: [\"*\"],\n    allowedMethods: [.get, .post],\n    allowedHeaders: [\"*\"],\n    exposedHeaders: [],\n    allowCredentials: true,  // ⚠️ SECURITY VULNERABILITY!\n    maxAge: 3600\n)\n// This allows ANY website to make authenticated requests to your API!\n\n// ❌ Wrong — no origin validation\nstruct BadCORSMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var response = try await next(request, context)\n        \n        // ⚠️ Reflects any origin without validation!\n        if let origin = request.headers[HTTPField.Name(\"origin\")!] {\n            response.headers[HTTPField.Name(\"access-control-allow-origin\")!] = origin\n            response.headers[HTTPField.Name(\"access-control-allow-credentials\")!] = \"true\"\n        }\n        \n        return response\n    }\n}\n\n// ❌ Wrong — hardcoded CORS headers in every handler\nrouter.get(\"/api/data\") { request, context in\n    var response = Response(status: .ok, body: .init(string: \"data\"))\n    response.headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n    return response\n}\n\n// ❌ Wrong — missing preflight handling\nstruct IncompleteCORSMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var response = try await next(request, context)\n        response.headers[HTTPField.Name(\"access-control-allow-origin\")!] = \"*\"\n        return response\n        // ⚠️ No preflight OPTIONS handling — CORS will fail for many requests!\n    }\n}\n```\n\nKey points:\n- CORS middleware must handle both preflight OPTIONS requests and actual requests\n- Preflight responses return 204 No Content with CORS headers\n- Actual responses get CORS headers added before returning\n- Never use wildcard (`*`) origin with `allowCredentials: true` — major security risk\n- Always validate Origin header against an allowlist in production\n- Include `Access-Control-Max-Age` to cache preflight responses (reduces OPTIONS traffic)\n- Use `Access-Control-Expose-Headers` to allow JavaScript access to response headers\n- Order matters: add CORS middleware early in the chain (after error middleware)\n- For APIs serving public data, wildcard origin is acceptable (without credentials)\n- For APIs with authentication, use explicit origin allowlist\n\nCommon mistakes:\n- Reflecting any origin without validation (security vulnerability)\n- Using wildcard origin with credentials enabled (forbidden by CORS spec)\n- Missing preflight OPTIONS handling (causes CORS failures)\n- Hardcoding CORS headers in route handlers (duplication)\n- Not including necessary headers in allowedHeaders (causes preflight rejection)\n- Setting overly permissive CORS in production (use explicit allowlist)\n\nSecurity considerations:\n- CORS is a browser security feature — it does not prevent direct API calls (use authentication)\n- Validate origins against allowlist, never reflect request origin blindly\n- Use HTTPS for all CORS-enabled endpoints (prevent MITM attacks)\n- Keep allowedOrigins as restrictive as possible\n- Review CORS configuration regularly as part of security audits\n- Monitor for unauthorized cross-origin requests",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "cors", "security", "preflight-handling"],
    "violationIds": ["wildcard-origin-with-credentials", "missing-origin-validation", "missing-preflight-handling", "cors-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "postgresnio-integration",
    "title": "PostgresNIO Database Integration Pattern",
    "content": "PostgresNIO is the official SSWG database driver for PostgreSQL with lowest overhead and full async/await support. Always use parameterized queries, properly size connection pools, implement the repository pattern for data access, and handle errors appropriately.\n\n```swift\nimport PostgresNIO\nimport Logging\nimport NIOCore\n\n// ✅ Correct — connection pool setup with proper sizing\nstruct DatabaseConfiguration: Sendable {\n    let host: String\n    let port: Int\n    let username: String\n    let password: String\n    let database: String\n    let maxConnections: Int\n    \n    static func fromEnvironment() throws -> DatabaseConfiguration {\n        guard let host = ProcessInfo.processInfo.environment[\"DB_HOST\"],\n              let username = ProcessInfo.processInfo.environment[\"DB_USER\"],\n              let password = ProcessInfo.processInfo.environment[\"DB_PASSWORD\"],\n              let database = ProcessInfo.processInfo.environment[\"DB_NAME\"] else {\n            throw AppError.configurationError(reason: \"Missing database environment variables\")\n        }\n        \n        let port = Int(ProcessInfo.processInfo.environment[\"DB_PORT\"] ?? \"5432\") ?? 5432\n        \n        // Rule of thumb: (num_cpu_cores × 2) + num_spindle_disks\n        // For cloud databases, check max_connections limit\n        let cpuCount = System.coreCount\n        let maxConnections = (cpuCount * 2) + 1\n        \n        return DatabaseConfiguration(\n            host: host,\n            port: port,\n            username: username,\n            password: password,\n            database: database,\n            maxConnections: min(maxConnections, 20) // Leave headroom for other services\n        )\n    }\n}\n\nfunc createPostgresPool(\n    config: DatabaseConfiguration,\n    eventLoopGroup: EventLoopGroup,\n    logger: Logger\n) -> PostgresClient {\n    let postgresConfig = PostgresClient.Configuration(\n        host: config.host,\n        port: config.port,\n        username: config.username,\n        password: config.password,\n        database: config.database,\n        tls: .prefer(try! .makeClientConfiguration()) // Use TLS in production\n    )\n    \n    return PostgresClient(\n        configuration: postgresConfig,\n        eventLoopGroupProvider: .shared(eventLoopGroup),\n        backgroundLogger: logger\n    )\n}\n\n// ✅ Correct — parameterized queries with \\(variable) interpolation\nstruct PostgresUserRepository: UserRepositoryProtocol {\n    let pool: PostgresClient\n    let logger: Logger\n    \n    func find(id: UUID) async throws -> User? {\n        // The \\(id) interpolation creates a BIND PARAMETER, not string substitution\n        let rows = try await pool.query(\n            \"SELECT id, email, name, created_at FROM users WHERE id = \\(id)\",\n            logger: logger\n        )\n        \n        // Decode first row\n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            return User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            )\n        }\n        \n        return nil\n    }\n    \n    func findAll(limit: Int, offset: Int) async throws -> [User] {\n        // Multiple parameters — all type-safe and SQL-injection proof\n        let rows = try await pool.query(\n            \"SELECT id, email, name, created_at FROM users ORDER BY created_at DESC LIMIT \\(limit) OFFSET \\(offset)\",\n            logger: logger\n        )\n        \n        var users: [User] = []\n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            users.append(User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            ))\n        }\n        \n        return users\n    }\n    \n    func insert(_ user: User) async throws -> User {\n        let rows = try await pool.query(\n            \"\"\"\n            INSERT INTO users (id, email, name, created_at)\n            VALUES (\\(user.id), \\(user.email), \\(user.name), \\(user.createdAt))\n            RETURNING id, email, name, created_at\n            \"\"\",\n            logger: logger\n        )\n        \n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            return User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            )\n        }\n        \n        throw AppError.internalError(reason: \"Failed to insert user\")\n    }\n    \n    func update(_ user: User) async throws -> User {\n        let rows = try await pool.query(\n            \"\"\"\n            UPDATE users\n            SET email = \\(user.email), name = \\(user.name)\n            WHERE id = \\(user.id)\n            RETURNING id, email, name, created_at\n            \"\"\",\n            logger: logger\n        )\n        \n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            return User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            )\n        }\n        \n        throw AppError.notFound(reason: \"User not found\")\n    }\n    \n    func delete(id: UUID) async throws {\n        _ = try await pool.query(\n            \"DELETE FROM users WHERE id = \\(id)\",\n            logger: logger\n        )\n    }\n    \n    // Complex query with multiple conditions\n    func search(query: String, isActive: Bool) async throws -> [User] {\n        let searchPattern = \"%\\(query)%\"\n        let rows = try await pool.query(\n            \"\"\"\n            SELECT id, email, name, created_at\n            FROM users\n            WHERE (email ILIKE \\(searchPattern) OR name ILIKE \\(searchPattern))\n              AND is_active = \\(isActive)\n            ORDER BY created_at DESC\n            \"\"\",\n            logger: logger\n        )\n        \n        var users: [User] = []\n        for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n            users.append(User(\n                id: id,\n                email: email,\n                name: name,\n                createdAt: createdAt\n            ))\n        }\n        \n        return users\n    }\n}\n\n// ✅ Correct — repository protocol for testability\nprotocol UserRepositoryProtocol: Sendable {\n    func find(id: UUID) async throws -> User?\n    func findAll(limit: Int, offset: Int) async throws -> [User]\n    func insert(_ user: User) async throws -> User\n    func update(_ user: User) async throws -> User\n    func delete(id: UUID) async throws\n    func search(query: String, isActive: Bool) async throws -> [User]\n}\n\n// ✅ Correct — error wrapping at repository boundary\nstruct PostgresUserRepositoryWithErrorWrapping: UserRepositoryProtocol {\n    let pool: PostgresClient\n    let logger: Logger\n    \n    func find(id: UUID) async throws -> User? {\n        do {\n            let rows = try await pool.query(\n                \"SELECT id, email, name, created_at FROM users WHERE id = \\(id)\",\n                logger: logger\n            )\n            \n            for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n                return User(id: id, email: email, name: name, createdAt: createdAt)\n            }\n            \n            return nil\n        } catch let error as PostgresError {\n            // Wrap database errors at the boundary\n            logger.error(\"Database error in find\", metadata: [\n                \"error\": \"\\(error)\",\n                \"userId\": \"\\(id)\"\n            ])\n            throw AppError.internalError(reason: \"Database query failed\")\n        }\n    }\n    \n    // ... other methods with similar error wrapping\n}\n\n// ✅ Correct — transaction support\nextension PostgresUserRepository {\n    func createUserWithProfile(\n        user: User,\n        profile: UserProfile\n    ) async throws -> (User, UserProfile) {\n        // Use withConnection for transactions\n        return try await pool.withConnection { connection in\n            // Begin transaction\n            try await connection.query(\"BEGIN\", logger: logger)\n            \n            do {\n                // Insert user\n                let userRows = try await connection.query(\n                    \"INSERT INTO users (id, email, name, created_at) VALUES (\\(user.id), \\(user.email), \\(user.name), \\(user.createdAt)) RETURNING id, email, name, created_at\",\n                    logger: logger\n                )\n                \n                var insertedUser: User? = nil\n                for try await (id, email, name, createdAt) in userRows.decode((UUID, String, String, Date).self) {\n                    insertedUser = User(id: id, email: email, name: name, createdAt: createdAt)\n                    break\n                }\n                \n                guard let user = insertedUser else {\n                    throw AppError.internalError(reason: \"Failed to insert user\")\n                }\n                \n                // Insert profile\n                let profileRows = try await connection.query(\n                    \"INSERT INTO user_profiles (user_id, bio, avatar_url) VALUES (\\(user.id), \\(profile.bio), \\(profile.avatarUrl)) RETURNING user_id, bio, avatar_url\",\n                    logger: logger\n                )\n                \n                var insertedProfile: UserProfile? = nil\n                for try await (userId, bio, avatarUrl) in profileRows.decode((UUID, String, String?).self) {\n                    insertedProfile = UserProfile(userId: userId, bio: bio, avatarUrl: avatarUrl)\n                    break\n                }\n                \n                guard let profile = insertedProfile else {\n                    throw AppError.internalError(reason: \"Failed to insert profile\")\n                }\n                \n                // Commit transaction\n                try await connection.query(\"COMMIT\", logger: logger)\n                \n                return (user, profile)\n            } catch {\n                // Rollback on error\n                try await connection.query(\"ROLLBACK\", logger: logger)\n                throw error\n            }\n        }\n    }\n}\n\n// ❌ CRITICAL SECURITY VULNERABILITY — string concatenation instead of parameterization\nfunc findUserByEmailUNSAFE(email: String) async throws -> User? {\n    // ⚠️ SQL INJECTION VULNERABILITY!\n    // If email = \"' OR '1'='1\", this returns all users!\n    let query = \"SELECT * FROM users WHERE email = '\\(email)'\"\n    let rows = try await pool.query(query, logger: logger)\n    // ...\n}\n\n// ❌ Wrong — using string interpolation instead of PostgresNIO's bind interpolation\nfunc findUserWrong(id: UUID) async throws -> User? {\n    // This looks like parameterization but it's NOT!\n    // Must use pool.query() with \\(variable) inside the query string\n    let query = \"SELECT * FROM users WHERE id = '\\(id.uuidString)'\"\n    let rows = try await pool.query(query, logger: logger)\n    // ...\n}\n\n// ❌ Wrong — excessive connection pool size\nlet badConfig = DatabaseConfiguration(\n    host: \"localhost\",\n    port: 5432,\n    username: \"user\",\n    password: \"pass\",\n    database: \"mydb\",\n    maxConnections: 200 // ⚠️ Will exhaust database max_connections!\n)\n// PostgreSQL default max_connections is 100 — running multiple app instances\n// will hit the limit and cause connection failures\n\n// ❌ Wrong — not using connection pool (creating new connection per query)\nfunc findUserNonPooled(id: UUID) async throws -> User? {\n    let connection = try await PostgresConnection.connect(\n        configuration: .init(\n            host: \"localhost\",\n            port: 5432,\n            username: \"user\",\n            password: \"pass\",\n            database: \"mydb\"\n        ),\n        id: 1,\n        logger: logger\n    )\n    defer { try? await connection.close() }\n    \n    let rows = try await connection.query(\n        \"SELECT id, email, name, created_at FROM users WHERE id = \\(id)\",\n        logger: logger\n    )\n    // ... ⚠️ Connection overhead on every query!\n}\n\n// ❌ Wrong — blocking decode pattern\nfunc findAllUsersBlocking() async throws -> [User] {\n    let rows = try await pool.query(\n        \"SELECT id, email, name, created_at FROM users\",\n        logger: logger\n    )\n    \n    // ⚠️ collect() buffers all rows in memory!\n    let allRows = try await rows.collect()\n    \n    return try allRows.map { row in\n        try row.decode((UUID, String, String, Date).self)\n    }.map { (id, email, name, createdAt) in\n        User(id: id, email: email, name: name, createdAt: createdAt)\n    }\n}\n\n// ✅ Correct — streaming decode pattern (memory efficient)\nfunc findAllUsersStreaming() async throws -> [User] {\n    let rows = try await pool.query(\n        \"SELECT id, email, name, created_at FROM users\",\n        logger: logger\n    )\n    \n    var users: [User] = []\n    // Process rows as they arrive — memory efficient\n    for try await (id, email, name, createdAt) in rows.decode((UUID, String, String, Date).self) {\n        users.append(User(id: id, email: email, name: name, createdAt: createdAt))\n    }\n    \n    return users\n}\n\n// ❌ Wrong — repository in route handler (not via dependencies)\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\", as: UUID.self)\n    \n    // ⚠️ Direct repository construction in handler!\n    let repo = PostgresUserRepository(pool: globalPool, logger: context.logger)\n    let user = try await repo.find(id: id)\n    \n    guard let user = user else {\n        throw HTTPError(.notFound)\n    }\n    \n    return UserResponse(user)\n}\n\n// ✅ Correct — repository via dependencies\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\", as: UUID.self)\n    let user = try await context.dependencies.userService.find(id: id)\n    return UserResponse(user)\n}\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n    \n    func find(id: UUID) async throws -> User {\n        guard let user = try await repository.find(id: id) else {\n            throw AppError.notFound(reason: \"User not found\")\n        }\n        return user\n    }\n}\n```\n\nKey points:\n- PostgresNIO's `\\(variable)` interpolation creates bind parameters (NOT string substitution)\n- Never build queries with string concatenation — always use parameterized queries\n- Connection pool sizing: `(num_cpu_cores × 2) + num_spindle_disks`\n- Watch PostgreSQL's `max_connections` limit (default 100)\n- Use PgBouncer or connection pooler in production\n- Always use the repository pattern — never call PostgresNIO directly from handlers\n- Decode rows with `for try await` for memory efficiency (don't use `.collect()`)\n- Wrap database errors at repository boundary into `AppError`\n- Use transactions with `withConnection` for multi-statement operations\n- Always use connection pooling (PostgresClient), never create connections per-query\n- Include logger in all queries for observability\n- Use TLS/SSL for production database connections\n\nCommon pitfalls:\n- String concatenation instead of parameterization (SQL injection vulnerability)\n- Excessive pool size exhausting `max_connections`\n- Creating connections per-query instead of using pool (performance issue)\n- Buffering all rows with `.collect()` (memory issue for large result sets)\n- Not wrapping database errors (leaks implementation details)\n- Direct database calls in handlers (violates clean architecture)\n- Missing transaction rollback on errors (data corruption risk)",
    "layer": "repository",
    "patternIds": ["database-integration", "repository-pattern", "parameterized-queries", "connection-pooling", "async-queries"],
    "violationIds": ["sql-injection", "string-concatenation-in-query", "excessive-pool-size", "missing-connection-pool", "repository-in-handler", "blocking-decode-pattern"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "bearer-token-auth-middleware",
    "title": "Bearer Token Authentication Middleware",
    "content": "Authentication via bearer token is implemented as RouterMiddleware that validates the Authorization header before passing requests to downstream handlers. Infrastructure endpoints like /health and /ready must always be exempt so that load balancers and orchestrators can probe without credentials.\n\n```swift\nimport Hummingbird\nimport Logging\n\n// ✅ Correct — Bearer token middleware with exempt paths\nstruct AuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n\n    private let token: String\n\n    init(token: String) {\n        self.token = token\n    }\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Always exempt infrastructure endpoints\n        let path = request.uri.path\n        guard path != \"/health\", path != \"/ready\" else {\n            return try await next(request, context)\n        }\n\n        guard\n            let header = request.headers[.authorization],\n            header.hasPrefix(\"Bearer \"),\n            String(header.dropFirst(7)) == token\n        else {\n            context.logger.warning(\n                \"Rejected unauthenticated request\",\n                metadata: [\"path\": \"\\(path)\", \"method\": \"\\(request.method)\"]\n            )\n            throw HTTPError(\n                .unauthorized,\n                message: \"Valid Bearer token required. Set Authorization: Bearer <token>\"\n            )\n        }\n\n        return try await next(request, context)\n    }\n}\n\n// ✅ Correct — conditional middleware registration\nfunc buildRouter(dependencies: AppDependencies) -> Router<AppRequestContext> {\n    let router = Router(context: AppRequestContext.self)\n    \n    // Add DI middleware first\n    router.add(middleware: DependencyInjectionMiddleware(dependencies: dependencies))\n    \n    // Only add auth middleware if MCP_AUTH_TOKEN is set\n    if let token = ProcessInfo.processInfo.environment[\"MCP_AUTH_TOKEN\"], !token.isEmpty {\n        router.add(middleware: AuthMiddleware(token: token))\n    }\n    \n    // Register routes\n    router.get(\"/health\") { _, _ in Response(status: .ok) }\n    router.get(\"/ready\") { _, _ in Response(status: .ok) }\n    router.post(\"/mcp\") { request, context in\n        // This endpoint requires auth when MCP_AUTH_TOKEN is set\n        try await context.dependencies.mcpService.handle(request)\n    }\n    \n    return router\n}\n\n// ❌ Wrong — hardcoded token in source\nstruct BadAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    let token = \"super-secret-token\" // ⚠️ SECURITY BREACH!\n    \n    func handle(...) async throws -> Response {\n        guard request.headers[.authorization] == \"Bearer \\(token)\" else {\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// ❌ Wrong — missing exempt paths (breaks load balancer health checks)\nstruct OverlyStrictAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n    \n    func handle(...) async throws -> Response {\n        // ⚠️ No exempt paths — /health and /ready require auth!\n        guard request.headers[.authorization] == \"Bearer \\(token)\" else {\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// ❌ Wrong — silent failure (no logging)\nstruct SilentAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n    \n    func handle(...) async throws -> Response {\n        guard request.headers[.authorization] == \"Bearer \\(token)\" else {\n            // ⚠️ No logging — impossible to debug failed auth attempts!\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// ❌ Wrong — incorrect header parsing\nstruct BrokenHeaderParsingMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n    \n    func handle(...) async throws -> Response {\n        // ⚠️ Doesn't check \"Bearer \" prefix!\n        let header = request.headers[.authorization] ?? \"\"\n        guard header == token else { // Should be \"Bearer <token>\"\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n```\n\nKey requirements:\n- Always exempt /health and /ready for infrastructure probes\n- Load token from environment variable, never hardcode\n- Log all rejected requests with path and method for security auditing\n- Verify \"Bearer \" prefix and extract token correctly\n- Return descriptive error message for debugging\n- Only add middleware when auth token is configured (zero overhead for local dev)\n- Middleware ordering: DI middleware must come before auth middleware",
    "layer": "middleware",
    "patternIds": ["bearer-token-auth", "auth-middleware", "conditional-middleware", "exempt-paths"],
    "violationIds": ["hardcoded-auth-token", "missing-health-check-exemption", "missing-auth-logging", "incorrect-bearer-parsing"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "jwt-authentication-pattern",
    "title": "JWT Authentication and Validation",
    "content": "JSON Web Tokens (JWT) provide stateless authentication. Use a JWT library (JWTKit or swift-jwt) to verify signatures, validate claims (exp, iat, iss, aud), and extract user identity. Never trust JWT payloads without signature verification.\n\n```swift\nimport Hummingbird\nimport JWTKit\nimport Foundation\n\n// ✅ Correct — JWT validation middleware with claim verification\nstruct JWTAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    private let signers: JWTSigners\n    \n    init(signers: JWTSigners) {\n        self.signers = signers\n    }\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Exempt infrastructure endpoints\n        let path = request.uri.path\n        guard path != \"/health\", path != \"/ready\" else {\n            return try await next(request, context)\n        }\n        \n        // Extract Bearer token\n        guard let header = request.headers[.authorization],\n              header.hasPrefix(\"Bearer \"),\n              !header.isEmpty else {\n            context.logger.warning(\"Missing or malformed Authorization header\")\n            throw HTTPError(.unauthorized, message: \"JWT token required\")\n        }\n        \n        let token = String(header.dropFirst(7))\n        \n        do {\n            // Verify signature and decode claims\n            let payload = try signers.verify(token, as: JWTPayload.self)\n            \n            // Validate expiration\n            guard payload.exp.value > Date() else {\n                context.logger.warning(\"Expired JWT token\", metadata: [\"sub\": \"\\(payload.sub.value)\"])\n                throw HTTPError(.unauthorized, message: \"Token expired\")\n            }\n            \n            // Inject user context\n            var ctx = context\n            ctx.userID = payload.sub.value\n            ctx.userEmail = payload.email\n            \n            context.logger.info(\n                \"Authenticated request\",\n                metadata: [\"userId\": \"\\(payload.sub.value)\", \"path\": \"\\(path)\"]\n            )\n            \n            return try await next(request, ctx)\n        } catch let jwtError as JWTError {\n            context.logger.warning(\"JWT validation failed\", metadata: [\"error\": \"\\(jwtError)\"])\n            throw HTTPError(.unauthorized, message: \"Invalid token\")\n        }\n    }\n}\n\n// JWT payload structure\nstruct JWTPayload: JWTPayload {\n    let sub: SubjectClaim  // User ID\n    let email: String\n    let exp: ExpirationClaim\n    let iat: IssuedAtClaim\n    let iss: IssuerClaim\n    \n    func verify(using signer: JWTSigner) throws {\n        // Verify expiration\n        try exp.verifyNotExpired()\n    }\n}\n\n// ✅ Correct — JWT signing for token generation\nstruct AuthService {\n    let signers: JWTSigners\n    let issuer: String\n    let tokenLifetime: TimeInterval\n    \n    func generateToken(for user: User) throws -> String {\n        let payload = JWTPayload(\n            sub: SubjectClaim(value: user.id.uuidString),\n            email: user.email,\n            exp: ExpirationClaim(value: Date().addingTimeInterval(tokenLifetime)),\n            iat: IssuedAtClaim(value: Date()),\n            iss: IssuerClaim(value: issuer)\n        )\n        \n        return try signers.sign(payload)\n    }\n}\n\n// ✅ Correct — JWT configuration from environment\nstruct JWTConfiguration: Sendable {\n    let secret: String\n    let issuer: String\n    let tokenLifetime: TimeInterval\n    \n    static func fromEnvironment() throws -> JWTConfiguration {\n        guard let secret = ProcessInfo.processInfo.environment[\"JWT_SECRET\"],\n              !secret.isEmpty else {\n            throw AppError.configurationError(reason: \"JWT_SECRET not set\")\n        }\n        \n        guard secret.count >= 32 else {\n            throw AppError.configurationError(reason: \"JWT_SECRET must be at least 32 characters\")\n        }\n        \n        let issuer = ProcessInfo.processInfo.environment[\"JWT_ISSUER\"] ?? \"hummingbird-app\"\n        let lifetime = TimeInterval(ProcessInfo.processInfo.environment[\"JWT_LIFETIME\"] ?? \"3600\") ?? 3600\n        \n        return JWTConfiguration(\n            secret: secret,\n            issuer: issuer,\n            tokenLifetime: lifetime\n        )\n    }\n    \n    func createSigners() throws -> JWTSigners {\n        let signers = JWTSigners()\n        try signers.use(.hs256(key: secret))\n        return signers\n    }\n}\n\n// ❌ CRITICAL VULNERABILITY — no signature verification\nfunc decodeJWTUnsafe(token: String) throws -> JWTPayload {\n    // ⚠️ Decodes JWT without verifying signature!\n    // Attacker can forge any payload and it will be trusted!\n    let parts = token.split(separator: \".\")\n    guard parts.count == 3 else {\n        throw AppError.invalidInput(reason: \"Malformed JWT\")\n    }\n    \n    let payloadData = Data(base64Encoded: String(parts[1])) ?? Data()\n    return try JSONDecoder().decode(JWTPayload.self, from: payloadData)\n}\n\n// ❌ Wrong — weak secret\nlet weakJWTConfig = JWTConfiguration(\n    secret: \"secret123\", // ⚠️ Too short and predictable!\n    issuer: \"app\",\n    tokenLifetime: 3600\n)\n\n// ❌ Wrong — no expiration validation\nstruct NoExpirationCheckMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let signers: JWTSigners\n    \n    func handle(...) async throws -> Response {\n        let token = extractToken(from: request)\n        let payload = try signers.verify(token, as: JWTPayload.self)\n        \n        // ⚠️ No exp claim validation — tokens never expire!\n        var ctx = context\n        ctx.userID = payload.sub.value\n        return try await next(request, ctx)\n    }\n}\n\n// ❌ Wrong — excessive token lifetime\nlet badConfig = JWTConfiguration(\n    secret: \"properly-long-secret-key-12345\",\n    issuer: \"app\",\n    tokenLifetime: 86400 * 365 // ⚠️ 1 year! If compromised, valid for a year!\n)\n\n// ❌ Wrong — missing issuer/audience validation\nstruct MissingClaimValidationMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let signers: JWTSigners\n    \n    func handle(...) async throws -> Response {\n        let token = extractToken(from: request)\n        let payload = try signers.verify(token, as: JWTPayload.self)\n        \n        // ⚠️ No iss/aud validation — accepts tokens from any issuer!\n        try payload.exp.verifyNotExpired()\n        \n        var ctx = context\n        ctx.userID = payload.sub.value\n        return try await next(request, ctx)\n    }\n}\n```\n\nKey requirements:\n- Always verify JWT signature before trusting payload\n- Validate exp (expiration), iat (issued at), iss (issuer), aud (audience) claims\n- Use strong secrets (minimum 32 characters, cryptographically random)\n- Set reasonable token lifetime (1 hour is typical, never more than 24 hours)\n- Log all authentication events (success and failure) with user ID\n- Inject authenticated user context for downstream handlers\n- Use HMAC-SHA256 (HS256) for symmetric keys or RSA (RS256) for asymmetric\n- Store JWT secret in environment variable, never hardcode\n- Implement token refresh mechanism for long-lived sessions\n\nCommon vulnerabilities:\n- Decoding JWT without signature verification (critical security breach)\n- Weak or short secrets (enables brute force attacks)\n- No expiration validation (tokens never expire)\n- Missing issuer/audience validation (accepts forged tokens)\n- Excessive token lifetime (increases compromise window)\n- Hardcoded secrets in source code",
    "layer": "middleware",
    "patternIds": ["jwt-auth", "stateless-auth", "token-validation", "claims-verification"],
    "violationIds": ["jwt-no-signature-verification", "jwt-weak-secret", "jwt-no-expiration-check", "jwt-excessive-lifetime", "jwt-missing-claim-validation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "session-based-authentication",
    "title": "Session-Based Authentication with Stateful Sessions",
    "content": "Session-based authentication stores session state server-side (in memory, Redis, or database) and uses a session ID cookie to identify users. Sessions are stateful but can be invalidated immediately and support complex session data beyond what fits in a JWT.\n\n```swift\nimport Hummingbird\nimport Foundation\n\n// ✅ Correct — session store with actor protection\nactor SessionStore {\n    private var sessions: [String: Session] = [:]\n    private let sessionLifetime: TimeInterval\n    \n    init(sessionLifetime: TimeInterval = 3600) {\n        self.sessionLifetime = sessionLifetime\n    }\n    \n    func create(userID: UUID) -> Session {\n        let session = Session(\n            id: UUID().uuidString,\n            userID: userID,\n            createdAt: Date(),\n            expiresAt: Date().addingTimeInterval(sessionLifetime)\n        )\n        sessions[session.id] = session\n        return session\n    }\n    \n    func get(id: String) -> Session? {\n        guard let session = sessions[id] else {\n            return nil\n        }\n        \n        // Check expiration\n        guard session.expiresAt > Date() else {\n            sessions.removeValue(forKey: id)\n            return nil\n        }\n        \n        return session\n    }\n    \n    func delete(id: String) {\n        sessions.removeValue(forKey: id)\n    }\n    \n    func extend(id: String) {\n        guard var session = sessions[id] else { return }\n        session.expiresAt = Date().addingTimeInterval(sessionLifetime)\n        sessions[id] = session\n    }\n    \n    func cleanup() {\n        let now = Date()\n        sessions = sessions.filter { $0.value.expiresAt > now }\n    }\n}\n\nstruct Session: Sendable {\n    let id: String\n    let userID: UUID\n    let createdAt: Date\n    var expiresAt: Date\n}\n\n// ✅ Correct — session authentication middleware\nstruct SessionAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    private let sessionStore: SessionStore\n    \n    init(sessionStore: SessionStore) {\n        self.sessionStore = sessionStore\n    }\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Exempt infrastructure and auth endpoints\n        let path = request.uri.path\n        guard path != \"/health\",\n              path != \"/ready\",\n              path != \"/login\",\n              path != \"/register\" else {\n            return try await next(request, context)\n        }\n        \n        // Extract session ID from cookie\n        guard let sessionID = request.cookies[\"session_id\"]?.value else {\n            context.logger.warning(\"No session cookie\", metadata: [\"path\": \"\\(path)\"])\n            throw HTTPError(.unauthorized, message: \"Authentication required\")\n        }\n        \n        // Validate session\n        guard let session = await sessionStore.get(id: sessionID) else {\n            context.logger.warning(\n                \"Invalid or expired session\",\n                metadata: [\"sessionId\": \"\\(sessionID)\", \"path\": \"\\(path)\"]\n            )\n            throw HTTPError(.unauthorized, message: \"Session expired\")\n        }\n        \n        // Extend session on activity\n        await sessionStore.extend(id: sessionID)\n        \n        // Inject user context\n        var ctx = context\n        ctx.userID = session.userID.uuidString\n        ctx.sessionID = session.id\n        \n        context.logger.info(\n            \"Authenticated request\",\n            metadata: [\"userId\": \"\\(session.userID)\", \"path\": \"\\(path)\"]\n        )\n        \n        return try await next(request, ctx)\n    }\n}\n\n// ✅ Correct — login handler that creates session\nrouter.post(\"/login\") { request, context in\n    struct LoginRequest: Decodable {\n        let email: String\n        let password: String\n    }\n    \n    let req = try await request.decode(as: LoginRequest.self, context: context)\n    \n    // Validate credentials\n    let user = try await context.dependencies.authService.authenticate(\n        email: req.email,\n        password: req.password\n    )\n    \n    // Create session\n    let session = await context.dependencies.sessionStore.create(userID: user.id)\n    \n    // Set secure cookie\n    var response = Response(status: .ok)\n    response.setCookie(\n        .init(\n            name: \"session_id\",\n            value: session.id,\n            path: \"/\",\n            expires: session.expiresAt,\n            maxAge: 3600,\n            httpOnly: true,\n            secure: true, // HTTPS only\n            sameSite: .strict\n        )\n    )\n    \n    return response\n}\n\n// ✅ Correct — logout handler that destroys session\nrouter.post(\"/logout\") { request, context in\n    guard let sessionID = request.cookies[\"session_id\"]?.value else {\n        return Response(status: .ok)\n    }\n    \n    await context.dependencies.sessionStore.delete(id: sessionID)\n    \n    // Clear cookie\n    var response = Response(status: .ok)\n    response.setCookie(\n        .init(\n            name: \"session_id\",\n            value: \"\",\n            path: \"/\",\n            expires: Date(timeIntervalSince1970: 0),\n            maxAge: 0\n        )\n    )\n    \n    return response\n}\n\n// ✅ Correct — background service for session cleanup\nstruct SessionCleanupService: Service {\n    let sessionStore: SessionStore\n    let interval: Duration\n    let logger: Logger\n    \n    func run() async throws {\n        while !Task.isCancelled {\n            try await Task.sleep(for: interval)\n            \n            await sessionStore.cleanup()\n            logger.debug(\"Session cleanup completed\")\n        }\n    }\n}\n\n// ❌ Wrong — sessions without actor protection (data race)\nvar sessions: [String: Session] = [:] // ⚠️ Shared mutable state!\n\nstruct UnsafeSessionMiddleware: RouterMiddleware {\n    func handle(...) async throws -> Response {\n        let session = sessions[sessionID] // ⚠️ Data race in Swift 6!\n        ...\n    }\n}\n\n// ❌ Wrong — insecure cookie (missing httpOnly, secure flags)\nrouter.post(\"/login\") { request, context in\n    let session = await sessionStore.create(userID: user.id)\n    \n    var response = Response(status: .ok)\n    response.setCookie(\n        .init(\n            name: \"session_id\",\n            value: session.id\n            // ⚠️ Missing httpOnly: true — vulnerable to XSS!\n            // ⚠️ Missing secure: true — transmitted over HTTP!\n            // ⚠️ Missing sameSite: .strict — vulnerable to CSRF!\n        )\n    )\n    \n    return response\n}\n\n// ❌ Wrong — predictable session IDs\nfunc createSessionWithWeakID(userID: UUID) -> Session {\n    let sessionID = \"\\(userID)_\\(Date().timeIntervalSince1970)\" // ⚠️ Predictable!\n    // Attacker can guess session IDs and hijack sessions\n    return Session(id: sessionID, userID: userID, createdAt: Date(), expiresAt: Date().addingTimeInterval(3600))\n}\n\n// ❌ Wrong — no session expiration\nactor NoExpirationSessionStore {\n    private var sessions: [String: Session] = [:]\n    \n    func get(id: String) -> Session? {\n        return sessions[id] // ⚠️ No expiration check — sessions live forever!\n    }\n}\n\n// ❌ Wrong — no session extension on activity (poor UX)\nstruct NoExtensionMiddleware: RouterMiddleware {\n    func handle(...) async throws -> Response {\n        let session = await sessionStore.get(id: sessionID)\n        // ⚠️ No session extension — user gets logged out mid-activity!\n        return try await next(request, context)\n    }\n}\n```\n\nKey requirements:\n- Protect session store with actor for thread safety\n- Use cryptographically random session IDs (UUID is sufficient)\n- Set secure cookie flags: httpOnly, secure, sameSite: .strict\n- Implement session expiration and cleanup\n- Extend session lifetime on user activity (sliding expiration)\n- Provide immediate logout/invalidation capability\n- Log authentication events\n- Exempt login/register endpoints from auth requirement\n- Use HTTPS in production (secure: true cookie flag)\n\nSession store backends:\n- In-memory (development, single instance)\n- Redis (production, distributed)\n- Database (production, persistent)\n\nCommon vulnerabilities:\n- Shared mutable state without actor protection (data races)\n- Insecure cookies (missing httpOnly, secure, sameSite flags)\n- Predictable session IDs (enables session hijacking)\n- No session expiration (sessions never expire)\n- No cleanup mechanism (memory leak)\n- Transmitting session IDs over HTTP (secure: false)",
    "layer": "middleware",
    "patternIds": ["session-auth", "stateful-auth", "cookie-based-auth", "session-management"],
    "violationIds": ["session-without-actor", "insecure-session-cookie", "predictable-session-id", "no-session-expiration", "missing-session-cleanup"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "user-context-injection",
    "title": "Authenticated User Context Injection",
    "content": "After successful authentication, middleware must inject user identity and metadata into AppRequestContext so that downstream handlers and services can access authenticated user information without re-parsing tokens or sessions.\n\n```swift\nimport Hummingbird\nimport Foundation\n\n// ✅ Correct — AppRequestContext with optional user fields\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies\n    \n    // User context fields (populated by auth middleware)\n    var userID: String?\n    var userEmail: String?\n    var userRoles: Set<String>?\n    var sessionID: String?\n    \n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        self.dependencies = AppDependencies.placeholder\n        self.userID = nil\n        self.userEmail = nil\n        self.userRoles = nil\n        self.sessionID = nil\n    }\n}\n\n// ✅ Correct — authentication middleware injects user context\nstruct JWTAuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let signers: JWTSigners\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        let path = request.uri.path\n        guard path != \"/health\", path != \"/ready\" else {\n            return try await next(request, context)\n        }\n        \n        let token = try extractBearerToken(from: request)\n        let payload = try signers.verify(token, as: JWTPayload.self)\n        try payload.exp.verifyNotExpired()\n        \n        // Inject user context\n        var ctx = context\n        ctx.userID = payload.sub.value\n        ctx.userEmail = payload.email\n        ctx.userRoles = Set(payload.roles ?? [])\n        \n        context.logger.info(\n            \"User authenticated\",\n            metadata: [\n                \"userId\": \"\\(payload.sub.value)\",\n                \"email\": \"\\(payload.email)\",\n                \"path\": \"\\(path)\"\n            ]\n        )\n        \n        // Pass modified context to next handler\n        return try await next(request, ctx)\n    }\n}\n\n// ✅ Correct — handler accesses authenticated user via context\nrouter.get(\"/profile\") { request, context in\n    guard let userID = context.userID else {\n        throw HTTPError(.unauthorized, message: \"Authentication required\")\n    }\n    \n    let user = try await context.dependencies.userService.find(id: UUID(uuidString: userID)!)\n    return UserProfileResponse(user)\n}\n\n// ✅ Correct — service receives user ID as explicit parameter\nstruct PostService {\n    let repository: any PostRepositoryProtocol\n    \n    func createPost(authorID: UUID, title: String, content: String) async throws -> Post {\n        let post = Post(\n            id: UUID(),\n            authorID: authorID,\n            title: title,\n            content: content,\n            createdAt: Date()\n        )\n        \n        return try await repository.insert(post)\n    }\n    \n    func updatePost(id: UUID, authorID: UUID, title: String, content: String) async throws -> Post {\n        // Verify ownership\n        guard let post = try await repository.find(id: id),\n              post.authorID == authorID else {\n            throw AppError.forbidden(reason: \"Can only update own posts\")\n        }\n        \n        var updated = post\n        updated.title = title\n        updated.content = content\n        \n        return try await repository.update(updated)\n    }\n}\n\n// ✅ Correct — handler passes user ID to service\nrouter.post(\"/posts\") { request, context in\n    guard let userID = context.userID else {\n        throw HTTPError(.unauthorized)\n    }\n    \n    struct CreatePostRequest: Decodable {\n        let title: String\n        let content: String\n    }\n    \n    let req = try await request.decode(as: CreatePostRequest.self, context: context)\n    \n    let post = try await context.dependencies.postService.createPost(\n        authorID: UUID(uuidString: userID)!,\n        title: req.title,\n        content: req.content\n    )\n    \n    return PostResponse(post)\n}\n\n// ✅ Correct — role-based authorization helper\nextension AppRequestContext {\n    func requireRole(_ role: String) throws {\n        guard let roles = userRoles, roles.contains(role) else {\n            logger.warning(\n                \"Role check failed\",\n                metadata: [\n                    \"userId\": \"\\(userID ?? \"none\")\",\n                    \"requiredRole\": \"\\(role)\",\n                    \"userRoles\": \"\\(userRoles?.description ?? \"none\")\"\n                ]\n            )\n            throw HTTPError(.forbidden, message: \"Insufficient permissions\")\n        }\n    }\n    \n    func requireAuthentication() throws -> String {\n        guard let userID = userID else {\n            throw HTTPError(.unauthorized, message: \"Authentication required\")\n        }\n        return userID\n    }\n}\n\n// ✅ Correct — admin-only endpoint with role check\nrouter.delete(\"/users/:id\") { request, context in\n    try context.requireRole(\"admin\")\n    \n    let id = try context.parameters.require(\"id\", as: UUID.self)\n    try await context.dependencies.userService.delete(id: id)\n    \n    return Response(status: .noContent)\n}\n\n// ❌ Wrong — service takes entire AppRequestContext\nstruct BadPostService {\n    let repository: any PostRepositoryProtocol\n    \n    // ⚠️ Service depends on HTTP context — not testable!\n    func createPost(context: AppRequestContext, title: String, content: String) async throws -> Post {\n        guard let authorID = context.userID else {\n            throw AppError.unauthorized(reason: \"User not authenticated\")\n        }\n        // ...\n    }\n}\n\n// ❌ Wrong — handler re-parses JWT instead of using injected context\nrouter.get(\"/profile\") { request, context in\n    // ⚠️ Redundant JWT parsing — context.userID already available!\n    let token = try extractBearerToken(from: request)\n    let payload = try context.dependencies.jwtSigners.verify(token, as: JWTPayload.self)\n    let userID = payload.sub.value\n    \n    let user = try await context.dependencies.userService.find(id: UUID(uuidString: userID)!)\n    return UserProfileResponse(user)\n}\n\n// ❌ Wrong — missing authentication check\nrouter.post(\"/posts\") { request, context in\n    // ⚠️ No check for context.userID — allows unauthenticated requests!\n    let req = try await request.decode(as: CreatePostRequest.self, context: context)\n    \n    // ⚠️ Using empty UUID as author — data integrity issue!\n    let post = try await context.dependencies.postService.createPost(\n        authorID: UUID(),\n        title: req.title,\n        content: req.content\n    )\n    \n    return PostResponse(post)\n}\n\n// ❌ Wrong — storing user in global variable\nvar currentUser: User? // ⚠️ Shared mutable state — data race!\n\nstruct BadAuthMiddleware: RouterMiddleware {\n    func handle(...) async throws -> Response {\n        let user = try await authenticateUser(request)\n        currentUser = user // ⚠️ Concurrent requests will overwrite!\n        return try await next(request, context)\n    }\n}\n\nrouter.get(\"/profile\") { request, context in\n    guard let user = currentUser else { // ⚠️ Wrong user or nil!\n        throw HTTPError(.unauthorized)\n    }\n    return UserProfileResponse(user)\n}\n```\n\nKey requirements:\n- Add optional user fields to AppRequestContext (userID, userEmail, userRoles, sessionID)\n- Authentication middleware populates user context after successful validation\n- Pass modified context to next middleware/handler in chain\n- Handlers access user via context.userID (not by re-parsing tokens)\n- Services receive user ID as explicit parameters (not entire context)\n- Implement helper methods (requireRole, requireAuthentication) for common checks\n- Log authentication and authorization events with user ID\n- Never store authenticated user in global/shared state\n\nContext modification pattern:\n```swift\nvar ctx = context  // Copy context\nctx.userID = \"...\" // Modify copy\nreturn try await next(request, ctx) // Pass modified copy\n```\n\nCommon mistakes:\n- Service taking entire AppRequestContext (couples service to HTTP layer)\n- Re-parsing JWT in handlers (redundant, inefficient)\n- Missing authentication checks in protected endpoints\n- Storing user in global variable (data race, wrong user)\n- Not passing modified context to next handler\n- Forgetting to make context var mutable before modification",
    "layer": "context",
    "patternIds": ["user-context", "context-injection", "authentication-context", "authorization-helpers"],
    "violationIds": ["service-takes-request-context", "redundant-jwt-parsing", "missing-auth-check", "global-user-state", "immutable-context-modification"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "websocket-pattern",
    "title": "WebSocket Integration with hummingbird-websocket",
    "content": "Hummingbird supports WebSockets through the hummingbird-websocket package. WebSocket connections are established via HTTP upgrade and provide full-duplex communication. All connection state must be managed with actors to ensure thread safety.\n\n```swift\n// Package dependency\n.package(url: \"https://github.com/hummingbird-project/hummingbird-websocket.git\", from: \"2.0.0\"),\n.product(name: \"HummingbirdWebSocket\", package: \"hummingbird-websocket\"),\n\nimport HummingbirdWebSocket\n\n// ✅ Correct — basic WebSocket upgrade pattern\nrouter.ws(\"/chat\") { request, wsContext in\n    return .upgrade([:]) { inbound, outbound, context in\n        for try await message in inbound {\n            switch message {\n            case .text(let text):\n                context.logger.info(\"Received text\", metadata: [\"message\": \"\\(text)\"])\n                try await outbound.write(.text(\"Echo: \\(text)\"))\n            case .binary(let data):\n                context.logger.info(\"Received binary\", metadata: [\"size\": \"\\(data.count)\"])\n                try await outbound.write(.binary(data))\n            }\n        }\n    }\n}\n\n// ✅ Correct — actor-based connection tracking for broadcasting\nactor WebSocketConnectionManager {\n    private var connections: [UUID: WebSocketOutboundWriter] = [:]\n    \n    func register(id: UUID, writer: WebSocketOutboundWriter) {\n        connections[id] = writer\n    }\n    \n    func unregister(id: UUID) {\n        connections.removeValue(forKey: id)\n    }\n    \n    func broadcast(message: String) async {\n        let writers = connections.values\n        await withTaskGroup(of: Void.self) { group in\n            for writer in writers {\n                group.addTask {\n                    try? await writer.write(.text(message))\n                }\n            }\n        }\n    }\n    \n    func send(to id: UUID, message: String) async throws {\n        guard let writer = connections[id] else {\n            throw AppError.notFound(reason: \"Connection not found\")\n        }\n        try await writer.write(.text(message))\n    }\n    \n    var activeConnections: Int {\n        connections.count\n    }\n}\n\n// ✅ Correct — WebSocket handler with connection lifecycle management\nrouter.ws(\"/chat/:room\") { request, wsContext in\n    let roomID = try wsContext.parameters.require(\"room\")\n    let connectionID = UUID()\n    \n    return .upgrade([:]) { inbound, outbound, context in\n        // Register connection\n        await context.dependencies.connectionManager.register(id: connectionID, writer: outbound)\n        \n        context.logger.info(\n            \"WebSocket connected\",\n            metadata: [\"connectionId\": \"\\(connectionID)\", \"room\": \"\\(roomID)\"]\n        )\n        \n        // Notify other users\n        await context.dependencies.connectionManager.broadcast(message: \"User \\(connectionID) joined\")\n        \n        // Handle cleanup on disconnect (defer executes when scope exits)\n        defer {\n            Task {\n                await context.dependencies.connectionManager.unregister(id: connectionID)\n                context.logger.info(\n                    \"WebSocket disconnected\",\n                    metadata: [\"connectionId\": \"\\(connectionID)\", \"room\": \"\\(roomID)\"]\n                )\n                await context.dependencies.connectionManager.broadcast(message: \"User \\(connectionID) left\")\n            }\n        }\n        \n        // Message handling loop\n        do {\n            for try await message in inbound {\n                switch message {\n                case .text(let text):\n                    context.logger.debug(\n                        \"Message received\",\n                        metadata: [\"connectionId\": \"\\(connectionID)\", \"text\": \"\\(text)\"]\n                    )\n                    \n                    // Broadcast to all connections in room\n                    await context.dependencies.connectionManager.broadcast(\n                        message: \"[\\(connectionID)]: \\(text)\"\n                    )\n                    \n                case .binary(let data):\n                    context.logger.debug(\n                        \"Binary data received\",\n                        metadata: [\"connectionId\": \"\\(connectionID)\", \"size\": \"\\(data.count)\"]\n                    )\n                    try await outbound.write(.binary(data))\n                }\n            }\n        } catch {\n            context.logger.error(\n                \"WebSocket error\",\n                metadata: [\"connectionId\": \"\\(connectionID)\", \"error\": \"\\(error)\"]\n            )\n        }\n    }\n}\n\n// ✅ Correct — structured message pattern with Codable\nstruct ChatMessage: Codable {\n    let type: MessageType\n    let sender: String\n    let content: String\n    let timestamp: Date\n    \n    enum MessageType: String, Codable {\n        case text\n        case system\n        case error\n    }\n}\n\nrouter.ws(\"/chat\") { request, wsContext in\n    let connectionID = UUID()\n    \n    return .upgrade([:]) { inbound, outbound, context in\n        await context.dependencies.connectionManager.register(id: connectionID, writer: outbound)\n        \n        defer {\n            Task {\n                await context.dependencies.connectionManager.unregister(id: connectionID)\n            }\n        }\n        \n        for try await message in inbound {\n            guard case .text(let text) = message else { continue }\n            \n            // Decode structured message\n            let decoder = JSONDecoder()\n            decoder.dateDecodingStrategy = .iso8601\n            \n            guard let data = text.data(using: .utf8),\n                  let chatMessage = try? decoder.decode(ChatMessage.self, from: data) else {\n                let error = ChatMessage(\n                    type: .error,\n                    sender: \"system\",\n                    content: \"Invalid message format\",\n                    timestamp: Date()\n                )\n                let encoder = JSONEncoder()\n                encoder.dateEncodingStrategy = .iso8601\n                if let errorData = try? encoder.encode(error),\n                   let errorJSON = String(data: errorData, encoding: .utf8) {\n                    try await outbound.write(.text(errorJSON))\n                }\n                continue\n            }\n            \n            // Broadcast to all connections\n            let encoder = JSONEncoder()\n            encoder.dateEncodingStrategy = .iso8601\n            if let messageData = try? encoder.encode(chatMessage),\n               let messageJSON = String(data: messageData, encoding: .utf8) {\n                await context.dependencies.connectionManager.broadcast(message: messageJSON)\n            }\n        }\n    }\n}\n\n// ✅ Correct — authenticated WebSocket with middleware\nrouter.ws(\"/secure/notifications\") { request, wsContext in\n    // Validate authentication before upgrade\n    guard let token = request.headers[.authorization]?.dropFirst(7),\n          let userID = try? wsContext.dependencies.authService.validateToken(String(token)) else {\n        return .dontUpgrade\n    }\n    \n    let connectionID = UUID()\n    \n    return .upgrade([:]) { inbound, outbound, context in\n        // User-specific connection tracking\n        await context.dependencies.connectionManager.register(id: connectionID, writer: outbound)\n        \n        context.logger.info(\n            \"Authenticated WebSocket connected\",\n            metadata: [\"userId\": \"\\(userID)\", \"connectionId\": \"\\(connectionID)\"]\n        )\n        \n        defer {\n            Task {\n                await context.dependencies.connectionManager.unregister(id: connectionID)\n            }\n        }\n        \n        for try await message in inbound {\n            switch message {\n            case .text(let text):\n                // Process authenticated user message\n                try await context.dependencies.messageService.handle(\n                    userID: userID,\n                    message: text\n                )\n            case .binary:\n                break\n            }\n        }\n    }\n}\n\n// ❌ Wrong — shared mutable state without actor protection\nvar connections: [UUID: WebSocketOutboundWriter] = [:] // ⚠️ Data race!\n\nrouter.ws(\"/chat\") { request, wsContext in\n    return .upgrade([:]) { inbound, outbound, context in\n        let id = UUID()\n        connections[id] = outbound // ⚠️ Concurrent access — data race in Swift 6!\n        \n        for try await message in inbound {\n            // ...\n        }\n        \n        connections.removeValue(forKey: id) // ⚠️ Data race!\n    }\n}\n\n// ❌ Wrong — no cleanup on disconnect\nrouter.ws(\"/chat\") { request, wsContext in\n    return .upgrade([:]) { inbound, outbound, context in\n        let id = UUID()\n        await connectionManager.register(id: id, writer: outbound)\n        \n        // ⚠️ Missing defer block — connection never cleaned up!\n        // Dead connections accumulate in memory\n        \n        for try await message in inbound {\n            // ...\n        }\n    }\n}\n\n// ❌ Wrong — no error handling\nrouter.ws(\"/chat\") { request, wsContext in\n    return .upgrade([:]) { inbound, outbound, context in\n        // ⚠️ No do-catch — errors crash the connection silently\n        for try await message in inbound {\n            try await outbound.write(.text(\"Echo\"))\n        }\n    }\n}\n\n// ❌ Wrong — synchronous blocking operations in WebSocket handler\nrouter.ws(\"/chat\") { request, wsContext in\n    return .upgrade([:]) { inbound, outbound, context in\n        for try await message in inbound {\n            Thread.sleep(forTimeInterval: 1.0) // ⚠️ Blocks thread!\n            try await outbound.write(.text(\"Echo\"))\n        }\n    }\n}\n```\n\nKey requirements:\n- Use `router.ws()` to define WebSocket endpoints\n- Return `.upgrade([:])` to accept the upgrade, `.dontUpgrade` to reject\n- Protect all shared connection state with actors (WebSocketConnectionManager)\n- Always use `defer` block to clean up connections on disconnect\n- Wrap message handling in do-catch for error handling\n- Log connection lifecycle events (connect, disconnect, errors)\n- Validate authentication before upgrade for secure endpoints\n- Use structured messages (Codable) for complex data exchange\n- Never use synchronous blocking operations (Thread.sleep, blocking I/O)\n\nWebSocket message types:\n- `.text(String)` — text messages (UTF-8)\n- `.binary(ByteBuffer)` — binary data\n\nConnection lifecycle:\n1. HTTP upgrade request received\n2. Authentication/authorization checks (if required)\n3. Return `.upgrade([:])` to accept\n4. Register connection in actor-protected store\n5. Set up `defer` block for cleanup\n6. Handle messages in for-await loop\n7. On disconnect (loop exit), defer block executes\n8. Unregister connection from store\n\nCommon pitfalls:\n- Shared mutable state without actor protection (data races)\n- No cleanup on disconnect (memory leak, dead connections accumulate)\n- Missing error handling (silent failures)\n- Synchronous blocking operations (blocks thread pool)\n- Not validating authentication before upgrade (security issue)\n- Writing to closed connections (crashes)",
    "layer": "middleware",
    "patternIds": ["websocket", "real-time-communication", "actor-based-state", "connection-lifecycle"],
    "violationIds": ["websocket-shared-state-without-actor", "missing-websocket-cleanup", "missing-websocket-error-handling", "blocking-in-websocket-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "server-sent-events-pattern",
    "title": "Server-Sent Events (SSE) for Unidirectional Streaming",
    "content": "Server-Sent Events (SSE) provide unidirectional server-to-client streaming over HTTP. Unlike WebSockets, SSE is a simple text-based protocol that works over standard HTTP, automatically reconnects on disconnect, and is ideal for server push notifications, real-time updates, and event streams.\n\n```swift\nimport Hummingbird\nimport Foundation\nimport NIOCore\n\n// ✅ Correct — SSE response with proper content-type\nrouter.get(\"/events\") { request, context in\n    // Create event stream\n    let stream = AsyncStream<ByteBuffer> { continuation in\n        Task {\n            var eventID = 0\n            while !Task.isCancelled {\n                // Format SSE event\n                let event = \"id: \\(eventID)\\ndata: {\\\"message\\\":\\\"Hello \\(eventID)\\\",\\\"timestamp\\\":\\\"\\(Date())\\\"}\\n\\n\"\n                \n                var buffer = context.allocator.buffer(capacity: event.utf8.count)\n                buffer.writeString(event)\n                continuation.yield(buffer)\n                \n                eventID += 1\n                try? await Task.sleep(for: .seconds(1))\n            }\n            continuation.finish()\n        }\n    }\n    \n    // Return SSE response with required headers\n    return Response(\n        status: .ok,\n        headers: [\n            .contentType: \"text/event-stream\",\n            .cacheControl: \"no-cache\",\n            .connection: \"keep-alive\"\n        ],\n        body: .init(asyncSequence: stream)\n    )\n}\n\n// ✅ Correct — actor-based SSE client manager for broadcasting\nactor SSEClientManager {\n    private var clients: [UUID: AsyncStream<ByteBuffer>.Continuation] = [:]\n    private let allocator: ByteBufferAllocator\n    \n    init(allocator: ByteBufferAllocator) {\n        self.allocator = allocator\n    }\n    \n    func register() -> (id: UUID, stream: AsyncStream<ByteBuffer>) {\n        let id = UUID()\n        let stream = AsyncStream<ByteBuffer> { continuation in\n            clients[id] = continuation\n        }\n        return (id, stream)\n    }\n    \n    func unregister(id: UUID) {\n        clients[id]?.finish()\n        clients.removeValue(forKey: id)\n    }\n    \n    func broadcast(event: String, data: String, id: String? = nil) {\n        var eventString = \"\"\n        if let id = id {\n            eventString += \"id: \\(id)\\n\"\n        }\n        eventString += \"event: \\(event)\\n\"\n        eventString += \"data: \\(data)\\n\\n\"\n        \n        var buffer = allocator.buffer(capacity: eventString.utf8.count)\n        buffer.writeString(eventString)\n        \n        for (_, continuation) in clients {\n            continuation.yield(buffer)\n        }\n    }\n    \n    func send(to clientID: UUID, event: String, data: String, id: String? = nil) {\n        var eventString = \"\"\n        if let id = id {\n            eventString += \"id: \\(id)\\n\"\n        }\n        eventString += \"event: \\(event)\\n\"\n        eventString += \"data: \\(data)\\n\\n\"\n        \n        var buffer = allocator.buffer(capacity: eventString.utf8.count)\n        buffer.writeString(eventString)\n        \n        clients[clientID]?.yield(buffer)\n    }\n    \n    var activeClients: Int {\n        clients.count\n    }\n}\n\n// ✅ Correct — SSE endpoint with client lifecycle management\nrouter.get(\"/notifications\") { request, context in\n    let (clientID, stream) = await context.dependencies.sseManager.register()\n    \n    context.logger.info(\n        \"SSE client connected\",\n        metadata: [\"clientId\": \"\\(clientID)\"]\n    )\n    \n    // Send initial connection event\n    await context.dependencies.sseManager.send(\n        to: clientID,\n        event: \"connected\",\n        data: \"{\\\"clientId\\\":\\\"\\(clientID)\\\"}\",\n        id: \"0\"\n    )\n    \n    // Wrap stream to handle cleanup on disconnect\n    let cleanupStream = AsyncStream<ByteBuffer> { continuation in\n        Task {\n            for await buffer in stream {\n                continuation.yield(buffer)\n            }\n            \n            // Cleanup when client disconnects\n            await context.dependencies.sseManager.unregister(id: clientID)\n            context.logger.info(\n                \"SSE client disconnected\",\n                metadata: [\"clientId\": \"\\(clientID)\"]\n            )\n            continuation.finish()\n        }\n    }\n    \n    return Response(\n        status: .ok,\n        headers: [\n            .contentType: \"text/event-stream\",\n            .cacheControl: \"no-cache\",\n            .connection: \"keep-alive\",\n            .custom(\"X-Accel-Buffering\"): \"no\" // Disable nginx buffering\n        ],\n        body: .init(asyncSequence: cleanupStream)\n    )\n}\n\n// ✅ Correct — background service that broadcasts to SSE clients\nstruct NotificationBroadcastService: Service {\n    let sseManager: SSEClientManager\n    let notificationQueue: NotificationQueue\n    let logger: Logger\n    \n    func run() async throws {\n        while !Task.isCancelled {\n            do {\n                let notification = try await notificationQueue.dequeue()\n                \n                let encoder = JSONEncoder()\n                let data = try encoder.encode(notification)\n                guard let jsonString = String(data: data, encoding: .utf8) else {\n                    continue\n                }\n                \n                await sseManager.broadcast(\n                    event: notification.type,\n                    data: jsonString,\n                    id: notification.id\n                )\n                \n                logger.info(\n                    \"Notification broadcast\",\n                    metadata: [\n                        \"notificationId\": \"\\(notification.id)\",\n                        \"type\": \"\\(notification.type)\",\n                        \"clients\": \"\\(await sseManager.activeClients)\"\n                    ]\n                )\n            } catch {\n                logger.error(\n                    \"Notification broadcast failed\",\n                    metadata: [\"error\": \"\\(error)\"]\n                )\n            }\n        }\n    }\n}\n\n// ✅ Correct — SSE event format with retry and multiline data\nfunc formatSSEEvent(\n    allocator: ByteBufferAllocator,\n    event: String? = nil,\n    data: String,\n    id: String? = nil,\n    retry: Int? = nil\n) -> ByteBuffer {\n    var eventString = \"\"\n    \n    if let id = id {\n        eventString += \"id: \\(id)\\n\"\n    }\n    \n    if let event = event {\n        eventString += \"event: \\(event)\\n\"\n    }\n    \n    if let retry = retry {\n        eventString += \"retry: \\(retry)\\n\"\n    }\n    \n    // Handle multiline data\n    for line in data.split(separator: \"\\n\") {\n        eventString += \"data: \\(line)\\n\"\n    }\n    \n    eventString += \"\\n\" // Double newline terminates event\n    \n    var buffer = allocator.buffer(capacity: eventString.utf8.count)\n    buffer.writeString(eventString)\n    return buffer\n}\n\n// ✅ Correct — authenticated SSE endpoint\nrouter.get(\"/secure/updates\") { request, context in\n    // Validate authentication before establishing stream\n    guard let userID = context.userID else {\n        throw HTTPError(.unauthorized, message: \"Authentication required\")\n    }\n    \n    let (clientID, stream) = await context.dependencies.sseManager.register()\n    \n    context.logger.info(\n        \"Authenticated SSE client connected\",\n        metadata: [\"userId\": \"\\(userID)\", \"clientId\": \"\\(clientID)\"]\n    )\n    \n    // User-specific initialization event\n    await context.dependencies.sseManager.send(\n        to: clientID,\n        event: \"authenticated\",\n        data: \"{\\\"userId\\\":\\\"\\(userID)\\\",\\\"clientId\\\":\\\"\\(clientID)\\\"}\"\n    )\n    \n    let cleanupStream = AsyncStream<ByteBuffer> { continuation in\n        Task {\n            for await buffer in stream {\n                continuation.yield(buffer)\n            }\n            await context.dependencies.sseManager.unregister(id: clientID)\n            context.logger.info(\n                \"Authenticated SSE client disconnected\",\n                metadata: [\"userId\": \"\\(userID)\", \"clientId\": \"\\(clientID)\"]\n            )\n            continuation.finish()\n        }\n    }\n    \n    return Response(\n        status: .ok,\n        headers: [\n            .contentType: \"text/event-stream\",\n            .cacheControl: \"no-cache\",\n            .connection: \"keep-alive\"\n        ],\n        body: .init(asyncSequence: cleanupStream)\n    )\n}\n\n// ❌ Wrong — missing content-type header\nrouter.get(\"/events\") { request, context in\n    let stream = AsyncStream<ByteBuffer> { continuation in\n        // ...\n    }\n    \n    // ⚠️ Missing Content-Type: text/event-stream header!\n    // Browser won't recognize this as SSE\n    return Response(\n        status: .ok,\n        body: .init(asyncSequence: stream)\n    )\n}\n\n// ❌ Wrong — shared mutable state without actor protection\nvar sseClients: [UUID: AsyncStream<ByteBuffer>.Continuation] = [:] // ⚠️ Data race!\n\nrouter.get(\"/events\") { request, context in\n    let id = UUID()\n    let stream = AsyncStream<ByteBuffer> { continuation in\n        sseClients[id] = continuation // ⚠️ Concurrent access — data race!\n    }\n    return Response(status: .ok, body: .init(asyncSequence: stream))\n}\n\n// ❌ Wrong — no client cleanup on disconnect\nrouter.get(\"/events\") { request, context in\n    let (clientID, stream) = await sseManager.register()\n    \n    // ⚠️ Missing cleanup wrapper — client never unregistered!\n    // Dead clients accumulate in memory\n    \n    return Response(\n        status: .ok,\n        headers: [.contentType: \"text/event-stream\"],\n        body: .init(asyncSequence: stream)\n    )\n}\n\n// ❌ Wrong — incorrect SSE event format\nrouter.get(\"/events\") { request, context in\n    let stream = AsyncStream<ByteBuffer> { continuation in\n        Task {\n            // ⚠️ Invalid format — missing double newline, incorrect field names\n            let event = \"{\\\"message\\\":\\\"hello\\\"}\\n\"\n            var buffer = context.allocator.buffer(capacity: event.utf8.count)\n            buffer.writeString(event)\n            continuation.yield(buffer)\n        }\n    }\n    return Response(status: .ok, headers: [.contentType: \"text/event-stream\"], body: .init(asyncSequence: stream))\n}\n\n// ❌ Wrong — synchronous blocking in event stream\nrouter.get(\"/events\") { request, context in\n    let stream = AsyncStream<ByteBuffer> { continuation in\n        Task {\n            while true {\n                Thread.sleep(forTimeInterval: 1.0) // ⚠️ Blocks thread!\n                // ...\n            }\n        }\n    }\n    return Response(status: .ok, headers: [.contentType: \"text/event-stream\"], body: .init(asyncSequence: stream))\n}\n```\n\nSSE Event Format:\n```\nid: <event-id>\\n\nevent: <event-type>\\n\ndata: <payload>\\n\nretry: <reconnect-ms>\\n\n\\n\n```\n\nKey requirements:\n- Response header `Content-Type: text/event-stream` (REQUIRED)\n- Response header `Cache-Control: no-cache` (prevents caching)\n- Response header `Connection: keep-alive` (keeps connection open)\n- Optional header `X-Accel-Buffering: no` (disables nginx buffering)\n- Use `AsyncStream<ByteBuffer>` for event streaming\n- Protect client state with actors (SSEClientManager)\n- Each event ends with double newline (`\\n\\n`)\n- Wrap stream to handle cleanup on client disconnect\n- Log client connections and disconnections\n- Validate authentication before establishing stream (if required)\n- Never use synchronous blocking operations (Thread.sleep)\n\nSSE event fields:\n- `id:` — Event ID for client-side replay (optional)\n- `event:` — Event type, defaults to \"message\" (optional)\n- `data:` — Event payload, can span multiple lines (required)\n- `retry:` — Reconnection delay in milliseconds (optional)\n\nWhen to use SSE:\n- Server-to-client push notifications\n- Real-time updates (stock prices, sports scores)\n- Progress indicators for long-running tasks\n- Server-side event logs streaming\n- Unidirectional data flow (server → client only)\n\nSSE vs WebSocket:\n- SSE: Unidirectional (server → client), simple text protocol, automatic reconnection\n- WebSocket: Bidirectional (client ↔ server), binary support, manual reconnection\n\nCommon pitfalls:\n- Missing `Content-Type: text/event-stream` header (browser won't recognize SSE)\n- Shared mutable client state without actor protection (data races)\n- No cleanup on client disconnect (memory leak)\n- Incorrect event format (missing `\\n\\n` terminator)\n- Synchronous blocking operations in stream (blocks thread pool)\n- Not disabling nginx buffering in production (`X-Accel-Buffering: no`)",
    "layer": "middleware",
    "patternIds": ["server-sent-events", "sse", "event-streaming", "actor-based-state", "real-time-push"],
    "violationIds": ["missing-sse-content-type", "sse-shared-state-without-actor", "missing-sse-cleanup", "invalid-sse-format", "blocking-in-sse-stream"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "background-jobs-hummingbird-jobs",
    "title": "Background Jobs with hummingbird-jobs",
    "content": "Hummingbird-jobs provides a robust job queue system for asynchronous task processing. It supports job persistence, retry logic with exponential backoff, job handlers, and graceful shutdown. Jobs are processed in background workers outside the HTTP request/response cycle, preventing timeouts and allowing long-running tasks.\n\n```swift\nimport HummingbirdJobs\nimport Foundation\n\n// ✅ Correct — define job data structure\nstruct EmailJobData: Codable, Sendable {\n    let recipientEmail: String\n    let subject: String\n    let body: String\n    let templateID: String?\n}\n\nstruct ImageProcessingJobData: Codable, Sendable {\n    let imageURL: String\n    let targetWidth: Int\n    let targetHeight: Int\n    let outputFormat: String\n}\n\n// ✅ Correct — implement job handler with error handling\nstruct EmailJobHandler: JobHandler {\n    typealias JobData = EmailJobData\n    \n    let emailService: EmailService\n    let logger: Logger\n    \n    func execute(job: JobData, context: JobContext) async throws {\n        logger.info(\n            \"Processing email job\",\n            metadata: [\n                \"recipient\": \"\\(job.recipientEmail)\",\n                \"subject\": \"\\(job.subject)\",\n                \"jobId\": \"\\(context.id)\"\n            ]\n        )\n        \n        do {\n            try await emailService.send(\n                to: job.recipientEmail,\n                subject: job.subject,\n                body: job.body,\n                templateID: job.templateID\n            )\n            \n            logger.info(\n                \"Email sent successfully\",\n                metadata: [\"jobId\": \"\\(context.id)\", \"recipient\": \"\\(job.recipientEmail)\"]\n            )\n        } catch {\n            logger.error(\n                \"Email delivery failed\",\n                metadata: [\"jobId\": \"\\(context.id)\", \"error\": \"\\(error)\"]\n            )\n            // Re-throw to trigger retry mechanism\n            throw JobError.failed(reason: \"Email delivery failed: \\(error.localizedDescription)\")\n        }\n    }\n}\n\n// ✅ Correct — job queue setup with persistence\nimport PostgresNIO\n\nstruct JobQueueService: Service {\n    let queue: JobQueue<PostgresJobQueue>\n    let logger: Logger\n    \n    init(pool: PostgresConnectionPool, logger: Logger) async throws {\n        // Initialize persistent job queue with PostgreSQL backend\n        let driver = PostgresJobQueue(\n            pool: pool,\n            configuration: .init(\n                failedJobsExpiration: .hours(24),\n                processingJobsExpiration: .minutes(10),\n                tableName: \"jobs\"\n            )\n        )\n        \n        // Ensure jobs table exists\n        try await driver.createTableIfNotExists()\n        \n        self.queue = JobQueue(\n            driver: driver,\n            logger: logger,\n            configuration: .init(\n                pollInterval: .seconds(1),\n                maxConcurrentJobs: 10\n            )\n        )\n        \n        self.logger = logger\n    }\n    \n    func run() async throws {\n        logger.info(\"Job queue service starting\")\n        \n        try await withGracefulShutdownHandler {\n            // Process jobs until shutdown signal\n            try await queue.run()\n        } onGracefulShutdown: {\n            logger.info(\"Job queue service shutting down gracefully\")\n            // Graceful shutdown:\n            // 1. Stop accepting new jobs\n            // 2. Wait for in-flight jobs to complete (up to gracefulShutdownTimeout)\n            // 3. Mark incomplete jobs as available for retry\n            queue.stop()\n        }\n        \n        logger.info(\"Job queue service stopped\")\n    }\n}\n\n// ✅ Correct — register job handlers with retry configuration\nfunc configureJobQueue(\n    queue: JobQueue<PostgresJobQueue>,\n    dependencies: AppDependencies\n) {\n    // Register email job handler with retry logic\n    queue.registerHandler(\n        \"send-email\",\n        handler: EmailJobHandler(\n            emailService: dependencies.emailService,\n            logger: dependencies.logger\n        ),\n        maxRetries: 3,\n        retryStrategy: .exponentialBackoff(\n            initialDelay: .seconds(5),\n            multiplier: 2.0,\n            maxDelay: .minutes(5)\n        )\n    )\n    \n    // Register image processing job with different retry config\n    queue.registerHandler(\n        \"process-image\",\n        handler: ImageProcessingJobHandler(\n            imageProcessor: dependencies.imageProcessor,\n            storage: dependencies.storageService,\n            logger: dependencies.logger\n        ),\n        maxRetries: 5,\n        retryStrategy: .exponentialBackoff(\n            initialDelay: .seconds(10),\n            multiplier: 2.0,\n            maxDelay: .minutes(10)\n        )\n    )\n    \n    // Register webhook delivery with high retry count\n    queue.registerHandler(\n        \"deliver-webhook\",\n        handler: WebhookDeliveryHandler(\n            httpClient: dependencies.httpClient,\n            logger: dependencies.logger\n        ),\n        maxRetries: 10,\n        retryStrategy: .exponentialBackoff(\n            initialDelay: .seconds(30),\n            multiplier: 1.5,\n            maxDelay: .hours(1)\n        )\n    )\n}\n\n// ✅ Correct — enqueue job from route handler\nrouter.post(\"/users/:id/send-welcome-email\") { request, context in\n    let userID = try context.parameters.require(\"id\", as: UUID.self)\n    let user = try await context.dependencies.userService.find(id: userID)\n    \n    // Enqueue job for background processing\n    let jobID = try await context.dependencies.jobQueue.enqueue(\n        \"send-email\",\n        data: EmailJobData(\n            recipientEmail: user.email,\n            subject: \"Welcome to Our Platform\",\n            body: \"Thank you for joining!\",\n            templateID: \"welcome-v2\"\n        ),\n        scheduledAt: Date.now.addingTimeInterval(60) // Delay 1 minute\n    )\n    \n    context.logger.info(\n        \"Welcome email job enqueued\",\n        metadata: [\"userId\": \"\\(userID)\", \"jobId\": \"\\(jobID)\"]\n    )\n    \n    return EnqueueJobResponse(\n        jobID: jobID,\n        scheduledAt: Date.now.addingTimeInterval(60),\n        status: \"queued\"\n    )\n}\n\n// ✅ Correct — job persistence with database migrations\nfinal class CreateJobsTable: Migration {\n    func up(connection: PostgresConnection) async throws {\n        try await connection.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS jobs (\n                id UUID PRIMARY KEY,\n                job_type VARCHAR(255) NOT NULL,\n                job_data JSONB NOT NULL,\n                status VARCHAR(50) NOT NULL,\n                max_retries INT NOT NULL DEFAULT 3,\n                retry_count INT NOT NULL DEFAULT 0,\n                scheduled_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n                started_at TIMESTAMPTZ,\n                completed_at TIMESTAMPTZ,\n                failed_at TIMESTAMPTZ,\n                error_message TEXT,\n                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n                updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n            );\n            \n            CREATE INDEX IF NOT EXISTS idx_jobs_status_scheduled ON jobs(status, scheduled_at);\n            CREATE INDEX IF NOT EXISTS idx_jobs_type ON jobs(job_type);\n            CREATE INDEX IF NOT EXISTS idx_jobs_created_at ON jobs(created_at);\n            \"\"\")\n    }\n    \n    func down(connection: PostgresConnection) async throws {\n        try await connection.execute(\"DROP TABLE IF EXISTS jobs CASCADE;\")\n    }\n}\n\n// ✅ Correct — job handler with idempotency\nstruct PaymentProcessingJobHandler: JobHandler {\n    typealias JobData = PaymentJobData\n    \n    let paymentService: PaymentService\n    let repository: PaymentRepository\n    let logger: Logger\n    \n    func execute(job: JobData, context: JobContext) async throws {\n        // Check if job already processed (idempotency)\n        if let existingPayment = try await repository.findByJobID(context.id) {\n            if existingPayment.status == .completed {\n                logger.info(\n                    \"Job already processed\",\n                    metadata: [\"jobId\": \"\\(context.id)\", \"paymentId\": \"\\(existingPayment.id)\"]\n                )\n                return // Skip duplicate processing\n            }\n        }\n        \n        do {\n            let payment = try await paymentService.processPayment(\n                amount: job.amount,\n                currency: job.currency,\n                customerID: job.customerID\n            )\n            \n            // Store job ID with payment for idempotency tracking\n            try await repository.updateJobID(payment.id, jobID: context.id)\n            \n            logger.info(\n                \"Payment processed successfully\",\n                metadata: [\"jobId\": \"\\(context.id)\", \"paymentId\": \"\\(payment.id)\"]\n            )\n        } catch {\n            logger.error(\n                \"Payment processing failed\",\n                metadata: [\"jobId\": \"\\(context.id)\", \"error\": \"\\(error)\"]\n            )\n            throw JobError.failed(reason: \"Payment failed: \\(error.localizedDescription)\")\n        }\n    }\n}\n\n// ✅ Correct — application setup with job queue\nfunc buildApplication() async throws -> Application<AppRequestContext> {\n    let app = Application<AppRequestContext>(\n        router: router,\n        configuration: .init(\n            address: .hostname(\"0.0.0.0\", port: 8080)\n        )\n    )\n    \n    // Setup job queue service\n    let jobQueueService = try await JobQueueService(\n        pool: databasePool,\n        logger: logger\n    )\n    \n    // Configure job handlers\n    configureJobQueue(\n        queue: jobQueueService.queue,\n        dependencies: dependencies\n    )\n    \n    // Add job queue to service lifecycle\n    // Starts before HTTP server, stops after HTTP server\n    app.addServices(jobQueueService)\n    \n    return app\n}\n\n// ✅ Correct — monitoring job queue health\nrouter.get(\"/health/jobs\") { request, context in\n    let stats = await context.dependencies.jobQueue.statistics()\n    \n    return JobQueueHealthResponse(\n        status: stats.failedJobs > 100 ? \"degraded\" : \"healthy\",\n        pendingJobs: stats.pendingJobs,\n        processingJobs: stats.processingJobs,\n        completedJobs: stats.completedJobs,\n        failedJobs: stats.failedJobs,\n        workerCount: stats.activeWorkers\n    )\n}\n\n// ❌ Wrong — processing job synchronously in route handler\nrouter.post(\"/users/:id/send-email\") { request, context in\n    let userID = try context.parameters.require(\"id\", as: UUID.self)\n    let user = try await context.dependencies.userService.find(id: userID)\n    \n    // ⚠️ Blocks HTTP thread for long-running task!\n    try await context.dependencies.emailService.send(\n        to: user.email,\n        subject: \"Welcome\",\n        body: \"Thanks for joining!\"\n    )\n    \n    return Response(status: .ok)\n}\n\n// ❌ Wrong — no retry logic on job failure\nstruct EmailJobHandler: JobHandler {\n    func execute(job: EmailJobData, context: JobContext) async throws {\n        try await emailService.send(...)\n        // ⚠️ No error handling — transient failures cause permanent job loss!\n    }\n}\n\n// ❌ Wrong — job handler without idempotency protection\nstruct PaymentJobHandler: JobHandler {\n    func execute(job: PaymentJobData, context: JobContext) async throws {\n        // ⚠️ If job retries, payment could be charged multiple times!\n        let payment = try await paymentService.charge(\n            amount: job.amount,\n            customerID: job.customerID\n        )\n    }\n}\n\n// ❌ Wrong — no job persistence (in-memory queue)\nlet queue = JobQueue(\n    driver: MemoryJobQueue(), // ⚠️ Jobs lost on restart!\n    logger: logger\n)\n\n// ❌ Wrong — blocking shutdown without graceful handling\nstruct JobQueueService: Service {\n    func run() async throws {\n        try await queue.run()\n        // ⚠️ No graceful shutdown — in-flight jobs terminated abruptly!\n    }\n}\n\n// ❌ Wrong — shared mutable job state without actor protection\nvar jobResults: [UUID: JobResult] = [:] // ⚠️ Data race!\n\nstruct JobHandler: JobHandler {\n    func execute(job: JobData, context: JobContext) async throws {\n        let result = try await process(job)\n        jobResults[context.id] = result // ⚠️ Concurrent access — data race!\n    }\n}\n```\n\nKey requirements:\n- Use persistent job queue backend (PostgresJobQueue, RedisJobQueue) for production\n- Register job handlers with descriptive type names\n- Configure retry strategy with exponential backoff\n- Implement graceful shutdown to complete in-flight jobs\n- Add idempotency checks for critical operations (payments, emails)\n- Log job lifecycle events (enqueue, start, complete, fail)\n- Store job metadata (job ID, timestamps, retry count) for debugging\n- Never process long-running tasks synchronously in route handlers\n- Protect shared job state with actors\n- Set appropriate `maxRetries` based on job criticality\n- Use `scheduledAt` for delayed job execution\n- Create database indexes on job status and scheduled_at for efficient polling\n\nRetry strategies:\n- `.exponentialBackoff(initialDelay:multiplier:maxDelay:)` — doubles delay between retries (recommended)\n- `.constantInterval(delay:)` — fixed delay between retries\n- `.custom((Int) -> Duration)` — custom retry delay function\n\nJob lifecycle:\n1. Enqueued → job created and persisted with status \"pending\"\n2. Processing → worker picks up job, status \"processing\"\n3. Completed → job finishes successfully, status \"completed\"\n4. Failed → job throws error, retry count incremented\n5. Retry → job re-enqueued with exponential backoff delay\n6. Abandoned → max retries exceeded, status \"failed\"\n\nCommon pitfalls:\n- Processing jobs synchronously in route handlers (blocks HTTP thread)\n- Using in-memory queue in production (jobs lost on restart)\n- No idempotency protection for critical operations (duplicate processing)\n- Missing graceful shutdown (in-flight jobs terminated)\n- Shared mutable state without actor protection (data races)\n- No retry logic or error handling (transient failures cause job loss)\n- Hardcoded retry configuration (should be configurable per job type)",
    "layer": "service",
    "patternIds": ["background-jobs", "job-queue", "retry-logic", "job-persistence", "hummingbird-jobs", "service-lifecycle"],
    "violationIds": ["sync-job-in-handler", "missing-job-retry", "missing-job-idempotency", "in-memory-job-queue", "missing-graceful-job-shutdown", "shared-job-state-without-actor"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  },
  {
    "id": "request-context-customization",
    "title": "Custom RequestContext Protocol Conformance and Extension Patterns",
    "content": "Hummingbird 2.x allows full customization of the request context through the `RequestContext` protocol. Custom contexts must store Hummingbird's `CoreRequestContextStorage` and can extend the context with application-specific properties like dependency injection containers, user authentication state, or request-scoped services.\n\n```swift\nimport Hummingbird\n\n// ✅ Correct — minimal custom RequestContext with CoreRequestContextStorage\nstruct AppRequestContext: RequestContext {\n    /// REQUIRED: Hummingbird's core context storage\n    /// Contains: logger, allocator, parameters, endpointPath, coreMiddleware\n    var coreContext: CoreRequestContextStorage\n\n    /// Application-specific dependency injection container\n    /// Set by DependencyInjectionMiddleware at the start of each request\n    var dependencies: AppDependencies!\n\n    /// Required initializer from RequestContext protocol\n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        // Note: dependencies is initialized by middleware, not here\n    }\n}\n\n// ✅ Correct — extended RequestContext with additional properties\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies!\n    \n    /// Request-scoped authentication state\n    /// Set by AuthenticationMiddleware after token validation\n    var authenticatedUser: User?\n    \n    /// Request-scoped correlation ID for distributed tracing\n    /// Set by TracingMiddleware from X-Correlation-ID header or generated\n    var correlationID: UUID\n    \n    /// Request-scoped feature flags\n    /// Resolved by FeatureFlagMiddleware based on user, environment, A/B test\n    var featureFlags: FeatureFlags\n    \n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        self.correlationID = UUID()\n        self.featureFlags = FeatureFlags.defaults\n    }\n}\n\n// ✅ Correct — middleware that extends context properties\nstruct AuthenticationMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    let authService: AuthenticationService\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var ctx = context\n        \n        // Extract and validate authentication token\n        if let authHeader = request.headers[.authorization],\n           let token = authHeader.dropFirst(\"Bearer \".count).nilIfEmpty {\n            do {\n                // Validate token and populate context.authenticatedUser\n                ctx.authenticatedUser = try await authService.validate(token: String(token))\n                \n                ctx.logger.info(\n                    \"Request authenticated\",\n                    metadata: [\n                        \"userId\": \"\\(ctx.authenticatedUser!.id)\",\n                        \"correlationId\": \"\\(ctx.correlationID)\"\n                    ]\n                )\n            } catch {\n                ctx.logger.warning(\n                    \"Authentication failed\",\n                    metadata: [\"error\": \"\\(error)\", \"correlationId\": \"\\(ctx.correlationID)\"]\n                )\n                // Continue with nil authenticatedUser for optional auth routes\n            }\n        }\n        \n        // Thread updated context through middleware chain\n        return try await next(request, ctx)\n    }\n}\n\n// ✅ Correct — accessing custom context properties in route handlers\nrouter.get(\"/profile\") { request, context in\n    // Access custom authentication state from context\n    guard let user = context.authenticatedUser else {\n        throw HTTPError(.unauthorized, message: \"Authentication required\")\n    }\n    \n    // Access dependency injection container from context\n    let profile = try await context.dependencies.userService.getProfile(userID: user.id)\n    \n    // Access correlation ID for logging\n    context.logger.info(\n        \"Profile retrieved\",\n        metadata: [\"userId\": \"\\(user.id)\", \"correlationId\": \"\\(context.correlationID)\"]\n    )\n    \n    return ProfileResponse(profile)\n}\n\n// ✅ Correct — feature flag middleware with context extension\nstruct FeatureFlagMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    let featureFlagService: FeatureFlagService\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var ctx = context\n        \n        // Resolve feature flags based on user, environment, and A/B testing\n        ctx.featureFlags = await featureFlagService.resolve(\n            user: ctx.authenticatedUser,\n            environment: ctx.dependencies.configuration.environment,\n            requestID: ctx.correlationID\n        )\n        \n        return try await next(request, ctx)\n    }\n}\n\n// ✅ Correct — using feature flags from context in handlers\nrouter.get(\"/dashboard\") { request, context in\n    guard let user = context.authenticatedUser else {\n        throw HTTPError(.unauthorized)\n    }\n    \n    // Access feature flags from context\n    let dashboard = if context.featureFlags.newDashboardEnabled {\n        try await context.dependencies.dashboardService.getV2Dashboard(for: user.id)\n    } else {\n        try await context.dependencies.dashboardService.getV1Dashboard(for: user.id)\n    }\n    \n    return DashboardResponse(dashboard)\n}\n\n// ✅ Correct — correlation ID middleware\nstruct CorrelationIDMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var ctx = context\n        \n        // Use correlation ID from header if present, otherwise generate new one\n        if let headerValue = request.headers[\"X-Correlation-ID\"],\n           let id = UUID(uuidString: String(headerValue)) {\n            ctx.correlationID = id\n        } else {\n            ctx.correlationID = UUID()\n        }\n        \n        // Add correlation ID to response headers for tracing\n        var response = try await next(request, ctx)\n        response.headers.replaceOrAdd(\n            name: \"X-Correlation-ID\",\n            value: ctx.correlationID.uuidString\n        )\n        \n        return response\n    }\n}\n\n// ✅ Correct — dependency injection middleware (CRITICAL PATTERN)\nstruct DependencyInjectionMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    let dependencies: AppDependencies\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        var ctx = context\n        \n        // Populate dependencies — MUST run before any route handler\n        ctx.dependencies = dependencies\n        \n        return try await next(request, ctx)\n    }\n}\n\n// ✅ Correct — middleware registration order (CRITICAL)\nfunc buildRouter(dependencies: AppDependencies) -> Router<AppRequestContext> {\n    let router = Router(context: AppRequestContext.self)\n    \n    // Order matters! DependencyInjectionMiddleware MUST be first\n    router.add(middleware: DependencyInjectionMiddleware(dependencies: dependencies))\n    router.add(middleware: CorrelationIDMiddleware())\n    router.add(middleware: AuthenticationMiddleware(authService: dependencies.authService))\n    router.add(middleware: FeatureFlagMiddleware(featureFlagService: dependencies.featureFlagService))\n    \n    // Routes registered after middleware\n    router.get(\"/profile\") { request, context in\n        // All middleware has run — context is fully populated\n        // dependencies, correlationID, authenticatedUser, featureFlags all available\n        ...\n    }\n    \n    return router\n}\n\n// ✅ Correct — CoreRequestContextStorage provides access to core properties\nrouter.get(\"/debug\") { request, context in\n    // Access logger from coreContext (also available as context.logger)\n    context.logger.info(\"Debug endpoint called\")\n    context.coreContext.logger.info(\"Same logger, accessed via coreContext\")\n    \n    // Access ByteBuffer allocator for efficient memory management\n    var buffer = context.allocator.buffer(capacity: 1024)\n    buffer.writeString(\"Response data\")\n    \n    // Access route parameters (populated by router)\n    let id = try context.parameters.require(\"id\", as: UUID.self)\n    \n    // Access matched endpoint path for logging/metrics\n    context.logger.info(\n        \"Request processed\",\n        metadata: [\"endpointPath\": \"\\(context.endpointPath)\"]\n    )\n    \n    return Response(status: .ok, body: .init(byteBuffer: buffer))\n}\n\n// ✅ Correct — request-scoped cache in context\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies!\n    \n    /// Request-scoped cache for expensive computations\n    /// Example: Cache decoded JWT claims to avoid re-parsing token multiple times\n    private(set) var cache: [String: Any] = [:]\n    \n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n    }\n    \n    mutating func setCacheValue<T>(_ value: T, forKey key: String) {\n        cache[key] = value\n    }\n    \n    func getCacheValue<T>(forKey key: String) -> T? {\n        cache[key] as? T\n    }\n}\n\n// Using request-scoped cache\nrouter.get(\"/user/permissions\") { request, context in\n    var ctx = context\n    \n    // Check cache first\n    if let cachedPermissions: [Permission] = ctx.getCacheValue(forKey: \"user.permissions\") {\n        return PermissionsResponse(cachedPermissions)\n    }\n    \n    // Compute and cache for this request\n    let permissions = try await ctx.dependencies.permissionService.getPermissions(\n        for: ctx.authenticatedUser!.id\n    )\n    ctx.setCacheValue(permissions, forKey: \"user.permissions\")\n    \n    return PermissionsResponse(permissions)\n}\n\n// ❌ Wrong — missing CoreRequestContextStorage\nstruct AppRequestContext: RequestContext {\n    var dependencies: AppDependencies!\n    // ⚠️ COMPILER ERROR: RequestContext protocol requires coreContext property\n    \n    init(source: Source) {\n        // ⚠️ CoreRequestContextStorage never initialized\n    }\n}\n\n// ❌ Wrong — directly storing CoreRequestContextStorage properties instead of embedding it\nstruct AppRequestContext: RequestContext {\n    // ⚠️ Wrong approach — should use coreContext: CoreRequestContextStorage\n    var logger: Logger\n    var allocator: ByteBufferAllocator\n    var parameters: Parameters\n    \n    var dependencies: AppDependencies!\n    \n    init(source: Source) {\n        self.logger = source.logger\n        self.allocator = source.channel.allocator\n        self.parameters = Parameters()\n    }\n}\n\n// ❌ Wrong — not threading context through middleware\nstruct AuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        // Modify context\n        var ctx = context\n        ctx.authenticatedUser = try await validate(request)\n        \n        // ⚠️ BUG: Passing original context instead of modified ctx!\n        // Changes to ctx.authenticatedUser are lost!\n        return try await next(request, context)\n    }\n}\n\n// ❌ Wrong — accessing dependencies before DependencyInjectionMiddleware runs\nrouter.get(\"/users\") { request, context in\n    // ⚠️ RUNTIME CRASH: context.dependencies is nil!\n    // DependencyInjectionMiddleware must run FIRST in middleware chain\n    return try await context.dependencies.userService.list()\n}\n\n// ❌ Wrong — initializing dependencies in context init\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies\n    \n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        // ⚠️ WRONG: Creates new AppDependencies per request (expensive!)\n        // Should be set by middleware, not initialized here\n        self.dependencies = AppDependencies(...)\n    }\n}\n\n// ❌ Wrong — mutable context properties without threading through middleware\nrouter.add(middleware: MyMiddleware())\nrouter.add(middleware: OtherMiddleware())\n\nstruct MyMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    \n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        context.customProperty = \"value\" // ⚠️ COMPILER ERROR: context is immutable\n        // Must use: var ctx = context; ctx.customProperty = \"value\"; next(request, ctx)\n        return try await next(request, context)\n    }\n}\n```\n\nKey requirements:\n\n**RequestContext Protocol Conformance:**\n- Must have `var coreContext: CoreRequestContextStorage` property (REQUIRED)\n- Must implement `init(source: Source)` (REQUIRED)\n- Must initialize `coreContext` with `CoreRequestContextStorage(source: source)`\n- Can add custom properties (dependencies, user, correlation ID, feature flags, cache)\n\n**CoreRequestContextStorage Provides:**\n- `logger: Logger` — request-scoped logger\n- `allocator: ByteBufferAllocator` — for efficient buffer allocation\n- `parameters: Parameters` — route path parameters\n- `endpointPath: String` — matched route pattern\n- Internal middleware state management\n\n**Threading Context Through Middleware:**\n1. Create mutable copy: `var ctx = context`\n2. Modify properties: `ctx.authenticatedUser = user`\n3. Pass modified context to next: `next(request, ctx)` (NOT `next(request, context)`)\n\n**Middleware Registration Order:**\n1. `DependencyInjectionMiddleware` — MUST BE FIRST (populates dependencies)\n2. `CorrelationIDMiddleware` — adds tracing ID\n3. `AuthenticationMiddleware` — validates token, populates user\n4. `FeatureFlagMiddleware` — resolves feature flags\n5. Route handlers (access fully-populated context)\n\n**Common Patterns:**\n- **Dependency Injection**: `var dependencies: AppDependencies!` (IUO, set by middleware)\n- **Authentication State**: `var authenticatedUser: User?` (optional, set by auth middleware)\n- **Correlation ID**: `var correlationID: UUID` (for distributed tracing)\n- **Feature Flags**: `var featureFlags: FeatureFlags` (A/B testing, gradual rollouts)\n- **Request-Scoped Cache**: `private(set) var cache: [String: Any] = [:]` (avoid duplicate work)\n\n**Accessing Context in Route Handlers:**\n```swift\nrouter.get(\"/example\") { request, context in\n    // Core properties (from CoreRequestContextStorage)\n    context.logger.info(\"Log message\")\n    let buffer = context.allocator.buffer(capacity: 1024)\n    let id = try context.parameters.require(\"id\")\n    \n    // Custom properties (from AppRequestContext)\n    let user = context.authenticatedUser // Set by AuthenticationMiddleware\n    let service = context.dependencies.userService // Set by DependencyInjectionMiddleware\n    let correlationID = context.correlationID // Set by CorrelationIDMiddleware\n    \n    return Response(status: .ok)\n}\n```\n\n**Common Pitfalls:**\n- Missing `coreContext: CoreRequestContextStorage` (compiler error)\n- Not threading modified context through middleware (context changes lost)\n- Accessing `dependencies` before `DependencyInjectionMiddleware` runs (nil crash)\n- Initializing dependencies in `init(source:)` instead of middleware (expensive, wrong pattern)\n- Registering middleware in wrong order (dependencies must be first)\n- Trying to mutate `context` directly instead of creating `var ctx = context`\n- Storing request-specific mutable state outside context (data races, wrong values)\n\n**Why Use Custom RequestContext:**\n- Type-safe dependency injection (no service locator magic)\n- Request-scoped state (authentication, tracing, feature flags)\n- Thread-safe by design (context is value type, copied through middleware)\n- Testable (mock context with fake dependencies)\n- Framework-agnostic services (context injected, not framework-coupled)\n- Single source of truth for request state",
    "layer": "context",
    "patternIds": ["request-context", "dependency-injection", "middleware-chain", "context-threading", "core-request-context-storage"],
    "violationIds": ["missing-core-context", "context-not-threaded", "dependencies-before-middleware", "init-dependencies-in-context", "direct-context-mutation"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2026-03-01T00:00:00Z"
  }
]
