[
  {
    "id": "route-handler-dispatcher-only",
    "title": "Route Handlers Are Dispatchers Only",
    "content": "In Hummingbird 2.x clean architecture, route handlers have exactly one job: dispatch to the service layer and return the result. They must not contain business logic, database calls, or service construction.\n\n```swift\n// ✅ Correct — pure dispatcher\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    let user = try await context.dependencies.userService.create(dto)\n    return CreateUserResponse(user)\n}\n\n// ❌ Wrong — business logic in handler\nrouter.post(\"/users\") { request, context in\n    let dto = try await request.decode(as: CreateUserRequest.self, context: context)\n    guard !dto.email.isEmpty else { throw HTTPError(.badRequest) }\n    let hashed = BCrypt.hash(dto.password)\n    let user = User(email: dto.email, passwordHash: hashed)\n    try await db.save(user)\n    return user\n}\n```",
    "layer": "controller",
    "patternIds": ["dispatcher-pattern", "thin-controller"],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-layer-no-hummingbird",
    "title": "Service Layer Must Not Import Hummingbird",
    "content": "The service layer encodes business logic independently of any web framework. No Hummingbird import means the service can be tested without an HTTP context and can be reused across transports.\n\n```swift\n// ✅ Correct — pure Swift service\nimport Foundation\n\nstruct UserService {\n    let repository: any UserRepositoryProtocol\n\n    func create(_ request: CreateUserRequest) async throws -> User {\n        guard !request.email.isEmpty else {\n            throw AppError.invalidInput(reason: \"Email must not be empty\")\n        }\n        return try await repository.insert(User(email: request.email))\n    }\n}\n\n// ❌ Wrong — Hummingbird leaked into service layer\nimport Hummingbird\n\nstruct UserService {\n    func create(_ req: Request) async throws -> Response { ... }\n}\n```",
    "layer": "service",
    "patternIds": ["framework-agnostic-service"],
    "violationIds": ["hummingbird-import-in-service"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dependency-injection-via-context",
    "title": "Inject Dependencies via AppRequestContext",
    "content": "All dependencies (services, repositories, stores) must be accessed through `AppRequestContext.dependencies`. This gives you a single, testable, type-safe injection point with zero service-locator magic.\n\n```swift\n// ✅ Correct — from AppRequestContext\nrouter.get(\"/users/:id\") { request, context in\n    let id = try context.parameters.require(\"id\")\n    return try await context.dependencies.userService.find(id: id)\n}\n\n// ❌ Wrong — constructed inline\nrouter.get(\"/users/:id\") { request, context in\n    let repo = PostgresUserRepository(pool: globalPool)\n    let service = UserService(repository: repo)\n    return try await service.find(id: request.uri.path)\n}\n```",
    "layer": "context",
    "patternIds": ["dependency-injection", "context-as-container"],
    "violationIds": ["service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "typed-errors-app-error",
    "title": "All Errors Are Typed AppError Values",
    "content": "Every error that crosses a layer boundary must be an `AppError`. Raw third-party errors are caught and wrapped immediately. This keeps HTTP response codes consistent and prevents internal details from leaking to clients.\n\n```swift\n// ✅ Correct — wrap at the boundary\nfunc findUser(id: String) async throws -> User {\n    do {\n        return try await repository.find(id: id)\n    } catch let dbError as DatabaseError {\n        throw AppError.internalError(reason: dbError.localizedDescription)\n    }\n}\n\n// ❌ Wrong — raw error propagates\nfunc findUser(id: String) async throws -> User {\n    return try await repository.find(id: id) // DatabaseError leaks up\n}\n```",
    "layer": null,
    "patternIds": ["typed-errors", "error-wrapping"],
    "violationIds": ["raw-error-thrown-from-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "dtos-at-boundaries",
    "title": "DTOs at Every HTTP Boundary",
    "content": "Domain models must never cross the HTTP layer raw. A DTO (Data Transfer Object) gives you a stable public contract independent of internal model evolution.\n\n```swift\n// ✅ Correct — DTO at the boundary\nstruct UserResponse: Codable, ResponseCodable {\n    let id: String\n    let email: String\n    let createdAt: Date\n\n    init(_ user: User) {\n        self.id = user.id.uuidString\n        self.email = user.email\n        self.createdAt = user.createdAt\n    }\n}\n\n// Handler returns DTO, not domain model\nrouter.get(\"/users/:id\") { request, context in\n    let user = try await context.dependencies.userService.find(...)\n    return UserResponse(user) // never `return user` directly\n}\n```",
    "layer": "controller",
    "patternIds": ["dto-pattern", "api-boundary"],
    "violationIds": ["domain-model-across-http-boundary"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "actor-for-shared-state",
    "title": "Use Actors for Shared Mutable State",
    "content": "Any mutable state shared across concurrent requests must be protected by a Swift actor. In Swift 6 strict concurrency mode this is enforced at compile time.\n\n```swift\n// ✅ Correct — actor-protected\nactor RateLimitStore {\n    private var windows: [String: [Date]] = [:]\n\n    func recordRequest(from ip: String, limit: Int) -> Bool {\n        // Safe — all access serialised by the actor\n        ...\n    }\n}\n\n// ❌ Wrong — data race in Swift 6\nvar requestCounts: [String: Int] = [:] // module-level var\n\nrouter.get(\"/\") { request, context in\n    requestCounts[request.uri.path, default: 0] += 1 // data race!\n    ...\n}\n```",
    "layer": "middleware",
    "patternIds": ["actor-model", "swift-concurrency"],
    "violationIds": ["shared-mutable-state-without-actor"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "request-context-di",
    "title": "AppRequestContext as the DI Container",
    "content": "Hummingbird 2.x uses a custom `RequestContext` to thread per-request state. `AppRequestContext` extends this to carry the application's dependency graph. `DependencyInjectionMiddleware` populates it at the start of every request.\n\n```swift\n// The context definition\nstruct AppRequestContext: RequestContext {\n    var coreContext: CoreRequestContextStorage\n    var dependencies: AppDependencies\n\n    init(source: Source) {\n        self.coreContext = CoreRequestContextStorage(source: source)\n        self.dependencies = AppDependencies.placeholder\n    }\n}\n\n// The middleware that fills it in\nstruct DependencyInjectionMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    let dependencies: AppDependencies\n\n    func handle(_ request: Request, context: AppRequestContext,\n                next: (Request, AppRequestContext) async throws -> Response) async throws -> Response {\n        var ctx = context\n        ctx.dependencies = dependencies\n        return try await next(request, ctx)\n    }\n}\n```",
    "layer": "context",
    "patternIds": ["request-context", "middleware-di"],
    "violationIds": ["nonisolated-context-access"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "router-middleware-pattern",
    "title": "RouterMiddleware Protocol Pattern",
    "content": "Hummingbird 2.x middleware conforms to `RouterMiddleware`. The associated `Context` type binds the middleware to a specific request context. Middleware is added to the router before routes are registered — order matters.\n\n```swift\nstruct AuthMiddleware: RouterMiddleware {\n    typealias Context = AppRequestContext\n    private let token: String\n\n    func handle(\n        _ request: Request,\n        context: AppRequestContext,\n        next: (Request, AppRequestContext) async throws -> Response\n    ) async throws -> Response {\n        guard let header = request.headers[.authorization],\n              header == \"Bearer \\(token)\" else {\n            throw HTTPError(.unauthorized)\n        }\n        return try await next(request, context)\n    }\n}\n\n// Registration order matters — add before routes\nrouter.add(middleware: DependencyInjectionMiddleware(...))\nrouter.add(middleware: AuthMiddleware(token: ...))\nrouter.get(\"/protected\") { ... }\n```",
    "layer": "middleware",
    "patternIds": ["middleware-chain", "request-pipeline"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "service-lifecycle-background-service",
    "title": "Background Services via Service Lifecycle",
    "content": "Hummingbird 2.x uses `swift-service-lifecycle` for background work. Implement `Service` and add to the application. The service group manages startup, shutdown, and graceful termination automatically.\n\n```swift\nimport Hummingbird\n\nstruct CacheRefreshService: Service {\n    let cache: CacheStore\n    let interval: Duration\n    let logger: Logger\n\n    func run() async throws {\n        while !Task.isCancelled {\n            do {\n                try await cache.refresh()\n                logger.info(\"Cache refreshed\")\n            } catch {\n                logger.warning(\"Cache refresh failed\", metadata: [\"error\": \"\\(error)\"])\n            }\n            try await Task.sleep(for: interval)\n        }\n    }\n}\n\n// In Application+build.swift:\napp.addServices(CacheRefreshService(cache: cache, interval: .seconds(3600), logger: logger))\n```",
    "layer": "service",
    "patternIds": ["service-lifecycle", "background-service"],
    "violationIds": [],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": false,
    "correctionId": null,
    "confidence": 0.95,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  },
  {
    "id": "inline-handler-anti-pattern",
    "title": "Anti-Pattern: All Logic Inline in Route Handlers",
    "content": "Tutorials often show all logic inline in a route handler for brevity. This is an anti-pattern in production code: it creates untestable handlers, couples framework to business logic, and makes layers impossible to reason about independently.\n\n```swift\n// ❌ ANTI-PATTERN — tutorial style, not production style\nrouter.post(\"/register\") { request, context in\n    struct Body: Decodable { var email: String; var password: String }\n    let body = try await request.decode(as: Body.self, context: context)\n    guard !body.email.isEmpty else { return Response(status: .badRequest) }\n    let hash = SHA256.hash(data: Data(body.password.utf8)).description\n    // Directly using global DB connection:\n    try await db.execute(\"INSERT INTO users ...\", [body.email, hash])\n    return Response(status: .created)\n}\n```\n\nThe correct approach uses the service layer for all business logic, the repository for DB access, and the context for injection.",
    "layer": "controller",
    "patternIds": [],
    "violationIds": ["inline-db-in-handler", "service-construction-in-handler"],
    "hummingbirdVersionRange": ">=2.0.0",
    "swiftVersionRange": ">=6.0",
    "isTutorialPattern": true,
    "correctionId": "route-handler-dispatcher-only",
    "confidence": 1.0,
    "source": "embedded",
    "lastVerifiedAt": "2025-01-01T00:00:00Z"
  }
]
